{"ast":null,"code":"import { Coord3D } from '../geometry/coord3d.js';\nimport { Direction } from '../geometry/geometry.js';\nimport { BinaryReader } from '../io/binaryreader.js';\nimport { ArrayBufferToUtf8String } from '../io/bufferutils.js';\nimport { RGBColor, IntegerToHexString } from '../model/color.js';\nimport { PhongMaterial } from '../model/material.js';\nimport { Mesh } from '../model/mesh.js';\nimport { Triangle } from '../model/triangle.js';\nimport { ImporterBase } from './importerbase.js';\nimport { ParametersFromLine, ReadLines, UpdateMaterialTransparency } from './importerutils.js';\nconst PlyHeaderCheckResult = {\n  Ok: 1,\n  NoVertices: 2,\n  NoFaces: 3,\n  UnknownError: 4\n};\n\nclass PlyHeader {\n  constructor() {\n    this.format = null;\n    this.elements = [];\n  }\n\n  SetFormat(format) {\n    this.format = format;\n  }\n\n  AddElement(name, count) {\n    this.elements.push({\n      name: name,\n      count: count,\n      format: []\n    });\n  }\n\n  GetElements() {\n    return this.elements;\n  }\n\n  AddSingleFormat(elemType, name) {\n    let lastElement = this.elements[this.elements.length - 1];\n    lastElement.format.push({\n      name: name,\n      isSingle: true,\n      elemType: elemType\n    });\n  }\n\n  AddListFormat(countType, elemType, name) {\n    let lastElement = this.elements[this.elements.length - 1];\n    lastElement.format.push({\n      name: name,\n      isSingle: false,\n      countType: countType,\n      elemType: elemType\n    });\n  }\n\n  GetElement(name) {\n    for (let i = 0; i < this.elements.length; i++) {\n      let element = this.elements[i];\n\n      if (element.name === name) {\n        return element;\n      }\n    }\n\n    return null;\n  }\n\n  Check() {\n    let vertex = this.GetElement('vertex');\n\n    if (vertex === null || vertex.length === 0 || vertex.format.length < 3) {\n      return PlyHeaderCheckResult.NoVertices;\n    }\n\n    let face = this.GetElement('face');\n\n    if (this.format === 'ascii') {\n      if (face === null || face.count === 0 || face.format.length < 0) {\n        return PlyHeaderCheckResult.NoFaces;\n      }\n    } else if (this.format === 'binary_little_endian' || this.format === 'binary_big_endian') {\n      let triStrips = this.GetElement('tristrips');\n      let hasFaces = face !== null && face.count > 0 && face.format.length > 0;\n      let hasTriStrips = triStrips !== null && triStrips.count > 0 && triStrips.format.length > 0;\n\n      if (!hasFaces && !hasTriStrips) {\n        return PlyHeaderCheckResult.NoFaces;\n      }\n    } else {\n      return PlyHeaderCheckResult.UnknownError;\n    }\n\n    return PlyHeaderCheckResult.Ok;\n  }\n\n}\n\nclass PlyMaterialHandler {\n  constructor(model) {\n    this.model = model;\n    this.colorToMaterial = new Map();\n  }\n\n  GetMaterialIndexByColor(color) {\n    let materialName = 'Color ' + IntegerToHexString(color[0]) + IntegerToHexString(color[1]) + IntegerToHexString(color[2]) + IntegerToHexString(color[3]);\n\n    if (this.colorToMaterial.has(materialName)) {\n      return this.colorToMaterial.get(materialName);\n    } else {\n      let material = new PhongMaterial();\n      material.name = materialName;\n      material.color = new RGBColor(color[0], color[1], color[2]);\n      material.opacity = color[3] / 255.0;\n      UpdateMaterialTransparency(material);\n      let materialIndex = this.model.AddMaterial(material);\n      this.colorToMaterial.set(materialName, materialIndex);\n      return materialIndex;\n    }\n  }\n\n}\n\nexport class ImporterPly extends ImporterBase {\n  constructor() {\n    super();\n  }\n\n  CanImportExtension(extension) {\n    return extension === 'ply';\n  }\n\n  GetUpDirection() {\n    return Direction.Y;\n  }\n\n  ClearContent() {\n    this.mesh = null;\n  }\n\n  ResetContent() {\n    this.mesh = new Mesh();\n    this.model.AddMeshToRootNode(this.mesh);\n  }\n\n  ImportContent(fileContent, onFinish) {\n    let headerString = this.GetHeaderContent(fileContent);\n    let header = this.ReadHeader(headerString);\n    let checkResult = header.Check();\n\n    if (checkResult === PlyHeaderCheckResult.Ok) {\n      if (header.format === 'ascii') {\n        let contentString = ArrayBufferToUtf8String(fileContent);\n        contentString = contentString.substring(headerString.length);\n        this.ReadAsciiContent(header, contentString);\n      } else if (header.format === 'binary_little_endian' || header.format === 'binary_big_endian') {\n        this.ReadBinaryContent(header, fileContent, headerString.length);\n      }\n    } else {\n      if (checkResult === PlyHeaderCheckResult.NoVertices) {\n        this.SetError('The model contains no vertices.');\n      } else if (checkResult === PlyHeaderCheckResult.NoFaces) {\n        this.SetError('The model contains no faces.');\n      } else {\n        this.SetError('Invalid header information.');\n      }\n    }\n\n    onFinish();\n  }\n\n  GetHeaderContent(fileContent) {\n    let headerContent = '';\n    let bufferView = new Uint8Array(fileContent);\n    let bufferIndex = 0;\n\n    for (bufferIndex = 0; bufferIndex < fileContent.byteLength; bufferIndex++) {\n      headerContent += String.fromCharCode(bufferView[bufferIndex]);\n\n      if (headerContent.endsWith('end_header')) {\n        break;\n      }\n    }\n\n    bufferIndex += 1;\n\n    while (bufferIndex < fileContent.byteLength) {\n      let char = String.fromCharCode(bufferView[bufferIndex]);\n      headerContent += char;\n      bufferIndex += 1;\n\n      if (char === '\\n') {\n        break;\n      }\n    }\n\n    return headerContent;\n  }\n\n  ReadHeader(headerContent) {\n    let header = new PlyHeader();\n    ReadLines(headerContent, line => {\n      let parameters = ParametersFromLine(line, null);\n\n      if (parameters.length === 0 || parameters[0] === 'comment') {\n        return;\n      }\n\n      if (parameters[0] === 'ply') {\n        return;\n      } else if (parameters[0] === 'format' && parameters.length >= 2) {\n        header.SetFormat(parameters[1]);\n      } else if (parameters[0] === 'element' && parameters.length >= 3) {\n        header.AddElement(parameters[1], parseInt(parameters[2], 10));\n      } else if (parameters[0] === 'property' && parameters.length >= 3) {\n        if (parameters[1] === 'list' && parameters.length >= 5) {\n          header.AddListFormat(parameters[2], parameters[3], parameters[4]);\n        } else {\n          header.AddSingleFormat(parameters[1], parameters[2]);\n        }\n      }\n    });\n    return header;\n  }\n\n  ReadAsciiContent(header, fileContent) {\n    let vertex = header.GetElement('vertex');\n    let face = header.GetElement('face');\n    let foundVertex = 0;\n    let foundFace = 0;\n    ReadLines(fileContent, line => {\n      if (this.WasError()) {\n        return;\n      }\n\n      let parameters = ParametersFromLine(line, null);\n\n      if (parameters.length === 0 || parameters[0] === 'comment') {\n        return;\n      }\n\n      if (foundVertex < vertex.count) {\n        if (parameters.length >= 3) {\n          this.mesh.AddVertex(new Coord3D(parseFloat(parameters[0]), parseFloat(parameters[1]), parseFloat(parameters[2])));\n          foundVertex += 1;\n        }\n\n        return;\n      }\n\n      if (face !== null && foundFace < face.count) {\n        if (parameters.length >= 4) {\n          let vertexCount = parseInt(parameters[0], 10);\n\n          if (parameters.length < vertexCount + 1) {\n            return;\n          }\n\n          for (let i = 0; i < vertexCount - 2; i++) {\n            let v0 = parseInt(parameters[1]);\n            let v1 = parseInt(parameters[i + 2]);\n            let v2 = parseInt(parameters[i + 3]);\n            let triangle = new Triangle(v0, v1, v2);\n            this.mesh.AddTriangle(triangle);\n          }\n\n          foundFace += 1;\n        }\n\n        return;\n      }\n    });\n  }\n\n  ReadBinaryContent(header, fileContent, headerLength) {\n    function ReadByFormat(reader, format) {\n      function ReadType(reader, type) {\n        if (type === 'char' || type === 'int8') {\n          return reader.ReadCharacter8();\n        } else if (type === 'uchar' || type === 'uint8') {\n          return reader.ReadUnsignedCharacter8();\n        } else if (type === 'short' || type === 'int16') {\n          return reader.ReadInteger16();\n        } else if (type === 'ushort' || type === 'uint16') {\n          return reader.ReadUnsignedInteger16();\n        } else if (type === 'int' || type === 'int32') {\n          return reader.ReadInteger32();\n        } else if (type === 'uint' || type === 'uint32') {\n          return reader.ReadUnsignedInteger32();\n        } else if (type === 'float' || type === 'float32') {\n          return reader.ReadFloat32();\n        } else if (type === 'double' || type === 'double64') {\n          return reader.ReadDouble64();\n        }\n\n        return null;\n      }\n\n      if (format.isSingle) {\n        return ReadType(reader, format.elemType);\n      } else {\n        let list = [];\n        let count = ReadType(reader, format.countType);\n\n        for (let i = 0; i < count; i++) {\n          list.push(ReadType(reader, format.elemType));\n        }\n\n        return list;\n      }\n    }\n\n    function SkipFormat(reader, format, startIndex) {\n      for (let i = startIndex; i < format.length; i++) {\n        ReadByFormat(reader, format[i]);\n      }\n    }\n\n    function SkipAndGetColor(reader, format, startIndex) {\n      let r = null;\n      let g = null;\n      let b = null;\n      let a = 255;\n\n      for (let i = startIndex; i < format.length; i++) {\n        let currFormat = format[i];\n        let val = ReadByFormat(reader, currFormat);\n\n        if (currFormat.name === 'red') {\n          r = val;\n        } else if (currFormat.name === 'green') {\n          g = val;\n        } else if (currFormat.name === 'blue') {\n          b = val;\n        } else if (currFormat.name === 'alpha') {\n          a = val;\n        }\n      }\n\n      if (r !== null && g !== null && b !== null) {\n        return [r, g, b, a];\n      }\n\n      return null;\n    }\n\n    let reader = null;\n\n    if (header.format === 'binary_little_endian') {\n      reader = new BinaryReader(fileContent, true);\n    } else if (header.format === 'binary_big_endian') {\n      reader = new BinaryReader(fileContent, false);\n    } else {\n      return;\n    }\n\n    reader.Skip(headerLength);\n    let materialHandler = new PlyMaterialHandler(this.model);\n    let elements = header.GetElements();\n\n    for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {\n      let element = elements[elementIndex];\n\n      if (element.name === 'vertex') {\n        for (let vertexIndex = 0; vertexIndex < element.count; vertexIndex++) {\n          let x = ReadByFormat(reader, element.format[0]);\n          let y = ReadByFormat(reader, element.format[1]);\n          let z = ReadByFormat(reader, element.format[2]);\n          let color = SkipAndGetColor(reader, element.format, 3);\n\n          if (color !== null) {\n            this.mesh.AddVertexColor(new RGBColor(color[0], color[1], color[2]));\n          }\n\n          this.mesh.AddVertex(new Coord3D(x, y, z));\n        }\n      } else if (element.name === 'face') {\n        for (let faceIndex = 0; faceIndex < element.count; faceIndex++) {\n          let vertices = ReadByFormat(reader, element.format[0]);\n          let faceColor = SkipAndGetColor(reader, element.format, 1);\n\n          for (let i = 0; i < vertices.length - 2; i++) {\n            let v0 = vertices[0];\n            let v1 = vertices[i + 1];\n            let v2 = vertices[i + 2];\n            let triangle = new Triangle(v0, v1, v2);\n\n            if (faceColor !== null) {\n              triangle.mat = materialHandler.GetMaterialIndexByColor(faceColor);\n            } else if (this.mesh.VertexColorCount() > 0) {\n              triangle.SetVertexColors(v0, v1, v2);\n            }\n\n            this.mesh.AddTriangle(triangle);\n          }\n        }\n      } else if (element.name === 'tristrips') {\n        for (let triStripIndex = 0; triStripIndex < element.count; triStripIndex++) {\n          let vertices = ReadByFormat(reader, element.format[0]);\n          SkipFormat(reader, element.format, 1);\n          let ccw = true;\n\n          for (let i = 0; i < vertices.length - 2; i++) {\n            let v0 = vertices[i];\n            let v1 = vertices[i + 1];\n            let v2 = vertices[i + 2];\n\n            if (v2 === -1) {\n              i += 2;\n              ccw = true;\n              continue;\n            }\n\n            if (!ccw) {\n              let tmp = v1;\n              v1 = v2;\n              v2 = tmp;\n            }\n\n            ccw = !ccw;\n            let triangle = new Triangle(v0, v1, v2);\n            this.mesh.AddTriangle(triangle);\n          }\n        }\n      } else {\n        SkipFormat(reader, element.format, 0);\n      }\n    }\n  }\n\n}","map":{"version":3,"names":["Coord3D","Direction","BinaryReader","ArrayBufferToUtf8String","RGBColor","IntegerToHexString","PhongMaterial","Mesh","Triangle","ImporterBase","ParametersFromLine","ReadLines","UpdateMaterialTransparency","PlyHeaderCheckResult","Ok","NoVertices","NoFaces","UnknownError","PlyHeader","constructor","format","elements","SetFormat","AddElement","name","count","push","GetElements","AddSingleFormat","elemType","lastElement","length","isSingle","AddListFormat","countType","GetElement","i","element","Check","vertex","face","triStrips","hasFaces","hasTriStrips","PlyMaterialHandler","model","colorToMaterial","Map","GetMaterialIndexByColor","color","materialName","has","get","material","opacity","materialIndex","AddMaterial","set","ImporterPly","CanImportExtension","extension","GetUpDirection","Y","ClearContent","mesh","ResetContent","AddMeshToRootNode","ImportContent","fileContent","onFinish","headerString","GetHeaderContent","header","ReadHeader","checkResult","contentString","substring","ReadAsciiContent","ReadBinaryContent","SetError","headerContent","bufferView","Uint8Array","bufferIndex","byteLength","String","fromCharCode","endsWith","char","line","parameters","parseInt","foundVertex","foundFace","WasError","AddVertex","parseFloat","vertexCount","v0","v1","v2","triangle","AddTriangle","headerLength","ReadByFormat","reader","ReadType","type","ReadCharacter8","ReadUnsignedCharacter8","ReadInteger16","ReadUnsignedInteger16","ReadInteger32","ReadUnsignedInteger32","ReadFloat32","ReadDouble64","list","SkipFormat","startIndex","SkipAndGetColor","r","g","b","a","currFormat","val","Skip","materialHandler","elementIndex","vertexIndex","x","y","z","AddVertexColor","faceIndex","vertices","faceColor","mat","VertexColorCount","SetVertexColors","triStripIndex","ccw","tmp"],"sources":["/Users/rohansagar/Desktop/node+react/client/node-react-3d/node_modules/online-3d-viewer/source/engine/import/importerply.js"],"sourcesContent":["import { Coord3D } from '../geometry/coord3d.js';\r\nimport { Direction } from '../geometry/geometry.js';\r\nimport { BinaryReader } from '../io/binaryreader.js';\r\nimport { ArrayBufferToUtf8String } from '../io/bufferutils.js';\r\nimport { RGBColor, IntegerToHexString } from '../model/color.js';\r\nimport { PhongMaterial } from '../model/material.js';\r\nimport { Mesh } from '../model/mesh.js';\r\nimport { Triangle } from '../model/triangle.js';\r\nimport { ImporterBase } from './importerbase.js';\r\nimport { ParametersFromLine, ReadLines, UpdateMaterialTransparency } from './importerutils.js';\r\n\r\nconst PlyHeaderCheckResult =\r\n{\r\n    Ok : 1,\r\n    NoVertices : 2,\r\n    NoFaces : 3,\r\n    UnknownError : 4\r\n};\r\n\r\nclass PlyHeader\r\n{\r\n    constructor ()\r\n    {\r\n        this.format = null;\r\n        this.elements = [];\r\n    }\r\n\r\n    SetFormat (format)\r\n    {\r\n        this.format = format;\r\n    }\r\n\r\n    AddElement (name, count)\r\n    {\r\n        this.elements.push ({\r\n            name : name,\r\n            count : count,\r\n            format : []\r\n        });\r\n    }\r\n\r\n    GetElements ()\r\n    {\r\n        return this.elements;\r\n    }\r\n\r\n    AddSingleFormat (elemType, name)\r\n    {\r\n        let lastElement = this.elements[this.elements.length - 1];\r\n        lastElement.format.push ({\r\n            name : name,\r\n            isSingle : true,\r\n            elemType : elemType\r\n        });\r\n    }\r\n\r\n    AddListFormat (countType, elemType, name)\r\n    {\r\n        let lastElement = this.elements[this.elements.length - 1];\r\n        lastElement.format.push ({\r\n            name : name,\r\n            isSingle : false,\r\n            countType : countType,\r\n            elemType : elemType\r\n        });\r\n    }\r\n\r\n    GetElement (name)\r\n    {\r\n        for (let i = 0; i < this.elements.length; i++) {\r\n            let element = this.elements[i];\r\n            if (element.name === name) {\r\n                return element;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    Check ()\r\n    {\r\n        let vertex = this.GetElement ('vertex');\r\n        if (vertex === null || vertex.length === 0 || vertex.format.length < 3) {\r\n            return PlyHeaderCheckResult.NoVertices;\r\n        }\r\n\r\n        let face = this.GetElement ('face');\r\n        if (this.format === 'ascii') {\r\n            if (face === null || face.count === 0 || face.format.length < 0) {\r\n                return PlyHeaderCheckResult.NoFaces;\r\n            }\r\n        } else if (this.format === 'binary_little_endian' || this.format === 'binary_big_endian') {\r\n            let triStrips = this.GetElement ('tristrips');\r\n            let hasFaces = (face !== null && face.count > 0 && face.format.length > 0);\r\n            let hasTriStrips = (triStrips !== null && triStrips.count > 0 && triStrips.format.length > 0);\r\n            if (!hasFaces && !hasTriStrips) {\r\n                return PlyHeaderCheckResult.NoFaces;\r\n            }\r\n        } else {\r\n            return PlyHeaderCheckResult.UnknownError;\r\n        }\r\n\r\n        return PlyHeaderCheckResult.Ok;\r\n    }\r\n}\r\n\r\nclass PlyMaterialHandler\r\n{\r\n    constructor (model)\r\n    {\r\n        this.model = model;\r\n        this.colorToMaterial = new Map ();\r\n    }\r\n\r\n    GetMaterialIndexByColor (color)\r\n    {\r\n        let materialName = 'Color ' +\r\n            IntegerToHexString (color[0]) +\r\n            IntegerToHexString (color[1]) +\r\n            IntegerToHexString (color[2]) +\r\n            IntegerToHexString (color[3]);\r\n\r\n        if (this.colorToMaterial.has (materialName)) {\r\n            return this.colorToMaterial.get (materialName);\r\n        } else {\r\n            let material = new PhongMaterial ();\r\n            material.name = materialName;\r\n            material.color = new RGBColor (color[0], color[1], color[2]);\r\n            material.opacity = color[3] / 255.0;\r\n            UpdateMaterialTransparency (material);\r\n            let materialIndex = this.model.AddMaterial (material);\r\n            this.colorToMaterial.set (materialName, materialIndex);\r\n            return materialIndex;\r\n        }\r\n    }\r\n}\r\n\r\nexport class ImporterPly extends ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'ply';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Y;\r\n    }\r\n\r\n    ClearContent ()\r\n    {\r\n        this.mesh = null;\r\n    }\r\n\r\n    ResetContent ()\r\n    {\r\n        this.mesh = new Mesh ();\r\n        this.model.AddMeshToRootNode (this.mesh);\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n        let headerString = this.GetHeaderContent (fileContent);\r\n        let header = this.ReadHeader (headerString);\r\n        let checkResult = header.Check ();\r\n        if (checkResult === PlyHeaderCheckResult.Ok) {\r\n            if (header.format === 'ascii') {\r\n                let contentString = ArrayBufferToUtf8String (fileContent);\r\n                contentString = contentString.substring (headerString.length);\r\n                this.ReadAsciiContent (header, contentString);\r\n            } else if (header.format === 'binary_little_endian' || header.format === 'binary_big_endian') {\r\n                this.ReadBinaryContent (header, fileContent, headerString.length);\r\n            }\r\n        } else {\r\n            if (checkResult === PlyHeaderCheckResult.NoVertices) {\r\n                this.SetError ('The model contains no vertices.');\r\n            } else if (checkResult === PlyHeaderCheckResult.NoFaces) {\r\n                this.SetError ('The model contains no faces.');\r\n            } else {\r\n                this.SetError ('Invalid header information.');\r\n            }\r\n        }\r\n        onFinish ();\r\n    }\r\n\r\n    GetHeaderContent (fileContent)\r\n    {\r\n        let headerContent = '';\r\n        let bufferView = new Uint8Array (fileContent);\r\n        let bufferIndex = 0;\r\n        for (bufferIndex = 0; bufferIndex < fileContent.byteLength; bufferIndex++) {\r\n            headerContent += String.fromCharCode (bufferView[bufferIndex]);\r\n            if (headerContent.endsWith ('end_header')) {\r\n                break;\r\n            }\r\n        }\r\n        bufferIndex += 1;\r\n        while (bufferIndex < fileContent.byteLength) {\r\n            let char = String.fromCharCode (bufferView[bufferIndex]);\r\n            headerContent += char;\r\n            bufferIndex += 1;\r\n            if (char === '\\n') {\r\n                break;\r\n            }\r\n        }\r\n        return headerContent;\r\n    }\r\n\r\n    ReadHeader (headerContent)\r\n    {\r\n        let header = new PlyHeader ();\r\n        ReadLines (headerContent, (line) => {\r\n            let parameters = ParametersFromLine (line, null);\r\n            if (parameters.length === 0 || parameters[0] === 'comment') {\r\n                return;\r\n            }\r\n\r\n            if (parameters[0] === 'ply') {\r\n                return;\r\n            } else if (parameters[0] === 'format' && parameters.length >= 2) {\r\n                header.SetFormat (parameters[1]);\r\n            } else if (parameters[0] === 'element' && parameters.length >= 3) {\r\n                header.AddElement (parameters[1], parseInt (parameters[2], 10));\r\n            } else if (parameters[0] === 'property' && parameters.length >= 3) {\r\n                if (parameters[1] === 'list' && parameters.length >= 5) {\r\n                    header.AddListFormat (parameters[2], parameters[3], parameters[4]);\r\n                } else {\r\n                    header.AddSingleFormat (parameters[1], parameters[2]);\r\n                }\r\n            }\r\n        });\r\n\r\n        return header;\r\n    }\r\n\r\n    ReadAsciiContent (header, fileContent)\r\n    {\r\n        let vertex = header.GetElement ('vertex');\r\n        let face = header.GetElement ('face');\r\n        let foundVertex = 0;\r\n        let foundFace = 0;\r\n        ReadLines (fileContent, (line) => {\r\n            if (this.WasError ()) {\r\n                return;\r\n            }\r\n\r\n            let parameters = ParametersFromLine (line, null);\r\n            if (parameters.length === 0 || parameters[0] === 'comment') {\r\n                return;\r\n            }\r\n\r\n            if (foundVertex < vertex.count) {\r\n                if (parameters.length >= 3) {\r\n                    this.mesh.AddVertex (new Coord3D (\r\n                        parseFloat (parameters[0]),\r\n                        parseFloat (parameters[1]),\r\n                        parseFloat (parameters[2])\r\n                    ));\r\n                    foundVertex += 1;\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (face !== null && foundFace < face.count) {\r\n                if (parameters.length >= 4) {\r\n                    let vertexCount = parseInt (parameters[0], 10);\r\n                    if (parameters.length < vertexCount + 1) {\r\n                        return;\r\n                    }\r\n                    for (let i = 0; i < vertexCount - 2; i++) {\r\n                        let v0 = parseInt (parameters[1]);\r\n                        let v1 = parseInt (parameters[i + 2]);\r\n                        let v2 = parseInt (parameters[i + 3]);\r\n                        let triangle = new Triangle (v0, v1, v2);\r\n                        this.mesh.AddTriangle (triangle);\r\n                    }\r\n                    foundFace += 1;\r\n                }\r\n                return;\r\n            }\r\n        });\r\n    }\r\n\r\n    ReadBinaryContent (header, fileContent, headerLength)\r\n    {\r\n        function ReadByFormat (reader, format)\r\n        {\r\n            function ReadType (reader, type)\r\n            {\r\n                if (type === 'char' || type === 'int8') {\r\n                    return reader.ReadCharacter8 ();\r\n                } else if (type === 'uchar' || type === 'uint8') {\r\n                    return reader.ReadUnsignedCharacter8 ();\r\n                } else if (type === 'short' || type === 'int16') {\r\n                    return reader.ReadInteger16 ();\r\n                } else if (type === 'ushort' || type === 'uint16') {\r\n                    return reader.ReadUnsignedInteger16 ();\r\n                } else if (type === 'int' || type === 'int32') {\r\n                    return reader.ReadInteger32 ();\r\n                } else if (type === 'uint' || type === 'uint32') {\r\n                    return reader.ReadUnsignedInteger32 ();\r\n                } else if (type === 'float' || type === 'float32') {\r\n                    return reader.ReadFloat32 ();\r\n                } else if (type === 'double' || type === 'double64') {\r\n                    return reader.ReadDouble64 ();\r\n                }\r\n                return null;\r\n            }\r\n\r\n            if (format.isSingle) {\r\n                return ReadType (reader, format.elemType);\r\n            } else {\r\n                let list = [];\r\n                let count = ReadType (reader, format.countType);\r\n                for (let i = 0; i < count; i++) {\r\n                    list.push (ReadType (reader, format.elemType));\r\n                }\r\n                return list;\r\n            }\r\n        }\r\n\r\n        function SkipFormat (reader, format, startIndex)\r\n        {\r\n            for (let i = startIndex; i < format.length; i++) {\r\n                ReadByFormat (reader, format[i]);\r\n            }\r\n        }\r\n\r\n        function SkipAndGetColor (reader, format, startIndex)\r\n        {\r\n            let r = null;\r\n            let g = null;\r\n            let b = null;\r\n            let a = 255;\r\n\r\n            for (let i = startIndex; i < format.length; i++) {\r\n                let currFormat = format[i];\r\n                let val = ReadByFormat (reader, currFormat);\r\n                if (currFormat.name === 'red') {\r\n                    r = val;\r\n                } else if (currFormat.name === 'green') {\r\n                    g = val;\r\n                } else if (currFormat.name === 'blue') {\r\n                    b = val;\r\n                } else if (currFormat.name === 'alpha') {\r\n                    a = val;\r\n                }\r\n            }\r\n\r\n            if (r !== null && g !== null && b !== null) {\r\n                return [r, g, b, a];\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        let reader = null;\r\n        if (header.format === 'binary_little_endian') {\r\n            reader = new BinaryReader (fileContent, true);\r\n        } else if (header.format === 'binary_big_endian') {\r\n            reader = new BinaryReader (fileContent, false);\r\n        } else {\r\n            return;\r\n        }\r\n        reader.Skip (headerLength);\r\n\r\n        let materialHandler = new PlyMaterialHandler (this.model);\r\n        let elements = header.GetElements ();\r\n        for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {\r\n            let element = elements[elementIndex];\r\n            if (element.name === 'vertex') {\r\n                for (let vertexIndex = 0; vertexIndex < element.count; vertexIndex++) {\r\n                    let x = ReadByFormat (reader, element.format[0]);\r\n                    let y = ReadByFormat (reader, element.format[1]);\r\n                    let z = ReadByFormat (reader, element.format[2]);\r\n                    let color = SkipAndGetColor (reader, element.format, 3);\r\n                    if (color !== null) {\r\n                        this.mesh.AddVertexColor (new RGBColor (color[0], color[1], color[2]));\r\n                    }\r\n                    this.mesh.AddVertex (new Coord3D (x, y, z));\r\n                }\r\n            } else if (element.name === 'face') {\r\n                for (let faceIndex = 0; faceIndex < element.count; faceIndex++) {\r\n                    let vertices = ReadByFormat (reader, element.format[0]);\r\n                    let faceColor = SkipAndGetColor (reader, element.format, 1);\r\n                    for (let i = 0; i < vertices.length - 2; i++) {\r\n                        let v0 = vertices[0];\r\n                        let v1 = vertices[i + 1];\r\n                        let v2 = vertices[i + 2];\r\n                        let triangle = new Triangle (v0, v1, v2);\r\n                        if (faceColor !== null) {\r\n                            triangle.mat = materialHandler.GetMaterialIndexByColor (faceColor);\r\n                        } else if (this.mesh.VertexColorCount () > 0) {\r\n                            triangle.SetVertexColors (v0, v1, v2);\r\n                        }\r\n                        this.mesh.AddTriangle (triangle);\r\n                    }\r\n                }\r\n            } else if (element.name === 'tristrips') {\r\n                for (let triStripIndex = 0; triStripIndex < element.count; triStripIndex++) {\r\n                    let vertices = ReadByFormat (reader, element.format[0]);\r\n                    SkipFormat (reader, element.format, 1);\r\n                    let ccw = true;\r\n                    for (let i = 0; i < vertices.length - 2; i++) {\r\n                        let v0 = vertices[i];\r\n                        let v1 = vertices[i + 1];\r\n                        let v2 = vertices[i + 2];\r\n                        if (v2 === -1) {\r\n                            i += 2;\r\n                            ccw = true;\r\n                            continue;\r\n                        }\r\n                        if (!ccw) {\r\n                            let tmp = v1;\r\n                            v1 = v2;\r\n                            v2 = tmp;\r\n                        }\r\n                        ccw = !ccw;\r\n                        let triangle = new Triangle (v0, v1, v2);\r\n                        this.mesh.AddTriangle (triangle);\r\n                    }\r\n                }\r\n            } else {\r\n                SkipFormat (reader, element.format, 0);\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { Coord2D } from '../geometry/coord2d.js';\nimport { ArrayToCoord3D, Coord3D } from '../geometry/coord3d.js';\nimport { Coord4D } from '../geometry/coord4d.js';\nimport { Direction } from '../geometry/geometry.js';\nimport { Matrix } from '../geometry/matrix.js';\nimport { ArrayToQuaternion } from '../geometry/quaternion.js';\nimport { Transformation } from '../geometry/transformation.js';\nimport { BinaryReader } from '../io/binaryreader.js';\nimport { ArrayBufferToUtf8String, Base64DataURIToArrayBuffer, GetFileExtensionFromMimeType } from '../io/bufferutils.js';\nimport { LoadExternalLibrary } from '../io/externallibs.js';\nimport { RGBColor, ColorComponentFromFloat, RGBColorFromFloatComponents, LinearToSRGB } from '../model/color.js';\nimport { PhongMaterial, PhysicalMaterial, TextureMap } from '../model/material.js';\nimport { Mesh } from '../model/mesh.js';\nimport { Node, NodeType } from '../model/node.js';\nimport { Property, PropertyGroup, PropertyType } from '../model/property.js';\nimport { Triangle } from '../model/triangle.js';\nimport { ImporterBase } from './importerbase.js';\nconst GltfComponentType = {\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126\n};\nconst GltfDataType = {\n  SCALAR: 0,\n  VEC2: 1,\n  VEC3: 2,\n  VEC4: 3,\n  MAT2: 4,\n  MAT3: 5,\n  MAT4: 6\n};\nconst GltfRenderMode = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6\n};\nconst GltfConstants = {\n  GLTF_STRING: 0x46546C67,\n  JSON_CHUNK_TYPE: 0x4E4F534A,\n  BINARY_CHUNK_TYPE: 0x004E4942\n};\n\nfunction GetGltfColor(color) {\n  return RGBColorFromFloatComponents(LinearToSRGB(color[0]), LinearToSRGB(color[1]), LinearToSRGB(color[2]));\n}\n\nfunction GetGltfVertexColor(color, componentType) {\n  function GetColorComponent(component, componentType) {\n    let normalized = component;\n\n    if (componentType === GltfComponentType.UNSIGNED_BYTE) {\n      normalized /= 255.0;\n    } else if (componentType === GltfComponentType.UNSIGNED_SHORT) {\n      normalized /= 65535.0;\n    }\n\n    return ColorComponentFromFloat(LinearToSRGB(normalized));\n  }\n\n  return new RGBColor(GetColorComponent(color[0], componentType), GetColorComponent(color[1], componentType), GetColorComponent(color[2], componentType));\n}\n\nclass GltfBufferReader {\n  constructor(buffer) {\n    this.reader = new BinaryReader(buffer, true);\n    this.componentType = null;\n    this.dataType = null;\n    this.byteStride = null;\n    this.dataCount = null;\n    this.sparseReader = null;\n  }\n\n  SetComponentType(componentType) {\n    this.componentType = componentType;\n  }\n\n  SetDataType(dataType) {\n    if (dataType === 'SCALAR') {\n      this.dataType = GltfDataType.SCALAR;\n    } else if (dataType === 'VEC2') {\n      this.dataType = GltfDataType.VEC2;\n    } else if (dataType === 'VEC3') {\n      this.dataType = GltfDataType.VEC3;\n    } else if (dataType === 'VEC4') {\n      this.dataType = GltfDataType.VEC4;\n    } else if (dataType === 'MAT2') {\n      this.dataType = GltfDataType.MAT2;\n    } else if (dataType === 'MAT3') {\n      this.dataType = GltfDataType.MAT3;\n    } else if (dataType === 'MAT4') {\n      this.dataType = GltfDataType.MAT4;\n    }\n  }\n\n  SetByteStride(byteStride) {\n    this.byteStride = byteStride;\n  }\n\n  SetDataCount(dataCount) {\n    this.dataCount = dataCount;\n  }\n\n  SetSparseReader(indexReader, valueReader) {\n    this.sparseReader = {\n      indexReader: indexReader,\n      valueReader: valueReader\n    };\n  }\n\n  ReadArrayBuffer(byteLength) {\n    return this.reader.ReadArrayBuffer(byteLength);\n  }\n\n  GetDataCount() {\n    return this.dataCount;\n  }\n\n  ReadData() {\n    if (this.dataType === null) {\n      return null;\n    }\n\n    if (this.dataType === GltfDataType.SCALAR) {\n      let data = this.ReadComponent();\n      this.SkipBytesByStride(1);\n      return data;\n    } else if (this.dataType === GltfDataType.VEC2) {\n      let x = this.ReadComponent();\n      let y = this.ReadComponent();\n      this.SkipBytesByStride(2);\n      return new Coord2D(x, y);\n    } else if (this.dataType === GltfDataType.VEC3) {\n      let x = this.ReadComponent();\n      let y = this.ReadComponent();\n      let z = this.ReadComponent();\n      this.SkipBytesByStride(3);\n      return new Coord3D(x, y, z);\n    } else if (this.dataType === GltfDataType.VEC4) {\n      let x = this.ReadComponent();\n      let y = this.ReadComponent();\n      let z = this.ReadComponent();\n      let w = this.ReadComponent();\n      this.SkipBytesByStride(4);\n      return new Coord4D(x, y, z, w);\n    }\n\n    return null;\n  }\n\n  EnumerateData(onData) {\n    if (this.sparseReader === null) {\n      for (let i = 0; i < this.dataCount; i++) {\n        onData(this.ReadData());\n      }\n    } else {\n      let sparseData = [];\n\n      for (let i = 0; i < this.sparseReader.indexReader.GetDataCount(); i++) {\n        let index = this.sparseReader.indexReader.ReadData();\n        let value = this.sparseReader.valueReader.ReadData();\n        sparseData.push({\n          index: index,\n          value: value\n        });\n      }\n\n      let sparseIndex = 0;\n\n      for (let i = 0; i < this.dataCount; i++) {\n        let data = this.ReadData();\n\n        if (sparseIndex < sparseData.length && sparseData[sparseIndex].index === i) {\n          onData(sparseData[sparseIndex].value);\n          sparseIndex += 1;\n        } else {\n          onData(data);\n        }\n      }\n    }\n  }\n\n  SkipBytes(bytes) {\n    this.reader.Skip(bytes);\n  }\n\n  ReadComponent() {\n    if (this.componentType === null) {\n      return null;\n    }\n\n    if (this.componentType === GltfComponentType.BYTE) {\n      return this.reader.ReadCharacter8();\n    } else if (this.componentType === GltfComponentType.UNSIGNED_BYTE) {\n      return this.reader.ReadUnsignedCharacter8();\n    } else if (this.componentType === GltfComponentType.SHORT) {\n      return this.reader.ReadInteger16();\n    } else if (this.componentType === GltfComponentType.UNSIGNED_SHORT) {\n      return this.reader.ReadUnsignedInteger16();\n    } else if (this.componentType === GltfComponentType.UNSIGNED_INT) {\n      return this.reader.ReadInteger32();\n    } else if (this.componentType === GltfComponentType.FLOAT) {\n      return this.reader.ReadFloat32();\n    }\n\n    return null;\n  }\n\n  SkipBytesByStride(componentCount) {\n    if (this.byteStride === null) {\n      return;\n    }\n\n    let readBytes = componentCount * this.GetComponentSize();\n    this.reader.Skip(this.byteStride - readBytes);\n  }\n\n  GetComponentSize() {\n    if (this.componentType === GltfComponentType.BYTE) {\n      return 1;\n    } else if (this.componentType === GltfComponentType.UNSIGNED_BYTE) {\n      return 1;\n    } else if (this.componentType === GltfComponentType.SHORT) {\n      return 2;\n    } else if (this.componentType === GltfComponentType.UNSIGNED_SHORT) {\n      return 2;\n    } else if (this.componentType === GltfComponentType.UNSIGNED_INT) {\n      return 4;\n    } else if (this.componentType === GltfComponentType.FLOAT) {\n      return 4;\n    }\n\n    return 0;\n  }\n\n}\n\nclass GltfExtensions {\n  constructor() {\n    this.supportedExtensions = ['KHR_draco_mesh_compression', 'KHR_materials_pbrSpecularGlossiness', 'KHR_texture_transform'];\n    this.draco = null;\n  }\n\n  LoadLibraries(extensionsRequired, callbacks) {\n    if (extensionsRequired === undefined) {\n      callbacks.onSuccess();\n      return;\n    }\n\n    if (this.draco === null && extensionsRequired.indexOf('KHR_draco_mesh_compression') !== -1) {\n      LoadExternalLibrary('loaders/draco_decoder.js').then(() => {\n        DracoDecoderModule().then(draco => {\n          this.draco = draco;\n          callbacks.onSuccess();\n        });\n      }).catch(() => {\n        callbacks.onError('Failed to load draco decoder.');\n      });\n    } else {\n      callbacks.onSuccess();\n    }\n  }\n\n  GetUnsupportedExtensions(extensionsRequired) {\n    let unsupportedExtensions = [];\n\n    if (extensionsRequired === undefined) {\n      return unsupportedExtensions;\n    }\n\n    for (let i = 0; i < extensionsRequired.length; i++) {\n      let requiredExtension = extensionsRequired[i];\n\n      if (this.supportedExtensions.indexOf(requiredExtension) === -1) {\n        unsupportedExtensions.push(requiredExtension);\n      }\n    }\n\n    return unsupportedExtensions;\n  }\n\n  ProcessMaterial(gltfMaterial, material, imporTextureFn) {\n    if (gltfMaterial.extensions === undefined) {\n      return null;\n    }\n\n    let khrSpecularGlossiness = gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness;\n\n    if (khrSpecularGlossiness === undefined) {\n      return null;\n    }\n\n    let phongMaterial = new PhongMaterial();\n    let diffuseColor = khrSpecularGlossiness.diffuseFactor;\n\n    if (diffuseColor !== undefined) {\n      phongMaterial.color = GetGltfColor(diffuseColor);\n      phongMaterial.opacity = diffuseColor[3];\n    }\n\n    let diffuseTexture = khrSpecularGlossiness.diffuseTexture;\n\n    if (diffuseTexture !== undefined) {\n      phongMaterial.diffuseMap = imporTextureFn(diffuseTexture);\n    }\n\n    let specularColor = khrSpecularGlossiness.specularFactor;\n\n    if (specularColor !== undefined) {\n      phongMaterial.specular = GetGltfColor(specularColor);\n    }\n\n    let specularTexture = khrSpecularGlossiness.specularGlossinessTexture;\n\n    if (specularTexture !== undefined) {\n      phongMaterial.specularMap = imporTextureFn(specularTexture);\n    }\n\n    let glossiness = khrSpecularGlossiness.glossinessFactor;\n\n    if (glossiness !== undefined) {\n      phongMaterial.shininess = glossiness;\n    }\n\n    return phongMaterial;\n  }\n\n  ProcessTexture(gltfTexture, texture) {\n    if (gltfTexture.extensions === undefined) {\n      return;\n    }\n\n    let khrTextureTransform = gltfTexture.extensions.KHR_texture_transform;\n\n    if (khrTextureTransform !== undefined) {\n      if (khrTextureTransform.offset !== undefined) {\n        texture.offset.x = khrTextureTransform.offset[0];\n        texture.offset.y = -khrTextureTransform.offset[1];\n      }\n\n      if (khrTextureTransform.scale !== undefined) {\n        texture.scale.x = khrTextureTransform.scale[0];\n        texture.scale.y = khrTextureTransform.scale[1];\n      }\n\n      if (khrTextureTransform.rotation !== undefined) {\n        texture.rotation = -khrTextureTransform.rotation;\n      }\n    }\n  }\n\n  ProcessPrimitive(importer, gltf, primitive, mesh) {\n    function EnumerateComponents(draco, decoder, dracoMesh, attributeId, processor) {\n      let attribute = decoder.GetAttributeByUniqueId(dracoMesh, attributeId);\n      let numComponents = attribute.num_components();\n      let numPoints = dracoMesh.num_points();\n      let numValues = numPoints * numComponents;\n      let dataSize = numValues * 4;\n\n      let attributePtr = draco._malloc(dataSize);\n\n      decoder.GetAttributeDataArrayForAllPoints(dracoMesh, attribute, draco.DT_FLOAT32, dataSize, attributePtr);\n      let attributeArray = new Float32Array(draco.HEAPF32.buffer, attributePtr, numValues).slice();\n\n      if (numComponents === 2) {\n        for (let i = 0; i < attributeArray.length; i += 2) {\n          processor(new Coord2D(attributeArray[i + 0], attributeArray[i + 1]));\n        }\n      } else if (numComponents === 3) {\n        for (let i = 0; i < attributeArray.length; i += 3) {\n          processor(new Coord3D(attributeArray[i + 0], attributeArray[i + 1], attributeArray[i + 2]));\n        }\n      } else if (numComponents === 4) {\n        for (let i = 0; i < attributeArray.length; i += 4) {\n          processor(new Coord4D(attributeArray[i + 0], attributeArray[i + 1], attributeArray[i + 2], attributeArray[i + 3]));\n        }\n      }\n\n      draco._free(attributePtr);\n    }\n\n    if (this.draco === null) {\n      return false;\n    }\n\n    if (primitive.extensions === undefined || primitive.extensions.KHR_draco_mesh_compression === undefined) {\n      return false;\n    }\n\n    let decoder = new this.draco.Decoder();\n    let decoderBuffer = new this.draco.DecoderBuffer();\n    let extensionParams = primitive.extensions.KHR_draco_mesh_compression;\n    let compressedBufferView = gltf.bufferViews[extensionParams.bufferView];\n    let compressedReader = importer.GetReaderFromBufferView(compressedBufferView);\n    let compressedArrayBuffer = compressedReader.ReadArrayBuffer(compressedBufferView.byteLength);\n    decoderBuffer.Init(new Int8Array(compressedArrayBuffer), compressedArrayBuffer.byteLength);\n    let geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n\n    if (geometryType !== this.draco.TRIANGULAR_MESH) {\n      return true;\n    }\n\n    let dracoMesh = new this.draco.Mesh();\n    let decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoMesh);\n\n    if (!decodingStatus.ok()) {\n      return true;\n    }\n\n    let hasVertices = extensionParams.attributes.POSITION !== undefined;\n    let hasVertexColors = false;\n    let hasNormals = extensionParams.attributes.NORMAL !== undefined;\n    let hasUVs = extensionParams.attributes.TEXCOORD_0 !== undefined;\n\n    if (!hasVertices) {\n      return true;\n    }\n\n    let vertexOffset = mesh.VertexCount();\n    let vertexColorOffset = mesh.VertexColorCount();\n    let normalOffset = mesh.NormalCount();\n    let uvOffset = mesh.TextureUVCount();\n    EnumerateComponents(this.draco, decoder, dracoMesh, extensionParams.attributes.POSITION, vertex => {\n      mesh.AddVertex(vertex);\n    });\n\n    if (hasNormals) {\n      EnumerateComponents(this.draco, decoder, dracoMesh, extensionParams.attributes.NORMAL, normal => {\n        mesh.AddNormal(normal);\n      });\n    }\n\n    if (hasUVs) {\n      EnumerateComponents(this.draco, decoder, dracoMesh, extensionParams.attributes.TEXCOORD_0, uv => {\n        uv.y = -uv.y;\n        mesh.AddTextureUV(uv);\n      });\n    }\n\n    let faceCount = dracoMesh.num_faces();\n    let indexCount = faceCount * 3;\n    let indexDataSize = indexCount * 4;\n\n    let indexDataPtr = this.draco._malloc(indexDataSize);\n\n    decoder.GetTrianglesUInt32Array(dracoMesh, indexDataSize, indexDataPtr);\n    let indexArray = new Uint32Array(this.draco.HEAPU32.buffer, indexDataPtr, indexCount).slice();\n\n    for (let i = 0; i < indexArray.length; i += 3) {\n      let v0 = indexArray[i];\n      let v1 = indexArray[i + 1];\n      let v2 = indexArray[i + 2];\n      importer.AddTriangle(primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\n    }\n\n    this.draco._free(indexDataPtr);\n\n    return true;\n  }\n\n}\n\nexport class ImporterGltf extends ImporterBase {\n  constructor() {\n    super();\n    this.gltfExtensions = new GltfExtensions();\n  }\n\n  CanImportExtension(extension) {\n    return extension === 'gltf' || extension === 'glb';\n  }\n\n  GetUpDirection() {\n    return Direction.Y;\n  }\n\n  ClearContent() {\n    this.bufferContents = null;\n    this.imageIndexToTextureParams = null;\n  }\n\n  ResetContent() {\n    this.bufferContents = [];\n    this.imageIndexToTextureParams = new Map();\n  }\n\n  ImportContent(fileContent, onFinish) {\n    if (this.extension === 'gltf') {\n      this.ProcessGltf(fileContent, onFinish);\n    } else if (this.extension === 'glb') {\n      this.ProcessBinaryGltf(fileContent, onFinish);\n    }\n  }\n\n  ProcessGltf(fileContent, onFinish) {\n    let textContent = ArrayBufferToUtf8String(fileContent);\n    let gltf = JSON.parse(textContent);\n\n    if (gltf.asset.version !== '2.0') {\n      this.SetError('Invalid glTF version.');\n      onFinish();\n      return;\n    }\n\n    for (let i = 0; i < gltf.buffers.length; i++) {\n      let buffer = null;\n      let gltfBuffer = gltf.buffers[i];\n      let base64Buffer = Base64DataURIToArrayBuffer(gltfBuffer.uri);\n\n      if (base64Buffer !== null) {\n        buffer = base64Buffer.buffer;\n      } else {\n        let fileBuffer = this.callbacks.getFileBuffer(gltfBuffer.uri);\n\n        if (fileBuffer !== null) {\n          buffer = fileBuffer;\n        }\n      }\n\n      if (buffer === null) {\n        this.SetError('One of the requested buffers is missing.');\n        onFinish();\n        return;\n      }\n\n      this.bufferContents.push(buffer);\n    }\n\n    this.ProcessMainFile(gltf, onFinish);\n  }\n\n  ProcessBinaryGltf(fileContent, onFinish) {\n    function ReadChunk(reader) {\n      let length = reader.ReadUnsignedInteger32();\n      let type = reader.ReadUnsignedInteger32();\n      let buffer = reader.ReadArrayBuffer(length);\n      return {\n        type: type,\n        buffer: buffer\n      };\n    }\n\n    let reader = new BinaryReader(fileContent, true);\n    let magic = reader.ReadUnsignedInteger32();\n\n    if (magic !== GltfConstants.GLTF_STRING) {\n      this.SetError('Invalid glTF file.');\n      onFinish();\n      return;\n    }\n\n    let version = reader.ReadUnsignedInteger32();\n\n    if (version !== 2) {\n      this.SetError('Invalid glTF version.');\n      onFinish();\n      return;\n    }\n\n    let length = reader.ReadUnsignedInteger32();\n\n    if (length !== reader.GetByteLength()) {\n      this.SetError('Invalid glTF file.');\n      onFinish();\n      return;\n    }\n\n    let gltfTextContent = null;\n\n    while (!reader.End()) {\n      let chunk = ReadChunk(reader);\n\n      if (chunk.type === GltfConstants.JSON_CHUNK_TYPE) {\n        gltfTextContent = ArrayBufferToUtf8String(chunk.buffer);\n      } else if (chunk.type === GltfConstants.BINARY_CHUNK_TYPE) {\n        this.bufferContents.push(chunk.buffer);\n      }\n    }\n\n    if (gltfTextContent !== null) {\n      let gltf = JSON.parse(gltfTextContent);\n      this.ProcessMainFile(gltf, onFinish);\n    }\n  }\n\n  ProcessMainFile(gltf, onFinish) {\n    let unsupportedExtensions = this.gltfExtensions.GetUnsupportedExtensions(gltf.extensionsRequired);\n\n    if (unsupportedExtensions.length > 0) {\n      this.SetError('Unsupported extension: ' + unsupportedExtensions.join(', ') + '.');\n      onFinish();\n      return;\n    }\n\n    this.gltfExtensions.LoadLibraries(gltf.extensionsRequired, {\n      onSuccess: () => {\n        this.ImportModel(gltf);\n        onFinish();\n      },\n      onError: message => {\n        this.SetError(message);\n        onFinish();\n      }\n    });\n  }\n\n  ImportModel(gltf) {\n    let materials = gltf.materials;\n\n    if (materials !== undefined) {\n      for (let material of materials) {\n        this.ImportMaterial(gltf, material);\n      }\n    }\n\n    let meshes = gltf.meshes;\n\n    if (meshes !== undefined) {\n      for (let mesh of meshes) {\n        this.ImportMesh(gltf, mesh);\n      }\n    }\n\n    this.ImportNodes(gltf);\n    this.ImportModelProperties(gltf);\n  }\n\n  ImportModelProperties(gltf) {\n    function ImportProperties(model, propertyGroupName, propertyObject) {\n      let propertyGroup = new PropertyGroup(propertyGroupName);\n\n      for (let propertyName in propertyObject) {\n        if (Object.prototype.hasOwnProperty.call(propertyObject, propertyName)) {\n          if (typeof propertyObject[propertyName] === 'string') {\n            const property = new Property(PropertyType.Text, propertyName, propertyObject[propertyName]);\n            propertyGroup.AddProperty(property);\n          }\n        }\n      }\n\n      if (propertyGroup.PropertyCount() > 0) {\n        model.AddPropertyGroup(propertyGroup);\n      }\n\n      return propertyGroup;\n    }\n\n    ImportProperties(this.model, 'Asset properties', gltf.asset);\n\n    if (gltf.asset['extras']) {\n      ImportProperties(this.model, 'Extras', gltf.asset['extras']);\n    }\n  }\n\n  GetDefaultScene(gltf) {\n    let defaultSceneIndex = gltf.scene || 0;\n\n    if (defaultSceneIndex >= gltf.scenes.length) {\n      return null;\n    }\n\n    return gltf.scenes[defaultSceneIndex];\n  }\n\n  ImportMaterial(gltf, gltfMaterial) {\n    let material = new PhysicalMaterial();\n\n    if (gltfMaterial.name !== undefined) {\n      material.name = gltfMaterial.name;\n    }\n\n    material.color = GetGltfColor([1.0, 1.0, 1.0]);\n\n    if (gltfMaterial.pbrMetallicRoughness !== undefined) {\n      let baseColor = gltfMaterial.pbrMetallicRoughness.baseColorFactor;\n\n      if (baseColor !== undefined) {\n        material.color = GetGltfColor(baseColor);\n        material.opacity = baseColor[3];\n      }\n\n      let metallicFactor = gltfMaterial.pbrMetallicRoughness.metallicFactor;\n\n      if (metallicFactor !== undefined) {\n        material.metalness = metallicFactor;\n      }\n\n      let roughnessFactor = gltfMaterial.pbrMetallicRoughness.roughnessFactor;\n\n      if (roughnessFactor !== undefined) {\n        material.roughness = roughnessFactor;\n      }\n\n      let emissiveColor = gltfMaterial.emissiveFactor;\n\n      if (emissiveColor !== undefined) {\n        material.emissive = GetGltfColor(emissiveColor);\n      }\n\n      material.diffuseMap = this.ImportTexture(gltf, gltfMaterial.pbrMetallicRoughness.baseColorTexture);\n      material.metalnessMap = this.ImportTexture(gltf, gltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture);\n      material.normalMap = this.ImportTexture(gltf, gltfMaterial.normalTexture);\n      material.emissiveMap = this.ImportTexture(gltf, gltfMaterial.emissiveTexture);\n\n      if (material.diffuseMap !== null) {\n        material.multiplyDiffuseMap = true;\n      }\n\n      let alphaMode = gltfMaterial.alphaMode;\n\n      if (alphaMode !== undefined) {\n        if (alphaMode === 'BLEND') {\n          material.transparent = true;\n        } else if (alphaMode === 'MASK') {\n          material.transparent = true;\n          material.alphaTest = gltfMaterial.alphaCutoff || 0.5;\n        }\n      }\n    }\n\n    let newMaterial = this.gltfExtensions.ProcessMaterial(gltfMaterial, material, textureRef => {\n      return this.ImportTexture(gltf, textureRef);\n    });\n\n    if (newMaterial !== null) {\n      material = newMaterial;\n    }\n\n    this.model.AddMaterial(material);\n  }\n\n  ImportTexture(gltf, gltfTextureRef) {\n    if (gltfTextureRef === undefined || gltfTextureRef === null) {\n      return null;\n    }\n\n    let texture = new TextureMap();\n    let gltfTexture = gltf.textures[gltfTextureRef.index];\n    let gltfImageIndex = gltfTexture.source;\n    let gltfImage = gltf.images[gltfImageIndex];\n    let textureParams = null;\n\n    if (this.imageIndexToTextureParams.has(gltfImageIndex)) {\n      textureParams = this.imageIndexToTextureParams.get(gltfImageIndex);\n    } else {\n      textureParams = {\n        name: null,\n        mimeType: null,\n        buffer: null\n      };\n      let textureIndexString = gltfImageIndex.toString();\n\n      if (gltfImage.uri !== undefined) {\n        let base64Buffer = Base64DataURIToArrayBuffer(gltfImage.uri);\n\n        if (base64Buffer !== null) {\n          textureParams.name = 'Embedded_' + textureIndexString + '.' + GetFileExtensionFromMimeType(base64Buffer.mimeType);\n          textureParams.mimeType = base64Buffer.mimeType;\n          textureParams.buffer = base64Buffer.buffer;\n        } else {\n          let textureBuffer = this.callbacks.getFileBuffer(gltfImage.uri);\n          textureParams.name = gltfImage.uri;\n          textureParams.buffer = textureBuffer;\n        }\n      } else if (gltfImage.bufferView !== undefined) {\n        let bufferView = gltf.bufferViews[gltfImage.bufferView];\n        let reader = this.GetReaderFromBufferView(bufferView);\n\n        if (reader !== null) {\n          let buffer = reader.ReadArrayBuffer(bufferView.byteLength);\n          textureParams.name = 'Binary_' + textureIndexString + '.' + GetFileExtensionFromMimeType(gltfImage.mimeType);\n          textureParams.mimeType = gltfImage.mimeType;\n          textureParams.buffer = buffer;\n        }\n      }\n\n      this.imageIndexToTextureParams.set(gltfImageIndex, textureParams);\n    }\n\n    texture.name = textureParams.name;\n    texture.mimeType = textureParams.mimeType;\n    texture.buffer = textureParams.buffer;\n    this.gltfExtensions.ProcessTexture(gltfTextureRef, texture);\n    return texture;\n  }\n\n  ImportMesh(gltf, gltfMesh) {\n    let mesh = new Mesh();\n    this.model.AddMesh(mesh);\n\n    if (gltfMesh.name !== undefined) {\n      mesh.SetName(gltfMesh.name);\n    }\n\n    for (let i = 0; i < gltfMesh.primitives.length; i++) {\n      let primitive = gltfMesh.primitives[i];\n      this.ImportPrimitive(gltf, primitive, mesh);\n    }\n  }\n\n  ImportPrimitive(gltf, primitive, mesh) {\n    if (this.gltfExtensions.ProcessPrimitive(this, gltf, primitive, mesh)) {\n      return;\n    }\n\n    if (primitive.attributes === undefined) {\n      return;\n    }\n\n    let hasVertices = primitive.attributes.POSITION !== undefined;\n    let hasVertexColors = primitive.attributes.COLOR_0 !== undefined;\n    let hasNormals = primitive.attributes.NORMAL !== undefined;\n    let hasUVs = primitive.attributes.TEXCOORD_0 !== undefined;\n    let hasIndices = primitive.indices !== undefined;\n    let mode = GltfRenderMode.TRIANGLES;\n\n    if (primitive.mode !== undefined) {\n      mode = primitive.mode;\n    }\n\n    if (mode !== GltfRenderMode.TRIANGLES && mode !== GltfRenderMode.TRIANGLE_STRIP && mode !== GltfRenderMode.TRIANGLE_FAN) {\n      return;\n    }\n\n    let vertexOffset = mesh.VertexCount();\n    let vertexColorOffset = mesh.VertexColorCount();\n    let normalOffset = mesh.NormalCount();\n    let uvOffset = mesh.TextureUVCount();\n\n    if (hasVertices) {\n      let accessor = gltf.accessors[primitive.attributes.POSITION];\n      let reader = this.GetReaderFromAccessor(gltf, accessor);\n\n      if (reader === null) {\n        return;\n      }\n\n      reader.EnumerateData(data => {\n        mesh.AddVertex(data);\n      });\n    } else {\n      return;\n    }\n\n    if (hasVertexColors) {\n      let accessor = gltf.accessors[primitive.attributes.COLOR_0];\n      let reader = this.GetReaderFromAccessor(gltf, accessor);\n\n      if (reader === null) {\n        return;\n      }\n\n      reader.EnumerateData(data => {\n        let color = GetGltfVertexColor([data.x, data.y, data.z], reader.componentType);\n        mesh.AddVertexColor(color);\n      });\n    }\n\n    if (hasNormals) {\n      let accessor = gltf.accessors[primitive.attributes.NORMAL];\n      let reader = this.GetReaderFromAccessor(gltf, accessor);\n\n      if (reader === null) {\n        return;\n      }\n\n      reader.EnumerateData(data => {\n        mesh.AddNormal(data);\n      });\n    }\n\n    if (hasUVs) {\n      let accessor = gltf.accessors[primitive.attributes.TEXCOORD_0];\n      let reader = this.GetReaderFromAccessor(gltf, accessor);\n\n      if (reader === null) {\n        return;\n      }\n\n      reader.EnumerateData(data => {\n        data.y = -data.y;\n        mesh.AddTextureUV(data);\n      });\n    }\n\n    let vertexIndices = [];\n\n    if (hasIndices) {\n      let accessor = gltf.accessors[primitive.indices];\n      let reader = this.GetReaderFromAccessor(gltf, accessor);\n\n      if (reader === null) {\n        return;\n      }\n\n      reader.EnumerateData(data => {\n        vertexIndices.push(data);\n      });\n    } else {\n      let primitiveVertexCount = mesh.VertexCount() - vertexOffset;\n\n      for (let i = 0; i < primitiveVertexCount; i++) {\n        vertexIndices.push(i);\n      }\n    }\n\n    if (mode === GltfRenderMode.TRIANGLES) {\n      for (let i = 0; i < vertexIndices.length; i += 3) {\n        let v0 = vertexIndices[i];\n        let v1 = vertexIndices[i + 1];\n        let v2 = vertexIndices[i + 2];\n        this.AddTriangle(primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\n      }\n    } else if (mode === GltfRenderMode.TRIANGLE_STRIP) {\n      for (let i = 0; i < vertexIndices.length - 2; i++) {\n        let v0 = vertexIndices[i];\n        let v1 = vertexIndices[i + 1];\n        let v2 = vertexIndices[i + 2];\n\n        if (i % 2 === 1) {\n          let tmp = v1;\n          v1 = v2;\n          v2 = tmp;\n        }\n\n        this.AddTriangle(primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\n      }\n    } else if (mode === GltfRenderMode.TRIANGLE_FAN) {\n      for (let i = 1; i < vertexIndices.length - 1; i++) {\n        let v0 = vertexIndices[0];\n        let v1 = vertexIndices[i];\n        let v2 = vertexIndices[i + 1];\n        this.AddTriangle(primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\n      }\n    }\n  }\n\n  AddTriangle(primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset) {\n    let triangle = new Triangle(vertexOffset + v0, vertexOffset + v1, vertexOffset + v2);\n\n    if (hasVertexColors) {\n      triangle.SetVertexColors(vertexColorOffset + v0, vertexColorOffset + v1, vertexColorOffset + v2);\n    }\n\n    if (hasNormals) {\n      triangle.SetNormals(normalOffset + v0, normalOffset + v1, normalOffset + v2);\n    }\n\n    if (hasUVs) {\n      triangle.SetTextureUVs(uvOffset + v0, uvOffset + v1, uvOffset + v2);\n    }\n\n    if (primitive.material !== undefined) {\n      triangle.mat = primitive.material;\n    }\n\n    mesh.AddTriangle(triangle);\n  }\n\n  ImportNodes(gltf) {\n    let scene = this.GetDefaultScene(gltf);\n\n    if (scene === null) {\n      return;\n    }\n\n    let rootNode = this.model.GetRootNode();\n\n    for (let nodeIndex of scene.nodes) {\n      let gltfNode = gltf.nodes[nodeIndex];\n      this.ImportNode(gltf, gltfNode, rootNode);\n    }\n  }\n\n  ImportNode(gltf, gltfNode, parentNode) {\n    function GetNodeTransformation(gltfNode) {\n      let matrix = new Matrix().CreateIdentity();\n\n      if (gltfNode.matrix !== undefined) {\n        matrix.Set(gltfNode.matrix);\n      } else {\n        let translation = [0.0, 0.0, 0.0];\n        let rotation = [0.0, 0.0, 0.0, 1.0];\n        let scale = [1.0, 1.0, 1.0];\n\n        if (gltfNode.translation !== undefined) {\n          translation = gltfNode.translation;\n        }\n\n        if (gltfNode.rotation !== undefined) {\n          rotation = gltfNode.rotation;\n        }\n\n        if (gltfNode.scale !== undefined) {\n          scale = gltfNode.scale;\n        }\n\n        matrix.ComposeTRS(ArrayToCoord3D(translation), ArrayToQuaternion(rotation), ArrayToCoord3D(scale));\n      }\n\n      return new Transformation(matrix);\n    }\n\n    if (gltfNode.children === undefined && gltfNode.mesh === undefined) {\n      return;\n    }\n\n    let node = new Node();\n\n    if (gltfNode.name !== undefined) {\n      node.SetName(gltfNode.name);\n    }\n\n    node.SetTransformation(GetNodeTransformation(gltfNode));\n    parentNode.AddChildNode(node);\n\n    if (gltfNode.children !== undefined) {\n      for (let childIndex of gltfNode.children) {\n        let childGltfNode = gltf.nodes[childIndex];\n        this.ImportNode(gltf, childGltfNode, node);\n      }\n    }\n\n    if (gltfNode.mesh !== undefined) {\n      if (gltfNode.children === undefined || gltfNode.children.length === 0) {\n        node.SetType(NodeType.MeshNode);\n      }\n\n      node.AddMeshIndex(gltfNode.mesh);\n    }\n  }\n\n  GetReaderFromBufferView(bufferView) {\n    let bufferIndex = bufferView.buffer || 0;\n    let buffer = this.bufferContents[bufferIndex];\n\n    if (buffer === undefined || buffer === null) {\n      return null;\n    }\n\n    let reader = new GltfBufferReader(buffer);\n    reader.SkipBytes(bufferView.byteOffset || 0);\n    let byteStride = bufferView.byteStride;\n\n    if (byteStride !== undefined && byteStride !== 0) {\n      reader.SetByteStride(byteStride);\n    }\n\n    return reader;\n  }\n\n  GetReaderFromAccessor(gltf, accessor) {\n    let bufferViewIndex = accessor.bufferView || 0;\n    let bufferView = gltf.bufferViews[bufferViewIndex];\n    let reader = this.GetReaderFromBufferView(bufferView);\n\n    if (reader === null) {\n      return null;\n    }\n\n    reader.SetComponentType(accessor.componentType);\n    reader.SetDataType(accessor.type);\n    reader.SetDataCount(accessor.count);\n    reader.SkipBytes(accessor.byteOffset || 0);\n\n    if (accessor.sparse !== undefined) {\n      let indexReader = this.GetReaderFromSparseAccessor(gltf, accessor.sparse.indices, accessor.sparse.indices.componentType, 'SCALAR', accessor.sparse.count);\n      let valueReader = this.GetReaderFromSparseAccessor(gltf, accessor.sparse.values, accessor.componentType, accessor.type, accessor.sparse.count);\n\n      if (indexReader !== null && valueReader !== null) {\n        reader.SetSparseReader(indexReader, valueReader);\n      }\n    }\n\n    return reader;\n  }\n\n  GetReaderFromSparseAccessor(gltf, sparseAccessor, componentType, type, count) {\n    if (sparseAccessor.bufferView === undefined) {\n      return null;\n    }\n\n    let bufferView = gltf.bufferViews[sparseAccessor.bufferView];\n    let reader = this.GetReaderFromBufferView(bufferView);\n\n    if (reader === null) {\n      return null;\n    }\n\n    reader.SetComponentType(componentType);\n    reader.SetDataType(type);\n    reader.SetDataCount(count);\n    reader.SkipBytes(sparseAccessor.byteOffset || 0);\n    return reader;\n  }\n\n}","map":{"version":3,"names":["Coord2D","ArrayToCoord3D","Coord3D","Coord4D","Direction","Matrix","ArrayToQuaternion","Transformation","BinaryReader","ArrayBufferToUtf8String","Base64DataURIToArrayBuffer","GetFileExtensionFromMimeType","LoadExternalLibrary","RGBColor","ColorComponentFromFloat","RGBColorFromFloatComponents","LinearToSRGB","PhongMaterial","PhysicalMaterial","TextureMap","Mesh","Node","NodeType","Property","PropertyGroup","PropertyType","Triangle","ImporterBase","GltfComponentType","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","UNSIGNED_INT","FLOAT","GltfDataType","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","GltfRenderMode","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","GltfConstants","GLTF_STRING","JSON_CHUNK_TYPE","BINARY_CHUNK_TYPE","GetGltfColor","color","GetGltfVertexColor","componentType","GetColorComponent","component","normalized","GltfBufferReader","constructor","buffer","reader","dataType","byteStride","dataCount","sparseReader","SetComponentType","SetDataType","SetByteStride","SetDataCount","SetSparseReader","indexReader","valueReader","ReadArrayBuffer","byteLength","GetDataCount","ReadData","data","ReadComponent","SkipBytesByStride","x","y","z","w","EnumerateData","onData","i","sparseData","index","value","push","sparseIndex","length","SkipBytes","bytes","Skip","ReadCharacter8","ReadUnsignedCharacter8","ReadInteger16","ReadUnsignedInteger16","ReadInteger32","ReadFloat32","componentCount","readBytes","GetComponentSize","GltfExtensions","supportedExtensions","draco","LoadLibraries","extensionsRequired","callbacks","undefined","onSuccess","indexOf","then","DracoDecoderModule","catch","onError","GetUnsupportedExtensions","unsupportedExtensions","requiredExtension","ProcessMaterial","gltfMaterial","material","imporTextureFn","extensions","khrSpecularGlossiness","KHR_materials_pbrSpecularGlossiness","phongMaterial","diffuseColor","diffuseFactor","opacity","diffuseTexture","diffuseMap","specularColor","specularFactor","specular","specularTexture","specularGlossinessTexture","specularMap","glossiness","glossinessFactor","shininess","ProcessTexture","gltfTexture","texture","khrTextureTransform","KHR_texture_transform","offset","scale","rotation","ProcessPrimitive","importer","gltf","primitive","mesh","EnumerateComponents","decoder","dracoMesh","attributeId","processor","attribute","GetAttributeByUniqueId","numComponents","num_components","numPoints","num_points","numValues","dataSize","attributePtr","_malloc","GetAttributeDataArrayForAllPoints","DT_FLOAT32","attributeArray","Float32Array","HEAPF32","slice","_free","KHR_draco_mesh_compression","Decoder","decoderBuffer","DecoderBuffer","extensionParams","compressedBufferView","bufferViews","bufferView","compressedReader","GetReaderFromBufferView","compressedArrayBuffer","Init","Int8Array","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","decodingStatus","DecodeBufferToMesh","ok","hasVertices","attributes","POSITION","hasVertexColors","hasNormals","NORMAL","hasUVs","TEXCOORD_0","vertexOffset","VertexCount","vertexColorOffset","VertexColorCount","normalOffset","NormalCount","uvOffset","TextureUVCount","vertex","AddVertex","normal","AddNormal","uv","AddTextureUV","faceCount","num_faces","indexCount","indexDataSize","indexDataPtr","GetTrianglesUInt32Array","indexArray","Uint32Array","HEAPU32","v0","v1","v2","AddTriangle","ImporterGltf","gltfExtensions","CanImportExtension","extension","GetUpDirection","Y","ClearContent","bufferContents","imageIndexToTextureParams","ResetContent","Map","ImportContent","fileContent","onFinish","ProcessGltf","ProcessBinaryGltf","textContent","JSON","parse","asset","version","SetError","buffers","gltfBuffer","base64Buffer","uri","fileBuffer","getFileBuffer","ProcessMainFile","ReadChunk","ReadUnsignedInteger32","type","magic","GetByteLength","gltfTextContent","End","chunk","join","ImportModel","message","materials","ImportMaterial","meshes","ImportMesh","ImportNodes","ImportModelProperties","ImportProperties","model","propertyGroupName","propertyObject","propertyGroup","propertyName","Object","prototype","hasOwnProperty","call","property","Text","AddProperty","PropertyCount","AddPropertyGroup","GetDefaultScene","defaultSceneIndex","scene","scenes","name","pbrMetallicRoughness","baseColor","baseColorFactor","metallicFactor","metalness","roughnessFactor","roughness","emissiveColor","emissiveFactor","emissive","ImportTexture","baseColorTexture","metalnessMap","metallicRoughnessTexture","normalMap","normalTexture","emissiveMap","emissiveTexture","multiplyDiffuseMap","alphaMode","transparent","alphaTest","alphaCutoff","newMaterial","textureRef","AddMaterial","gltfTextureRef","textures","gltfImageIndex","source","gltfImage","images","textureParams","has","get","mimeType","textureIndexString","toString","textureBuffer","set","gltfMesh","AddMesh","SetName","primitives","ImportPrimitive","COLOR_0","hasIndices","indices","mode","accessor","accessors","GetReaderFromAccessor","AddVertexColor","vertexIndices","primitiveVertexCount","tmp","triangle","SetVertexColors","SetNormals","SetTextureUVs","mat","rootNode","GetRootNode","nodeIndex","nodes","gltfNode","ImportNode","parentNode","GetNodeTransformation","matrix","CreateIdentity","Set","translation","ComposeTRS","children","node","SetTransformation","AddChildNode","childIndex","childGltfNode","SetType","MeshNode","AddMeshIndex","bufferIndex","byteOffset","bufferViewIndex","count","sparse","GetReaderFromSparseAccessor","values","sparseAccessor"],"sources":["/Users/rohansagar/Desktop/node+react/client/node-react-3d/node_modules/online-3d-viewer/source/engine/import/importergltf.js"],"sourcesContent":["import { Coord2D } from '../geometry/coord2d.js';\r\nimport { ArrayToCoord3D, Coord3D } from '../geometry/coord3d.js';\r\nimport { Coord4D } from '../geometry/coord4d.js';\r\nimport { Direction } from '../geometry/geometry.js';\r\nimport { Matrix } from '../geometry/matrix.js';\r\nimport { ArrayToQuaternion } from '../geometry/quaternion.js';\r\nimport { Transformation } from '../geometry/transformation.js';\r\nimport { BinaryReader } from '../io/binaryreader.js';\r\nimport { ArrayBufferToUtf8String, Base64DataURIToArrayBuffer, GetFileExtensionFromMimeType } from '../io/bufferutils.js';\r\nimport { LoadExternalLibrary } from '../io/externallibs.js';\r\nimport { RGBColor, ColorComponentFromFloat, RGBColorFromFloatComponents, LinearToSRGB } from '../model/color.js';\r\nimport { PhongMaterial, PhysicalMaterial, TextureMap } from '../model/material.js';\r\nimport { Mesh } from '../model/mesh.js';\r\nimport { Node, NodeType } from '../model/node.js';\r\nimport { Property, PropertyGroup, PropertyType } from '../model/property.js';\r\nimport { Triangle } from '../model/triangle.js';\r\nimport { ImporterBase } from './importerbase.js';\r\n\r\nconst GltfComponentType =\r\n{\r\n    BYTE : 5120,\r\n    UNSIGNED_BYTE : 5121,\r\n    SHORT : 5122,\r\n    UNSIGNED_SHORT : 5123,\r\n    UNSIGNED_INT : 5125,\r\n    FLOAT : 5126\r\n};\r\n\r\nconst GltfDataType =\r\n{\r\n    SCALAR : 0,\r\n    VEC2 : 1,\r\n    VEC3 : 2,\r\n    VEC4 : 3,\r\n    MAT2 : 4,\r\n    MAT3  : 5,\r\n    MAT4  : 6\r\n};\r\n\r\nconst GltfRenderMode =\r\n{\r\n    POINTS : 0,\r\n    LINES : 1,\r\n    LINE_LOOP : 2,\r\n    LINE_STRIP : 3,\r\n    TRIANGLES : 4,\r\n    TRIANGLE_STRIP  : 5,\r\n    TRIANGLE_FAN : 6\r\n};\r\n\r\nconst GltfConstants =\r\n{\r\n    GLTF_STRING : 0x46546C67,\r\n    JSON_CHUNK_TYPE : 0x4E4F534A,\r\n    BINARY_CHUNK_TYPE : 0x004E4942\r\n};\r\n\r\nfunction GetGltfColor (color)\r\n{\r\n    return RGBColorFromFloatComponents (\r\n        LinearToSRGB (color[0]),\r\n        LinearToSRGB (color[1]),\r\n        LinearToSRGB (color[2])\r\n    );\r\n}\r\n\r\nfunction GetGltfVertexColor (color, componentType)\r\n{\r\n    function GetColorComponent (component, componentType)\r\n    {\r\n        let normalized = component;\r\n        if (componentType === GltfComponentType.UNSIGNED_BYTE) {\r\n            normalized /= 255.0;\r\n        } else if (componentType === GltfComponentType.UNSIGNED_SHORT) {\r\n            normalized /= 65535.0;\r\n        }\r\n        return ColorComponentFromFloat (LinearToSRGB (normalized));\r\n    }\r\n\r\n    return new RGBColor (\r\n        GetColorComponent (color[0], componentType),\r\n        GetColorComponent (color[1], componentType),\r\n        GetColorComponent (color[2], componentType)\r\n    );\r\n}\r\n\r\nclass GltfBufferReader\r\n{\r\n    constructor (buffer)\r\n    {\r\n        this.reader = new BinaryReader (buffer, true);\r\n        this.componentType = null;\r\n        this.dataType = null;\r\n        this.byteStride = null;\r\n        this.dataCount = null;\r\n        this.sparseReader = null;\r\n    }\r\n\r\n    SetComponentType (componentType)\r\n    {\r\n        this.componentType = componentType;\r\n    }\r\n\r\n    SetDataType (dataType)\r\n    {\r\n        if (dataType === 'SCALAR') {\r\n            this.dataType = GltfDataType.SCALAR;\r\n        } else if (dataType === 'VEC2') {\r\n            this.dataType = GltfDataType.VEC2;\r\n        } else if (dataType === 'VEC3') {\r\n            this.dataType = GltfDataType.VEC3;\r\n        } else if (dataType === 'VEC4') {\r\n            this.dataType = GltfDataType.VEC4;\r\n        } else if (dataType === 'MAT2') {\r\n            this.dataType = GltfDataType.MAT2;\r\n        } else if (dataType === 'MAT3') {\r\n            this.dataType = GltfDataType.MAT3;\r\n        } else if (dataType === 'MAT4') {\r\n            this.dataType = GltfDataType.MAT4;\r\n        }\r\n    }\r\n\r\n    SetByteStride (byteStride)\r\n    {\r\n        this.byteStride = byteStride;\r\n    }\r\n\r\n    SetDataCount (dataCount)\r\n    {\r\n        this.dataCount = dataCount;\r\n    }\r\n\r\n    SetSparseReader (indexReader, valueReader)\r\n    {\r\n        this.sparseReader = {\r\n            indexReader : indexReader,\r\n            valueReader : valueReader\r\n        };\r\n    }\r\n\r\n    ReadArrayBuffer (byteLength)\r\n    {\r\n        return this.reader.ReadArrayBuffer (byteLength);\r\n    }\r\n\r\n    GetDataCount ()\r\n    {\r\n        return this.dataCount;\r\n    }\r\n\r\n    ReadData ()\r\n    {\r\n        if (this.dataType === null) {\r\n            return null;\r\n        }\r\n        if (this.dataType === GltfDataType.SCALAR) {\r\n            let data = this.ReadComponent ();\r\n            this.SkipBytesByStride (1);\r\n            return data;\r\n        } else if (this.dataType === GltfDataType.VEC2) {\r\n            let x = this.ReadComponent ();\r\n            let y = this.ReadComponent ();\r\n            this.SkipBytesByStride (2);\r\n            return new Coord2D (x, y);\r\n        } else if (this.dataType === GltfDataType.VEC3) {\r\n            let x = this.ReadComponent ();\r\n            let y = this.ReadComponent ();\r\n            let z = this.ReadComponent ();\r\n            this.SkipBytesByStride (3);\r\n            return new Coord3D (x, y, z);\r\n        } else if (this.dataType === GltfDataType.VEC4) {\r\n            let x = this.ReadComponent ();\r\n            let y = this.ReadComponent ();\r\n            let z = this.ReadComponent ();\r\n            let w = this.ReadComponent ();\r\n            this.SkipBytesByStride (4);\r\n            return new Coord4D (x, y, z, w);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    EnumerateData (onData)\r\n    {\r\n        if (this.sparseReader === null) {\r\n            for (let i = 0; i < this.dataCount; i++) {\r\n                onData (this.ReadData ());\r\n            }\r\n        } else {\r\n            let sparseData = [];\r\n            for (let i = 0; i < this.sparseReader.indexReader.GetDataCount (); i++) {\r\n                let index = this.sparseReader.indexReader.ReadData ();\r\n                let value = this.sparseReader.valueReader.ReadData ();\r\n                sparseData.push ({\r\n                    index : index,\r\n                    value : value\r\n                });\r\n            }\r\n            let sparseIndex = 0;\r\n            for (let i = 0; i < this.dataCount; i++) {\r\n                let data = this.ReadData ();\r\n                if (sparseIndex < sparseData.length && sparseData[sparseIndex].index === i) {\r\n                    onData (sparseData[sparseIndex].value);\r\n                    sparseIndex += 1;\r\n                } else {\r\n                    onData (data);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    SkipBytes (bytes)\r\n    {\r\n        this.reader.Skip (bytes);\r\n    }\r\n\r\n    ReadComponent ()\r\n    {\r\n        if (this.componentType === null) {\r\n            return null;\r\n        }\r\n        if (this.componentType === GltfComponentType.BYTE) {\r\n            return this.reader.ReadCharacter8 ();\r\n        } else if (this.componentType === GltfComponentType.UNSIGNED_BYTE) {\r\n            return this.reader.ReadUnsignedCharacter8 ();\r\n        } else if (this.componentType === GltfComponentType.SHORT) {\r\n            return this.reader.ReadInteger16 ();\r\n        } else if (this.componentType === GltfComponentType.UNSIGNED_SHORT) {\r\n            return this.reader.ReadUnsignedInteger16 ();\r\n        } else if (this.componentType === GltfComponentType.UNSIGNED_INT) {\r\n            return this.reader.ReadInteger32 ();\r\n        } else if (this.componentType === GltfComponentType.FLOAT) {\r\n            return this.reader.ReadFloat32 ();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    SkipBytesByStride (componentCount)\r\n    {\r\n        if (this.byteStride === null) {\r\n            return;\r\n        }\r\n        let readBytes = componentCount * this.GetComponentSize ();\r\n        this.reader.Skip (this.byteStride - readBytes);\r\n    }\r\n\r\n    GetComponentSize ()\r\n    {\r\n        if (this.componentType === GltfComponentType.BYTE) {\r\n            return 1;\r\n        } else if (this.componentType === GltfComponentType.UNSIGNED_BYTE) {\r\n            return 1;\r\n        } else if (this.componentType === GltfComponentType.SHORT) {\r\n            return 2;\r\n        } else if (this.componentType === GltfComponentType.UNSIGNED_SHORT) {\r\n            return 2;\r\n        } else if (this.componentType === GltfComponentType.UNSIGNED_INT) {\r\n            return 4;\r\n        } else if (this.componentType === GltfComponentType.FLOAT) {\r\n            return 4;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n\r\nclass GltfExtensions\r\n{\r\n    constructor ()\r\n    {\r\n        this.supportedExtensions = [\r\n            'KHR_draco_mesh_compression',\r\n            'KHR_materials_pbrSpecularGlossiness',\r\n            'KHR_texture_transform',\r\n        ];\r\n        this.draco = null;\r\n    }\r\n\r\n    LoadLibraries (extensionsRequired, callbacks)\r\n    {\r\n        if (extensionsRequired === undefined) {\r\n            callbacks.onSuccess ();\r\n            return;\r\n        }\r\n        if (this.draco === null && extensionsRequired.indexOf ('KHR_draco_mesh_compression') !== -1) {\r\n\t\t\tLoadExternalLibrary ('loaders/draco_decoder.js').then (() => {\r\n                DracoDecoderModule ().then ((draco) => {\r\n                    this.draco = draco;\r\n                    callbacks.onSuccess ();\r\n                });\r\n            }).catch (() => {\r\n                callbacks.onError ('Failed to load draco decoder.');\r\n            });\r\n        } else {\r\n            callbacks.onSuccess ();\r\n        }\r\n    }\r\n\r\n    GetUnsupportedExtensions (extensionsRequired)\r\n    {\r\n        let unsupportedExtensions = [];\r\n        if (extensionsRequired === undefined) {\r\n            return unsupportedExtensions;\r\n        }\r\n        for (let i = 0; i < extensionsRequired.length; i++) {\r\n            let requiredExtension = extensionsRequired[i];\r\n            if (this.supportedExtensions.indexOf (requiredExtension) === -1) {\r\n                unsupportedExtensions.push (requiredExtension);\r\n            }\r\n        }\r\n        return unsupportedExtensions;\r\n    }\r\n\r\n    ProcessMaterial (gltfMaterial, material, imporTextureFn)\r\n    {\r\n        if (gltfMaterial.extensions === undefined) {\r\n            return null;\r\n        }\r\n\r\n        let khrSpecularGlossiness = gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness;\r\n        if (khrSpecularGlossiness === undefined) {\r\n            return null;\r\n        }\r\n\r\n        let phongMaterial = new PhongMaterial ();\r\n        let diffuseColor = khrSpecularGlossiness.diffuseFactor;\r\n        if (diffuseColor !== undefined) {\r\n            phongMaterial.color = GetGltfColor (diffuseColor);\r\n            phongMaterial.opacity = diffuseColor[3];\r\n        }\r\n        let diffuseTexture = khrSpecularGlossiness.diffuseTexture;\r\n        if (diffuseTexture !== undefined) {\r\n            phongMaterial.diffuseMap = imporTextureFn (diffuseTexture);\r\n        }\r\n        let specularColor = khrSpecularGlossiness.specularFactor;\r\n        if (specularColor !== undefined) {\r\n            phongMaterial.specular = GetGltfColor (specularColor);\r\n        }\r\n        let specularTexture = khrSpecularGlossiness.specularGlossinessTexture;\r\n        if (specularTexture !== undefined) {\r\n            phongMaterial.specularMap = imporTextureFn (specularTexture);\r\n        }\r\n        let glossiness = khrSpecularGlossiness.glossinessFactor;\r\n        if (glossiness !== undefined) {\r\n            phongMaterial.shininess = glossiness;\r\n        }\r\n\r\n        return phongMaterial;\r\n    }\r\n\r\n    ProcessTexture (gltfTexture, texture)\r\n    {\r\n        if (gltfTexture.extensions === undefined) {\r\n            return;\r\n        }\r\n        let khrTextureTransform = gltfTexture.extensions.KHR_texture_transform;\r\n        if (khrTextureTransform !== undefined) {\r\n            if (khrTextureTransform.offset !== undefined) {\r\n                texture.offset.x = khrTextureTransform.offset[0];\r\n                texture.offset.y = -khrTextureTransform.offset[1];\r\n            }\r\n            if (khrTextureTransform.scale !== undefined) {\r\n                texture.scale.x = khrTextureTransform.scale[0];\r\n                texture.scale.y = khrTextureTransform.scale[1];\r\n            }\r\n            if (khrTextureTransform.rotation !== undefined) {\r\n                texture.rotation = -khrTextureTransform.rotation;\r\n            }\r\n        }\r\n    }\r\n\r\n    ProcessPrimitive (importer, gltf, primitive, mesh)\r\n    {\r\n        function EnumerateComponents (draco, decoder, dracoMesh, attributeId, processor)\r\n        {\r\n            let attribute = decoder.GetAttributeByUniqueId (dracoMesh, attributeId);\r\n            let numComponents = attribute.num_components ();\r\n            let numPoints = dracoMesh.num_points ();\r\n            let numValues = numPoints * numComponents;\r\n            let dataSize = numValues * 4;\r\n            let attributePtr = draco._malloc (dataSize);\r\n            decoder.GetAttributeDataArrayForAllPoints (dracoMesh, attribute, draco.DT_FLOAT32, dataSize, attributePtr);\r\n            let attributeArray = new Float32Array (draco.HEAPF32.buffer, attributePtr, numValues).slice ();\r\n            if (numComponents === 2) {\r\n                for (let i = 0; i < attributeArray.length; i += 2) {\r\n                    processor (new Coord2D (\r\n                        attributeArray[i + 0],\r\n                        attributeArray[i + 1]\r\n                    ));\r\n                }\r\n            } else if (numComponents === 3) {\r\n                for (let i = 0; i < attributeArray.length; i += 3) {\r\n                    processor (new Coord3D (\r\n                        attributeArray[i + 0],\r\n                        attributeArray[i + 1],\r\n                        attributeArray[i + 2]\r\n                    ));\r\n                }\r\n            } else if (numComponents === 4) {\r\n                for (let i = 0; i < attributeArray.length; i += 4) {\r\n                    processor (new Coord4D (\r\n                        attributeArray[i + 0],\r\n                        attributeArray[i + 1],\r\n                        attributeArray[i + 2],\r\n                        attributeArray[i + 3]\r\n                    ));\r\n                }\r\n            }\r\n            draco._free (attributePtr);\r\n        }\r\n\r\n        if (this.draco === null) {\r\n            return false;\r\n        }\r\n\r\n        if (primitive.extensions === undefined || primitive.extensions.KHR_draco_mesh_compression === undefined) {\r\n            return false;\r\n        }\r\n\r\n        let decoder = new this.draco.Decoder ();\r\n        let decoderBuffer = new this.draco.DecoderBuffer ();\r\n\r\n        let extensionParams = primitive.extensions.KHR_draco_mesh_compression;\r\n        let compressedBufferView = gltf.bufferViews[extensionParams.bufferView];\r\n        let compressedReader = importer.GetReaderFromBufferView (compressedBufferView);\r\n        let compressedArrayBuffer = compressedReader.ReadArrayBuffer (compressedBufferView.byteLength);\r\n        decoderBuffer.Init (new Int8Array (compressedArrayBuffer), compressedArrayBuffer.byteLength);\r\n        let geometryType = decoder.GetEncodedGeometryType (decoderBuffer);\r\n        if (geometryType !== this.draco.TRIANGULAR_MESH) {\r\n            return true;\r\n        }\r\n\r\n        let dracoMesh = new this.draco.Mesh ();\r\n        let decodingStatus = decoder.DecodeBufferToMesh (decoderBuffer, dracoMesh);\r\n        if (!decodingStatus.ok ()) {\r\n            return true;\r\n        }\r\n\r\n        let hasVertices = (extensionParams.attributes.POSITION !== undefined);\r\n        let hasVertexColors = false;\r\n        let hasNormals = (extensionParams.attributes.NORMAL !== undefined);\r\n        let hasUVs = (extensionParams.attributes.TEXCOORD_0 !== undefined);\r\n\r\n        if (!hasVertices) {\r\n            return true;\r\n        }\r\n\r\n        let vertexOffset = mesh.VertexCount ();\r\n        let vertexColorOffset = mesh.VertexColorCount ();\r\n        let normalOffset = mesh.NormalCount ();\r\n        let uvOffset = mesh.TextureUVCount ();\r\n\r\n        EnumerateComponents (this.draco, decoder, dracoMesh, extensionParams.attributes.POSITION, (vertex) => {\r\n            mesh.AddVertex (vertex);\r\n        });\r\n\r\n        if (hasNormals) {\r\n            EnumerateComponents (this.draco, decoder, dracoMesh, extensionParams.attributes.NORMAL, (normal) => {\r\n                mesh.AddNormal (normal);\r\n            });\r\n        }\r\n\r\n        if (hasUVs) {\r\n            EnumerateComponents (this.draco, decoder, dracoMesh, extensionParams.attributes.TEXCOORD_0, (uv) => {\r\n                uv.y = -uv.y;\r\n                mesh.AddTextureUV (uv);\r\n            });\r\n        }\r\n\r\n        let faceCount = dracoMesh.num_faces ();\r\n        let indexCount = faceCount * 3;\r\n        let indexDataSize = indexCount * 4;\r\n        let indexDataPtr = this.draco._malloc (indexDataSize);\r\n        decoder.GetTrianglesUInt32Array (dracoMesh, indexDataSize, indexDataPtr);\r\n        let indexArray = new Uint32Array (this.draco.HEAPU32.buffer, indexDataPtr, indexCount).slice ();\r\n        for (let i = 0; i < indexArray.length; i += 3) {\r\n            let v0 = indexArray[i];\r\n            let v1 = indexArray[i + 1];\r\n            let v2 = indexArray[i + 2];\r\n            importer.AddTriangle (primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\r\n        }\r\n        this.draco._free (indexDataPtr);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nexport class ImporterGltf extends ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n        this.gltfExtensions = new GltfExtensions ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === 'gltf' || extension === 'glb';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Y;\r\n    }\r\n\r\n    ClearContent ()\r\n    {\r\n        this.bufferContents = null;\r\n        this.imageIndexToTextureParams = null;\r\n    }\r\n\r\n    ResetContent ()\r\n    {\r\n        this.bufferContents = [];\r\n        this.imageIndexToTextureParams = new Map ();\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n        if (this.extension === 'gltf') {\r\n            this.ProcessGltf (fileContent, onFinish);\r\n        } else if (this.extension === 'glb') {\r\n            this.ProcessBinaryGltf (fileContent, onFinish);\r\n        }\r\n    }\r\n\r\n    ProcessGltf (fileContent, onFinish)\r\n    {\r\n        let textContent = ArrayBufferToUtf8String (fileContent);\r\n        let gltf = JSON.parse (textContent);\r\n        if (gltf.asset.version !== '2.0') {\r\n            this.SetError ('Invalid glTF version.');\r\n            onFinish ();\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < gltf.buffers.length; i++) {\r\n            let buffer = null;\r\n            let gltfBuffer = gltf.buffers[i];\r\n            let base64Buffer = Base64DataURIToArrayBuffer (gltfBuffer.uri);\r\n            if (base64Buffer !== null) {\r\n                buffer = base64Buffer.buffer;\r\n            } else {\r\n                let fileBuffer = this.callbacks.getFileBuffer (gltfBuffer.uri);\r\n                if (fileBuffer !== null) {\r\n                    buffer = fileBuffer;\r\n                }\r\n            }\r\n            if (buffer === null) {\r\n                this.SetError ('One of the requested buffers is missing.');\r\n                onFinish ();\r\n                return;\r\n            }\r\n            this.bufferContents.push (buffer);\r\n        }\r\n\r\n        this.ProcessMainFile (gltf, onFinish);\r\n    }\r\n\r\n    ProcessBinaryGltf (fileContent, onFinish)\r\n    {\r\n        function ReadChunk (reader)\r\n        {\r\n            let length = reader.ReadUnsignedInteger32 ();\r\n            let type = reader.ReadUnsignedInteger32 ();\r\n            let buffer = reader.ReadArrayBuffer (length);\r\n            return {\r\n                type : type,\r\n                buffer : buffer\r\n            };\r\n        }\r\n\r\n        let reader = new BinaryReader (fileContent, true);\r\n        let magic = reader.ReadUnsignedInteger32 ();\r\n        if (magic !== GltfConstants.GLTF_STRING) {\r\n            this.SetError ('Invalid glTF file.');\r\n            onFinish ();\r\n            return;\r\n        }\r\n        let version = reader.ReadUnsignedInteger32 ();\r\n        if (version !== 2) {\r\n            this.SetError ('Invalid glTF version.');\r\n            onFinish ();\r\n            return;\r\n        }\r\n        let length = reader.ReadUnsignedInteger32 ();\r\n        if (length !== reader.GetByteLength ()) {\r\n            this.SetError ('Invalid glTF file.');\r\n            onFinish ();\r\n            return;\r\n        }\r\n\r\n        let gltfTextContent = null;\r\n        while (!reader.End ()) {\r\n            let chunk = ReadChunk (reader);\r\n            if (chunk.type === GltfConstants.JSON_CHUNK_TYPE) {\r\n                gltfTextContent = ArrayBufferToUtf8String (chunk.buffer);\r\n            } else if (chunk.type === GltfConstants.BINARY_CHUNK_TYPE) {\r\n                this.bufferContents.push (chunk.buffer);\r\n            }\r\n        }\r\n\r\n        if (gltfTextContent !== null) {\r\n            let gltf = JSON.parse (gltfTextContent);\r\n            this.ProcessMainFile (gltf, onFinish);\r\n        }\r\n    }\r\n\r\n    ProcessMainFile (gltf, onFinish)\r\n    {\r\n        let unsupportedExtensions = this.gltfExtensions.GetUnsupportedExtensions (gltf.extensionsRequired);\r\n        if (unsupportedExtensions.length > 0) {\r\n            this.SetError ('Unsupported extension: ' + unsupportedExtensions.join (', ') + '.');\r\n            onFinish ();\r\n            return;\r\n        }\r\n\r\n        this.gltfExtensions.LoadLibraries (gltf.extensionsRequired, {\r\n            onSuccess : () => {\r\n                this.ImportModel (gltf);\r\n                onFinish ();\r\n            },\r\n            onError : (message) => {\r\n                this.SetError (message);\r\n                onFinish ();\r\n            }\r\n        });\r\n    }\r\n\r\n    ImportModel (gltf)\r\n    {\r\n        let materials = gltf.materials;\r\n        if (materials !== undefined) {\r\n            for (let material of materials) {\r\n                this.ImportMaterial (gltf, material);\r\n            }\r\n        }\r\n\r\n        let meshes = gltf.meshes;\r\n        if (meshes !== undefined) {\r\n            for (let mesh of meshes) {\r\n                this.ImportMesh (gltf, mesh);\r\n            }\r\n        }\r\n\r\n        this.ImportNodes (gltf);\r\n        this.ImportModelProperties (gltf);\r\n    }\r\n\r\n    ImportModelProperties (gltf)\r\n    {\r\n        function ImportProperties (model, propertyGroupName, propertyObject)\r\n        {\r\n            let propertyGroup = new PropertyGroup (propertyGroupName);\r\n            for (let propertyName in propertyObject) {\r\n                if (Object.prototype.hasOwnProperty.call (propertyObject, propertyName)) {\r\n                    if (typeof propertyObject[propertyName] === 'string') {\r\n                        const property = new Property (PropertyType.Text, propertyName, propertyObject[propertyName]);\r\n                        propertyGroup.AddProperty (property);\r\n                    }\r\n                }\r\n            }\r\n            if (propertyGroup.PropertyCount () > 0) {\r\n                model.AddPropertyGroup (propertyGroup);\r\n            }\r\n            return propertyGroup;\r\n        }\r\n\r\n        ImportProperties (this.model, 'Asset properties', gltf.asset);\r\n        if (gltf.asset['extras']) {\r\n            ImportProperties (this.model, 'Extras', gltf.asset['extras']);\r\n        }\r\n    }\r\n\r\n    GetDefaultScene (gltf)\r\n    {\r\n        let defaultSceneIndex = gltf.scene || 0;\r\n        if (defaultSceneIndex >= gltf.scenes.length) {\r\n            return null;\r\n        }\r\n        return gltf.scenes[defaultSceneIndex];\r\n    }\r\n\r\n    ImportMaterial (gltf, gltfMaterial)\r\n    {\r\n        let material = new PhysicalMaterial ();\r\n        if (gltfMaterial.name !== undefined) {\r\n            material.name = gltfMaterial.name;\r\n        }\r\n\r\n        material.color = GetGltfColor ([1.0, 1.0, 1.0]);\r\n        if (gltfMaterial.pbrMetallicRoughness !== undefined) {\r\n            let baseColor = gltfMaterial.pbrMetallicRoughness.baseColorFactor;\r\n            if (baseColor !== undefined) {\r\n                material.color = GetGltfColor (baseColor);\r\n                material.opacity = baseColor[3];\r\n            }\r\n            let metallicFactor = gltfMaterial.pbrMetallicRoughness.metallicFactor;\r\n            if (metallicFactor !== undefined) {\r\n                material.metalness = metallicFactor;\r\n            }\r\n            let roughnessFactor = gltfMaterial.pbrMetallicRoughness.roughnessFactor;\r\n            if (roughnessFactor !== undefined) {\r\n                material.roughness = roughnessFactor;\r\n            }\r\n            let emissiveColor = gltfMaterial.emissiveFactor;\r\n            if (emissiveColor !== undefined) {\r\n                material.emissive = GetGltfColor (emissiveColor);\r\n            }\r\n\r\n            material.diffuseMap = this.ImportTexture (gltf, gltfMaterial.pbrMetallicRoughness.baseColorTexture);\r\n            material.metalnessMap = this.ImportTexture (gltf, gltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture);\r\n            material.normalMap = this.ImportTexture (gltf, gltfMaterial.normalTexture);\r\n            material.emissiveMap = this.ImportTexture (gltf, gltfMaterial.emissiveTexture);\r\n            if (material.diffuseMap !== null) {\r\n                material.multiplyDiffuseMap = true;\r\n            }\r\n\r\n            let alphaMode = gltfMaterial.alphaMode;\r\n            if (alphaMode !== undefined) {\r\n                if (alphaMode === 'BLEND') {\r\n                    material.transparent = true;\r\n                } else if (alphaMode === 'MASK') {\r\n                    material.transparent = true;\r\n                    material.alphaTest = gltfMaterial.alphaCutoff || 0.5;\r\n                }\r\n            }\r\n        }\r\n\r\n        let newMaterial = this.gltfExtensions.ProcessMaterial (gltfMaterial, material, (textureRef) => {\r\n            return this.ImportTexture (gltf, textureRef);\r\n        });\r\n        if (newMaterial !== null) {\r\n            material = newMaterial;\r\n        }\r\n        this.model.AddMaterial (material);\r\n    }\r\n\r\n    ImportTexture (gltf, gltfTextureRef)\r\n    {\r\n        if (gltfTextureRef === undefined || gltfTextureRef === null) {\r\n            return null;\r\n        }\r\n\r\n        let texture = new TextureMap ();\r\n        let gltfTexture = gltf.textures[gltfTextureRef.index];\r\n        let gltfImageIndex = gltfTexture.source;\r\n        let gltfImage = gltf.images[gltfImageIndex];\r\n\r\n        let textureParams = null;\r\n        if (this.imageIndexToTextureParams.has (gltfImageIndex)) {\r\n            textureParams = this.imageIndexToTextureParams.get (gltfImageIndex);\r\n        } else {\r\n            textureParams = {\r\n                name : null,\r\n                mimeType : null,\r\n                buffer : null\r\n            };\r\n            let textureIndexString = gltfImageIndex.toString ();\r\n            if (gltfImage.uri !== undefined) {\r\n                let base64Buffer = Base64DataURIToArrayBuffer (gltfImage.uri);\r\n                if (base64Buffer !== null) {\r\n                    textureParams.name = 'Embedded_' + textureIndexString + '.' + GetFileExtensionFromMimeType (base64Buffer.mimeType);\r\n                    textureParams.mimeType = base64Buffer.mimeType;\r\n                    textureParams.buffer = base64Buffer.buffer;\r\n                } else {\r\n                    let textureBuffer = this.callbacks.getFileBuffer (gltfImage.uri);\r\n                    textureParams.name = gltfImage.uri;\r\n                    textureParams.buffer = textureBuffer;\r\n                }\r\n            } else if (gltfImage.bufferView !== undefined) {\r\n                let bufferView = gltf.bufferViews[gltfImage.bufferView];\r\n                let reader = this.GetReaderFromBufferView (bufferView);\r\n                if (reader !== null) {\r\n                    let buffer = reader.ReadArrayBuffer (bufferView.byteLength);\r\n                    textureParams.name = 'Binary_' + textureIndexString + '.' + GetFileExtensionFromMimeType (gltfImage.mimeType);\r\n                    textureParams.mimeType = gltfImage.mimeType;\r\n                    textureParams.buffer = buffer;\r\n                }\r\n            }\r\n            this.imageIndexToTextureParams.set (gltfImageIndex, textureParams);\r\n        }\r\n\r\n        texture.name = textureParams.name;\r\n        texture.mimeType = textureParams.mimeType;\r\n        texture.buffer = textureParams.buffer;\r\n\r\n        this.gltfExtensions.ProcessTexture (gltfTextureRef, texture);\r\n        return texture;\r\n    }\r\n\r\n    ImportMesh (gltf, gltfMesh)\r\n    {\r\n        let mesh = new Mesh ();\r\n        this.model.AddMesh (mesh);\r\n        if (gltfMesh.name !== undefined) {\r\n            mesh.SetName (gltfMesh.name);\r\n        }\r\n\r\n        for (let i = 0; i < gltfMesh.primitives.length; i++) {\r\n            let primitive = gltfMesh.primitives[i];\r\n            this.ImportPrimitive (gltf, primitive, mesh);\r\n        }\r\n    }\r\n\r\n    ImportPrimitive (gltf, primitive, mesh)\r\n    {\r\n        if (this.gltfExtensions.ProcessPrimitive (this, gltf, primitive, mesh)) {\r\n            return;\r\n        }\r\n\r\n        if (primitive.attributes === undefined) {\r\n            return;\r\n        }\r\n\r\n        let hasVertices = (primitive.attributes.POSITION !== undefined);\r\n        let hasVertexColors = (primitive.attributes.COLOR_0 !== undefined);\r\n        let hasNormals = (primitive.attributes.NORMAL !== undefined);\r\n        let hasUVs = (primitive.attributes.TEXCOORD_0 !== undefined);\r\n        let hasIndices = (primitive.indices !== undefined);\r\n\r\n        let mode = GltfRenderMode.TRIANGLES;\r\n        if (primitive.mode !== undefined) {\r\n            mode = primitive.mode;\r\n        }\r\n        if (mode !== GltfRenderMode.TRIANGLES && mode !== GltfRenderMode.TRIANGLE_STRIP && mode !== GltfRenderMode.TRIANGLE_FAN) {\r\n            return;\r\n        }\r\n\r\n        let vertexOffset = mesh.VertexCount ();\r\n        let vertexColorOffset = mesh.VertexColorCount ();\r\n        let normalOffset = mesh.NormalCount ();\r\n        let uvOffset = mesh.TextureUVCount ();\r\n\r\n        if (hasVertices) {\r\n            let accessor = gltf.accessors[primitive.attributes.POSITION];\r\n            let reader = this.GetReaderFromAccessor (gltf, accessor);\r\n            if (reader === null) {\r\n                return;\r\n            }\r\n            reader.EnumerateData ((data) => {\r\n                mesh.AddVertex (data);\r\n            });\r\n        } else {\r\n            return;\r\n        }\r\n\r\n        if (hasVertexColors) {\r\n            let accessor = gltf.accessors[primitive.attributes.COLOR_0];\r\n            let reader = this.GetReaderFromAccessor (gltf, accessor);\r\n            if (reader === null) {\r\n                return;\r\n            }\r\n            reader.EnumerateData ((data) => {\r\n                let color = GetGltfVertexColor ([data.x, data.y, data.z], reader.componentType);\r\n                mesh.AddVertexColor (color);\r\n            });\r\n        }\r\n\r\n        if (hasNormals) {\r\n            let accessor = gltf.accessors[primitive.attributes.NORMAL];\r\n            let reader = this.GetReaderFromAccessor (gltf, accessor);\r\n            if (reader === null) {\r\n                return;\r\n            }\r\n            reader.EnumerateData ((data) => {\r\n                mesh.AddNormal (data);\r\n            });\r\n        }\r\n\r\n        if (hasUVs) {\r\n            let accessor = gltf.accessors[primitive.attributes.TEXCOORD_0];\r\n            let reader = this.GetReaderFromAccessor (gltf, accessor);\r\n            if (reader === null) {\r\n                return;\r\n            }\r\n            reader.EnumerateData ((data) => {\r\n                data.y = -data.y;\r\n                mesh.AddTextureUV (data);\r\n            });\r\n        }\r\n\r\n        let vertexIndices = [];\r\n        if (hasIndices) {\r\n            let accessor = gltf.accessors[primitive.indices];\r\n            let reader = this.GetReaderFromAccessor (gltf, accessor);\r\n            if (reader === null) {\r\n                return;\r\n            }\r\n            reader.EnumerateData ((data) => {\r\n                vertexIndices.push (data);\r\n            });\r\n        } else {\r\n            let primitiveVertexCount = mesh.VertexCount () - vertexOffset;\r\n            for (let i = 0; i < primitiveVertexCount; i++) {\r\n                vertexIndices.push (i);\r\n            }\r\n        }\r\n\r\n        if (mode === GltfRenderMode.TRIANGLES) {\r\n            for (let i = 0; i < vertexIndices.length; i += 3) {\r\n                let v0 = vertexIndices[i];\r\n                let v1 = vertexIndices[i + 1];\r\n                let v2 = vertexIndices[i + 2];\r\n                this.AddTriangle (primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\r\n            }\r\n        } else if (mode === GltfRenderMode.TRIANGLE_STRIP) {\r\n            for (let i = 0; i < vertexIndices.length - 2; i++) {\r\n                let v0 = vertexIndices[i];\r\n                let v1 = vertexIndices[i + 1];\r\n                let v2 = vertexIndices[i + 2];\r\n                if (i % 2 === 1) {\r\n                    let tmp = v1;\r\n                    v1 = v2;\r\n                    v2 = tmp;\r\n                }\r\n                this.AddTriangle (primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\r\n            }\r\n        } else if (mode === GltfRenderMode.TRIANGLE_FAN) {\r\n            for (let i = 1; i < vertexIndices.length - 1; i++) {\r\n                let v0 = vertexIndices[0];\r\n                let v1 = vertexIndices[i];\r\n                let v2 = vertexIndices[i + 1];\r\n                this.AddTriangle (primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset);\r\n            }\r\n        }\r\n    }\r\n\r\n    AddTriangle (primitive, mesh, v0, v1, v2, hasVertexColors, hasNormals, hasUVs, vertexOffset, vertexColorOffset, normalOffset, uvOffset)\r\n    {\r\n        let triangle = new Triangle (\r\n            vertexOffset + v0,\r\n            vertexOffset + v1,\r\n            vertexOffset + v2\r\n        );\r\n        if (hasVertexColors) {\r\n            triangle.SetVertexColors (\r\n                vertexColorOffset + v0,\r\n                vertexColorOffset + v1,\r\n                vertexColorOffset + v2\r\n            );\r\n        }\r\n        if (hasNormals) {\r\n            triangle.SetNormals (\r\n                normalOffset + v0,\r\n                normalOffset + v1,\r\n                normalOffset + v2\r\n            );\r\n        }\r\n        if (hasUVs) {\r\n            triangle.SetTextureUVs (\r\n                uvOffset + v0,\r\n                uvOffset + v1,\r\n                uvOffset + v2\r\n            );\r\n        }\r\n        if (primitive.material !== undefined) {\r\n            triangle.mat = primitive.material;\r\n        }\r\n        mesh.AddTriangle (triangle);\r\n    }\r\n\r\n    ImportNodes (gltf)\r\n    {\r\n        let scene = this.GetDefaultScene (gltf);\r\n        if (scene === null) {\r\n            return;\r\n        }\r\n        let rootNode = this.model.GetRootNode ();\r\n        for (let nodeIndex of scene.nodes) {\r\n            let gltfNode = gltf.nodes[nodeIndex];\r\n            this.ImportNode (gltf, gltfNode, rootNode);\r\n        }\r\n    }\r\n\r\n    ImportNode (gltf, gltfNode, parentNode)\r\n    {\r\n        function GetNodeTransformation (gltfNode)\r\n        {\r\n            let matrix = new Matrix ().CreateIdentity ();\r\n            if (gltfNode.matrix !== undefined) {\r\n                matrix.Set (gltfNode.matrix);\r\n            } else {\r\n                let translation = [0.0, 0.0, 0.0];\r\n                let rotation = [0.0, 0.0, 0.0, 1.0];\r\n                let scale = [1.0, 1.0, 1.0];\r\n                if (gltfNode.translation !== undefined) {\r\n                    translation = gltfNode.translation;\r\n                }\r\n                if (gltfNode.rotation !== undefined) {\r\n                    rotation = gltfNode.rotation;\r\n                }\r\n                if (gltfNode.scale !== undefined) {\r\n                    scale = gltfNode.scale;\r\n                }\r\n                matrix.ComposeTRS (\r\n                    ArrayToCoord3D (translation),\r\n                    ArrayToQuaternion (rotation),\r\n                    ArrayToCoord3D (scale)\r\n                );\r\n            }\r\n            return new Transformation (matrix);\r\n        }\r\n\r\n        if (gltfNode.children === undefined && gltfNode.mesh === undefined) {\r\n            return;\r\n        }\r\n\r\n        let node = new Node ();\r\n        if (gltfNode.name !== undefined) {\r\n            node.SetName (gltfNode.name);\r\n        }\r\n        node.SetTransformation (GetNodeTransformation (gltfNode));\r\n        parentNode.AddChildNode (node);\r\n\r\n        if (gltfNode.children !== undefined) {\r\n            for (let childIndex of gltfNode.children) {\r\n                let childGltfNode = gltf.nodes[childIndex];\r\n                this.ImportNode (gltf, childGltfNode, node);\r\n            }\r\n        }\r\n\r\n        if (gltfNode.mesh !== undefined) {\r\n            if (gltfNode.children === undefined || gltfNode.children.length === 0) {\r\n                node.SetType (NodeType.MeshNode);\r\n            }\r\n            node.AddMeshIndex (gltfNode.mesh);\r\n        }\r\n    }\r\n\r\n    GetReaderFromBufferView (bufferView)\r\n    {\r\n        let bufferIndex = bufferView.buffer || 0;\r\n        let buffer = this.bufferContents[bufferIndex];\r\n        if (buffer === undefined || buffer === null) {\r\n            return null;\r\n        }\r\n\r\n        let reader = new GltfBufferReader (buffer);\r\n        reader.SkipBytes (bufferView.byteOffset || 0);\r\n        let byteStride = bufferView.byteStride;\r\n        if (byteStride !== undefined && byteStride !== 0) {\r\n            reader.SetByteStride (byteStride);\r\n        }\r\n\r\n        return reader;\r\n    }\r\n\r\n    GetReaderFromAccessor (gltf, accessor)\r\n    {\r\n        let bufferViewIndex = accessor.bufferView || 0;\r\n        let bufferView = gltf.bufferViews[bufferViewIndex];\r\n        let reader = this.GetReaderFromBufferView (bufferView);\r\n        if (reader === null) {\r\n            return null;\r\n        }\r\n\r\n        reader.SetComponentType (accessor.componentType);\r\n        reader.SetDataType (accessor.type);\r\n        reader.SetDataCount (accessor.count);\r\n        reader.SkipBytes (accessor.byteOffset || 0);\r\n\r\n        if (accessor.sparse !== undefined) {\r\n            let indexReader = this.GetReaderFromSparseAccessor (gltf, accessor.sparse.indices, accessor.sparse.indices.componentType, 'SCALAR', accessor.sparse.count);\r\n            let valueReader = this.GetReaderFromSparseAccessor (gltf, accessor.sparse.values, accessor.componentType, accessor.type, accessor.sparse.count);\r\n            if (indexReader !== null && valueReader !== null) {\r\n                reader.SetSparseReader (indexReader, valueReader);\r\n            }\r\n        }\r\n        return reader;\r\n    }\r\n\r\n    GetReaderFromSparseAccessor (gltf, sparseAccessor, componentType, type, count)\r\n    {\r\n        if (sparseAccessor.bufferView === undefined) {\r\n            return null;\r\n        }\r\n\r\n        let bufferView = gltf.bufferViews[sparseAccessor.bufferView];\r\n        let reader = this.GetReaderFromBufferView (bufferView);\r\n        if (reader === null) {\r\n            return null;\r\n        }\r\n\r\n        reader.SetComponentType (componentType);\r\n        reader.SetDataType (type);\r\n        reader.SetDataCount (count);\r\n        reader.SkipBytes (sparseAccessor.byteOffset || 0);\r\n        return reader;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
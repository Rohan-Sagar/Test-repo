{"ast":null,"code":"import { Box2, BufferGeometry, FileLoader, Float32BufferAttribute, Loader, Matrix3, Path, Shape, ShapePath, ShapeUtils, Vector2, Vector3 } from 'three';\n\nclass SVGLoader extends Loader {\n  constructor(manager) {\n    super(manager); // Default dots per inch\n\n    this.defaultDPI = 90; // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\n    this.defaultUnit = 'px';\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(text) {\n    const scope = this;\n\n    function parseNode(node, style) {\n      if (node.nodeType !== 1) return;\n      const transform = getNodeTransform(node);\n      let isDefsNode = false;\n      let path = null;\n\n      switch (node.nodeName) {\n        case 'svg':\n          style = parseStyle(node, style);\n          break;\n\n        case 'style':\n          parseCSSStylesheet(node);\n          break;\n\n        case 'g':\n          style = parseStyle(node, style);\n          break;\n\n        case 'path':\n          style = parseStyle(node, style);\n          if (node.hasAttribute('d')) path = parsePathNode(node);\n          break;\n\n        case 'rect':\n          style = parseStyle(node, style);\n          path = parseRectNode(node);\n          break;\n\n        case 'polygon':\n          style = parseStyle(node, style);\n          path = parsePolygonNode(node);\n          break;\n\n        case 'polyline':\n          style = parseStyle(node, style);\n          path = parsePolylineNode(node);\n          break;\n\n        case 'circle':\n          style = parseStyle(node, style);\n          path = parseCircleNode(node);\n          break;\n\n        case 'ellipse':\n          style = parseStyle(node, style);\n          path = parseEllipseNode(node);\n          break;\n\n        case 'line':\n          style = parseStyle(node, style);\n          path = parseLineNode(node);\n          break;\n\n        case 'defs':\n          isDefsNode = true;\n          break;\n\n        case 'use':\n          style = parseStyle(node, style);\n          const href = node.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || '';\n          const usedNodeId = href.substring(1);\n          const usedNode = node.viewportElement.getElementById(usedNodeId);\n\n          if (usedNode) {\n            parseNode(usedNode, style);\n          } else {\n            console.warn('SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId);\n          }\n\n          break;\n\n        default: // console.log( node );\n\n      }\n\n      if (path) {\n        if (style.fill !== undefined && style.fill !== 'none') {\n          path.color.setStyle(style.fill);\n        }\n\n        transformPath(path, currentTransform);\n        paths.push(path);\n        path.userData = {\n          node: node,\n          style: style\n        };\n      }\n\n      const childNodes = node.childNodes;\n\n      for (let i = 0; i < childNodes.length; i++) {\n        const node = childNodes[i];\n\n        if (isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs') {\n          // Ignore everything in defs except CSS style definitions\n          // and nested defs, because it is OK by the standard to have\n          // <style/> there.\n          continue;\n        }\n\n        parseNode(node, style);\n      }\n\n      if (transform) {\n        transformStack.pop();\n\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1]);\n        } else {\n          currentTransform.identity();\n        }\n      }\n    }\n\n    function parsePathNode(node) {\n      const path = new ShapePath();\n      const point = new Vector2();\n      const control = new Vector2();\n      const firstPoint = new Vector2();\n      let isFirstPoint = true;\n      let doSetFirstPoint = false;\n      const d = node.getAttribute('d'); // console.log( d );\n\n      const commands = d.match(/[a-df-z][^a-df-z]*/ig);\n\n      for (let i = 0, l = commands.length; i < l; i++) {\n        const command = commands[i];\n        const type = command.charAt(0);\n        const data = command.slice(1).trim();\n\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true;\n          isFirstPoint = false;\n        }\n\n        let numbers;\n\n        switch (type) {\n          case 'M':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n\n              if (j === 0) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'H':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'V':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'L':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'C':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);\n              control.x = numbers[j + 2];\n              control.y = numbers[j + 3];\n              point.x = numbers[j + 4];\n              point.y = numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'S':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'Q':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);\n              control.x = numbers[j + 0];\n              control.y = numbers[j + 1];\n              point.x = numbers[j + 2];\n              point.y = numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'T':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = numbers[j + 0];\n              point.y = numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'A':\n            numbers = parseFloats(data, [3, 4], 7);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if start point == end point\n              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue;\n              const start = point.clone();\n              point.x = numbers[j + 5];\n              point.y = numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'm':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y);\n              } else {\n                path.lineTo(point.x, point.y);\n              }\n\n              if (j === 0) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'h':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'v':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'l':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0];\n              point.y += numbers[j + 1];\n              control.x = point.x;\n              control.y = point.y;\n              path.lineTo(point.x, point.y);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'c':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);\n              control.x = point.x + numbers[j + 2];\n              control.y = point.y + numbers[j + 3];\n              point.x += numbers[j + 4];\n              point.y += numbers[j + 5];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 's':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'q':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);\n              control.x = point.x + numbers[j + 0];\n              control.y = point.y + numbers[j + 1];\n              point.x += numbers[j + 2];\n              point.y += numbers[j + 3];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 't':\n            numbers = parseFloats(data);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x);\n              const ry = getReflection(point.y, control.y);\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);\n              control.x = rx;\n              control.y = ry;\n              point.x = point.x + numbers[j + 0];\n              point.y = point.y + numbers[j + 1];\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'a':\n            numbers = parseFloats(data, [3, 4], 7);\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if no displacement\n              if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue;\n              const start = point.clone();\n              point.x += numbers[j + 5];\n              point.y += numbers[j + 6];\n              control.x = point.x;\n              control.y = point.y;\n              parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);\n            }\n\n            break;\n\n          case 'Z':\n          case 'z':\n            path.currentPath.autoClose = true;\n\n            if (path.currentPath.curves.length > 0) {\n              // Reset point to beginning of Path\n              point.copy(firstPoint);\n              path.currentPath.currentPoint.copy(point);\n              isFirstPoint = true;\n            }\n\n            break;\n\n          default:\n            console.warn(command);\n        } // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\n        doSetFirstPoint = false;\n      }\n\n      return path;\n    }\n\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;\n\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        const stylesheet = node.sheet.cssRules[i];\n        if (stylesheet.type !== 1) continue;\n        const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map(i => i.trim());\n\n        for (let j = 0; j < selectorList.length; j++) {\n          // Remove empty rules\n          const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(_ref => {\n            let [, v] = _ref;\n            return v !== '';\n          }));\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions);\n        }\n      }\n    }\n    /**\n     * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n     * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n     * From\n     * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n     * To\n     * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n     */\n\n\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx == 0 || ry == 0) {\n        // draw a line if either of the radii == 0\n        path.lineTo(end.x, end.y);\n        return;\n      }\n\n      x_axis_rotation = x_axis_rotation * Math.PI / 180; // Ensure radii are positive\n\n      rx = Math.abs(rx);\n      ry = Math.abs(ry); // Compute (x1', y1')\n\n      const dx2 = (start.x - end.x) / 2.0;\n      const dy2 = (start.y - end.y) / 2.0;\n      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2; // Compute (cx', cy')\n\n      let rxs = rx * rx;\n      let rys = ry * ry;\n      const x1ps = x1p * x1p;\n      const y1ps = y1p * y1p; // Ensure radii are large enough\n\n      const cr = x1ps / rxs + y1ps / rys;\n\n      if (cr > 1) {\n        // scale up rx,ry equally so cr == 1\n        const s = Math.sqrt(cr);\n        rx = s * rx;\n        ry = s * ry;\n        rxs = rx * rx;\n        rys = ry * ry;\n      }\n\n      const dq = rxs * y1ps + rys * x1ps;\n      const pq = (rxs * rys - dq) / dq;\n      let q = Math.sqrt(Math.max(0, pq));\n      if (large_arc_flag === sweep_flag) q = -q;\n      const cxp = q * rx * y1p / ry;\n      const cyp = -q * ry * x1p / rx; // Step 3: Compute (cx, cy) from (cx', cy')\n\n      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2; // Step 4: Compute θ1 and Δθ\n\n      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n    }\n\n    function svgAngle(ux, uy, vx, vy) {\n      const dot = ux * vx + uy * vy;\n      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear\n\n      if (ux * vy - uy * vx < 0) ang = -ang;\n      return ang;\n    }\n    /*\n    * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n    * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n    */\n\n\n    function parseRectNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('x') || 0);\n      const y = parseFloatWithUnits(node.getAttribute('y') || 0);\n      const rx = parseFloatWithUnits(node.getAttribute('rx') || node.getAttribute('ry') || 0);\n      const ry = parseFloatWithUnits(node.getAttribute('ry') || node.getAttribute('rx') || 0);\n      const w = parseFloatWithUnits(node.getAttribute('width'));\n      const h = parseFloatWithUnits(node.getAttribute('height')); // Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n      // https://spencermortensen.com/articles/bezier-circle/\n\n      const bci = 1 - 0.551915024494;\n      const path = new ShapePath(); // top left\n\n      path.moveTo(x + rx, y); // top right\n\n      path.lineTo(x + w - rx, y);\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);\n      } // bottom right\n\n\n      path.lineTo(x + w, y + h - ry);\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);\n      } // bottom left\n\n\n      path.lineTo(x + rx, y + h);\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);\n      } // back to top left\n\n\n      path.lineTo(x, y + ry);\n\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);\n      }\n\n      return path;\n    }\n\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n\n        index++;\n      }\n\n      const regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute('points').replace(regex, iterator);\n      path.currentPath.autoClose = true;\n      return path;\n    }\n\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a);\n        const y = parseFloatWithUnits(b);\n\n        if (index === 0) {\n          path.moveTo(x, y);\n        } else {\n          path.lineTo(x, y);\n        }\n\n        index++;\n      }\n\n      const regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n      const path = new ShapePath();\n      let index = 0;\n      node.getAttribute('points').replace(regex, iterator);\n      path.currentPath.autoClose = false;\n      return path;\n    }\n\n    function parseCircleNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('cx') || 0);\n      const y = parseFloatWithUnits(node.getAttribute('cy') || 0);\n      const r = parseFloatWithUnits(node.getAttribute('r') || 0);\n      const subpath = new Path();\n      subpath.absarc(x, y, r, 0, Math.PI * 2);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n\n    function parseEllipseNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('cx') || 0);\n      const y = parseFloatWithUnits(node.getAttribute('cy') || 0);\n      const rx = parseFloatWithUnits(node.getAttribute('rx') || 0);\n      const ry = parseFloatWithUnits(node.getAttribute('ry') || 0);\n      const subpath = new Path();\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n      const path = new ShapePath();\n      path.subPaths.push(subpath);\n      return path;\n    }\n\n    function parseLineNode(node) {\n      const x1 = parseFloatWithUnits(node.getAttribute('x1') || 0);\n      const y1 = parseFloatWithUnits(node.getAttribute('y1') || 0);\n      const x2 = parseFloatWithUnits(node.getAttribute('x2') || 0);\n      const y2 = parseFloatWithUnits(node.getAttribute('y2') || 0);\n      const path = new ShapePath();\n      path.moveTo(x1, y1);\n      path.lineTo(x2, y2);\n      path.currentPath.autoClose = false;\n      return path;\n    } //\n\n\n    function parseStyle(node, style) {\n      style = Object.assign({}, style); // clone style\n\n      let stylesheetStyles = {};\n\n      if (node.hasAttribute('class')) {\n        const classSelectors = node.getAttribute('class').split(/\\s/).filter(Boolean).map(i => i.trim());\n\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]]);\n        }\n      }\n\n      if (node.hasAttribute('id')) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')]);\n      }\n\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === undefined) adjustFunction = function copy(v) {\n          if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.');\n          return v;\n        };\n        if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));\n        if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);\n        if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName]);\n      }\n\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)));\n      }\n\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v));\n      }\n\n      addStyle('fill', 'fill');\n      addStyle('fill-opacity', 'fillOpacity', clamp);\n      addStyle('fill-rule', 'fillRule');\n      addStyle('opacity', 'opacity', clamp);\n      addStyle('stroke', 'stroke');\n      addStyle('stroke-opacity', 'strokeOpacity', clamp);\n      addStyle('stroke-width', 'strokeWidth', positive);\n      addStyle('stroke-linejoin', 'strokeLineJoin');\n      addStyle('stroke-linecap', 'strokeLineCap');\n      addStyle('stroke-miterlimit', 'strokeMiterLimit', positive);\n      addStyle('visibility', 'visibility');\n      return style;\n    } // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\n    function getReflection(a, b) {\n      return a - (b - a);\n    } // from https://github.com/ppvg/svg-numbers (MIT License)\n\n\n    function parseFloats(input, flags, stride) {\n      if (typeof input !== 'string') {\n        throw new TypeError('Invalid input: ' + typeof input);\n      } // Character groups\n\n\n      const RE = {\n        SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i,\n        FLAGS: /[01]/\n      }; // States\n\n      const SEP = 0;\n      const INT = 1;\n      const FLOAT = 2;\n      const EXP = 3;\n      let state = SEP;\n      let seenComma = true;\n      let number = '',\n          exponent = '';\n      const result = [];\n\n      function throwSyntaxError(current, i, partial) {\n        const error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.');\n        error.partial = partial;\n        throw error;\n      }\n\n      function newNumber() {\n        if (number !== '') {\n          if (exponent === '') result.push(Number(number));else result.push(Number(number) * Math.pow(10, Number(exponent)));\n        }\n\n        number = '';\n        exponent = '';\n      }\n\n      let current;\n      const length = input.length;\n\n      for (let i = 0; i < length; i++) {\n        current = input[i]; // check for flags\n\n        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n          state = INT;\n          number = current;\n          newNumber();\n          continue;\n        } // parse until next number\n\n\n        if (state === SEP) {\n          // eat whitespace\n          if (RE.WHITESPACE.test(current)) {\n            continue;\n          } // start new number\n\n\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT;\n            number = current;\n            continue;\n          }\n\n          if (RE.POINT.test(current)) {\n            state = FLOAT;\n            number = current;\n            continue;\n          } // throw on double commas (e.g. \"1, , 2\")\n\n\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result);\n            }\n\n            seenComma = true;\n          }\n        } // parse integer part\n\n\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n\n          if (RE.POINT.test(current)) {\n            number += current;\n            state = FLOAT;\n            continue;\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          } // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\n\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result);\n          }\n        } // parse decimal part\n\n\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current;\n            continue;\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP;\n            continue;\n          } // throw on double decimal points (e.g. \"1..2\")\n\n\n          if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n            throwSyntaxError(current, i, result);\n          }\n        } // parse exponent part\n\n\n        if (state === EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current;\n            continue;\n          }\n\n          if (RE.SIGN.test(current)) {\n            if (exponent === '') {\n              exponent += current;\n              continue;\n            }\n\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result);\n            }\n          }\n        } // end of number\n\n\n        if (RE.WHITESPACE.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = false;\n        } else if (RE.COMMA.test(current)) {\n          newNumber();\n          state = SEP;\n          seenComma = true;\n        } else if (RE.SIGN.test(current)) {\n          newNumber();\n          state = INT;\n          number = current;\n        } else if (RE.POINT.test(current)) {\n          newNumber();\n          state = FLOAT;\n          number = current;\n        } else {\n          throwSyntaxError(current, i, result);\n        }\n      } // add the last number found (if any)\n\n\n      newNumber();\n      return result;\n    } // Units\n\n\n    const units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']; // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\n    const unitConversion = {\n      'mm': {\n        'mm': 1,\n        'cm': 0.1,\n        'in': 1 / 25.4,\n        'pt': 72 / 25.4,\n        'pc': 6 / 25.4,\n        'px': -1\n      },\n      'cm': {\n        'mm': 10,\n        'cm': 1,\n        'in': 1 / 2.54,\n        'pt': 72 / 2.54,\n        'pc': 6 / 2.54,\n        'px': -1\n      },\n      'in': {\n        'mm': 25.4,\n        'cm': 2.54,\n        'in': 1,\n        'pt': 72,\n        'pc': 6,\n        'px': -1\n      },\n      'pt': {\n        'mm': 25.4 / 72,\n        'cm': 2.54 / 72,\n        'in': 1 / 72,\n        'pt': 1,\n        'pc': 6 / 72,\n        'px': -1\n      },\n      'pc': {\n        'mm': 25.4 / 6,\n        'cm': 2.54 / 6,\n        'in': 1 / 6,\n        'pt': 72 / 6,\n        'pc': 1,\n        'px': -1\n      },\n      'px': {\n        'px': 1\n      }\n    };\n\n    function parseFloatWithUnits(string) {\n      let theUnit = 'px';\n\n      if (typeof string === 'string' || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          const u = units[i];\n\n          if (string.endsWith(u)) {\n            theUnit = u;\n            string = string.substring(0, string.length - u.length);\n            break;\n          }\n        }\n      }\n\n      let scale = undefined;\n\n      if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n        // Conversion scale from  pixels to inches, then to default units\n        scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI;\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit];\n\n        if (scale < 0) {\n          // Conversion scale to pixels\n          scale = unitConversion[theUnit]['in'] * scope.defaultDPI;\n        }\n      }\n\n      return scale * parseFloat(string);\n    } // Transforms\n\n\n    function getNodeTransform(node) {\n      if (!(node.hasAttribute('transform') || node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))) {\n        return null;\n      }\n\n      const transform = parseNodeTransform(node);\n\n      if (transformStack.length > 0) {\n        transform.premultiply(transformStack[transformStack.length - 1]);\n      }\n\n      currentTransform.copy(transform);\n      transformStack.push(transform);\n      return transform;\n    }\n\n    function parseNodeTransform(node) {\n      const transform = new Matrix3();\n      const currentTransform = tempTransform0;\n\n      if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n        const tx = parseFloatWithUnits(node.getAttribute('x'));\n        const ty = parseFloatWithUnits(node.getAttribute('y'));\n        transform.translate(tx, ty);\n      }\n\n      if (node.hasAttribute('transform')) {\n        const transformsTexts = node.getAttribute('transform').split(')');\n\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          const transformText = transformsTexts[tIndex].trim();\n          if (transformText === '') continue;\n          const openParPos = transformText.indexOf('(');\n          const closeParPos = transformText.length;\n\n          if (openParPos > 0 && openParPos < closeParPos) {\n            const transformType = transformText.slice(0, openParPos);\n            const array = parseFloats(transformText.slice(openParPos + 1));\n            currentTransform.identity();\n\n            switch (transformType) {\n              case 'translate':\n                if (array.length >= 1) {\n                  const tx = array[0];\n                  let ty = 0;\n\n                  if (array.length >= 2) {\n                    ty = array[1];\n                  }\n\n                  currentTransform.translate(tx, ty);\n                }\n\n                break;\n\n              case 'rotate':\n                if (array.length >= 1) {\n                  let angle = 0;\n                  let cx = 0;\n                  let cy = 0; // Angle\n\n                  angle = -array[0] * Math.PI / 180;\n\n                  if (array.length >= 3) {\n                    // Center x, y\n                    cx = array[1];\n                    cy = array[2];\n                  } // Rotate around center (cx, cy)\n\n\n                  tempTransform1.identity().translate(-cx, -cy);\n                  tempTransform2.identity().rotate(angle);\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);\n                  tempTransform1.identity().translate(cx, cy);\n                  currentTransform.multiplyMatrices(tempTransform1, tempTransform3);\n                }\n\n                break;\n\n              case 'scale':\n                if (array.length >= 1) {\n                  const scaleX = array[0];\n                  let scaleY = scaleX;\n\n                  if (array.length >= 2) {\n                    scaleY = array[1];\n                  }\n\n                  currentTransform.scale(scaleX, scaleY);\n                }\n\n                break;\n\n              case 'skewX':\n                if (array.length === 1) {\n                  currentTransform.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);\n                }\n\n                break;\n\n              case 'skewY':\n                if (array.length === 1) {\n                  currentTransform.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);\n                }\n\n                break;\n\n              case 'matrix':\n                if (array.length === 6) {\n                  currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);\n                }\n\n                break;\n            }\n          }\n\n          transform.premultiply(currentTransform);\n        }\n      }\n\n      return transform;\n    }\n\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);\n        v2.set(tempV3.x, tempV3.y);\n      }\n\n      const isRotated = isTransformRotated(m);\n      const subPaths = path.subPaths;\n\n      for (let i = 0, n = subPaths.length; i < n; i++) {\n        const subPath = subPaths[i];\n        const curves = subPath.curves;\n\n        for (let j = 0; j < curves.length; j++) {\n          const curve = curves[j];\n\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n            transfVec2(curve.v3);\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0);\n            transfVec2(curve.v1);\n            transfVec2(curve.v2);\n          } else if (curve.isEllipseCurve) {\n            if (isRotated) {\n              console.warn('SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.');\n            }\n\n            tempV2.set(curve.aX, curve.aY);\n            transfVec2(tempV2);\n            curve.aX = tempV2.x;\n            curve.aY = tempV2.y;\n            curve.xRadius *= getTransformScaleX(m);\n            curve.yRadius *= getTransformScaleY(m);\n          }\n        }\n      }\n    }\n\n    function isTransformRotated(m) {\n      return m.elements[1] !== 0 || m.elements[3] !== 0;\n    }\n\n    function getTransformScaleX(m) {\n      const te = m.elements;\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1]);\n    }\n\n    function getTransformScaleY(m) {\n      const te = m.elements;\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4]);\n    } //\n\n\n    const paths = [];\n    const stylesheets = {};\n    const transformStack = [];\n    const tempTransform0 = new Matrix3();\n    const tempTransform1 = new Matrix3();\n    const tempTransform2 = new Matrix3();\n    const tempTransform3 = new Matrix3();\n    const tempV2 = new Vector2();\n    const tempV3 = new Vector3();\n    const currentTransform = new Matrix3();\n    const xml = new DOMParser().parseFromString(text, 'image/svg+xml'); // application/xml\n\n    parseNode(xml.documentElement, {\n      fill: '#000',\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: 'miter',\n      strokeLineCap: 'butt',\n      strokeMiterLimit: 4\n    });\n    const data = {\n      paths: paths,\n      xml: xml.documentElement\n    }; // console.log( paths );\n\n    return data;\n  }\n\n  static createShapes(shapePath) {\n    // Param shapePath: a shapepath as returned by the parse function of this class\n    // Returns Shape object\n    const BIGNUMBER = 999999999;\n    const IntersectionLocationType = {\n      ORIGIN: 0,\n      DESTINATION: 1,\n      BETWEEN: 2,\n      LEFT: 3,\n      RIGHT: 4,\n      BEHIND: 5,\n      BEYOND: 6\n    };\n    const classifyResult = {\n      loc: IntersectionLocationType.ORIGIN,\n      t: 0\n    };\n\n    function findEdgeIntersection(a0, a1, b0, b1) {\n      const x1 = a0.x;\n      const x2 = a1.x;\n      const x3 = b0.x;\n      const x4 = b1.x;\n      const y1 = a0.y;\n      const y2 = a1.y;\n      const y3 = b0.y;\n      const y4 = b1.y;\n      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n      const t1 = nom1 / denom;\n      const t2 = nom2 / denom;\n\n      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n        //1. lines are parallel or edges don't intersect\n        return null;\n      } else if (nom1 === 0 && denom === 0) {\n        //2. lines are colinear\n        //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1); //find position of this endpoints relatively to edge1\n\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return {\n              x: point.x,\n              y: point.y,\n              t: classifyResult.t\n            };\n          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);\n            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);\n            return {\n              x: x,\n              y: y,\n              t: classifyResult.t\n            };\n          }\n        }\n\n        return null;\n      } else {\n        //3. edges intersect\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1);\n\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1;\n            return {\n              x: point.x,\n              y: point.y,\n              t: classifyResult.t\n            };\n          }\n        }\n\n        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);\n        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);\n        return {\n          x: x,\n          y: y,\n          t: t1\n        };\n      }\n    }\n\n    function classifyPoint(p, edgeStart, edgeEnd) {\n      const ax = edgeEnd.x - edgeStart.x;\n      const ay = edgeEnd.y - edgeStart.y;\n      const bx = p.x - edgeStart.x;\n      const by = p.y - edgeStart.y;\n      const sa = ax * by - bx * ay;\n\n      if (p.x === edgeStart.x && p.y === edgeStart.y) {\n        classifyResult.loc = IntersectionLocationType.ORIGIN;\n        classifyResult.t = 0;\n        return;\n      }\n\n      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n        classifyResult.loc = IntersectionLocationType.DESTINATION;\n        classifyResult.t = 1;\n        return;\n      }\n\n      if (sa < -Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.LEFT;\n        return;\n      }\n\n      if (sa > Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.RIGHT;\n        return;\n      }\n\n      if (ax * bx < 0 || ay * by < 0) {\n        classifyResult.loc = IntersectionLocationType.BEHIND;\n        return;\n      }\n\n      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n        classifyResult.loc = IntersectionLocationType.BEYOND;\n        return;\n      }\n\n      let t;\n\n      if (ax !== 0) {\n        t = bx / ax;\n      } else {\n        t = by / ay;\n      }\n\n      classifyResult.loc = IntersectionLocationType.BETWEEN;\n      classifyResult.t = t;\n    }\n\n    function getIntersections(path1, path2) {\n      const intersectionsRaw = [];\n      const intersections = [];\n\n      for (let index = 1; index < path1.length; index++) {\n        const path1EdgeStart = path1[index - 1];\n        const path1EdgeEnd = path1[index];\n\n        for (let index2 = 1; index2 < path2.length; index2++) {\n          const path2EdgeStart = path2[index2 - 1];\n          const path2EdgeEnd = path2[index2];\n          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);\n\n          if (intersection !== null && intersectionsRaw.find(i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON) === undefined) {\n            intersectionsRaw.push(intersection);\n            intersections.push(new Vector2(intersection.x, intersection.y));\n          }\n        }\n      }\n\n      return intersections;\n    }\n\n    function getScanlineIntersections(scanline, boundingBox, paths) {\n      const center = new Vector2();\n      boundingBox.getCenter(center);\n      const allIntersections = [];\n      paths.forEach(path => {\n        // check if the center of the bounding box is in the bounding box of the paths.\n        // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n        // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n        if (path.boundingBox.containsPoint(center)) {\n          const intersections = getIntersections(scanline, path.points);\n          intersections.forEach(p => {\n            allIntersections.push({\n              identifier: path.identifier,\n              isCW: path.isCW,\n              point: p\n            });\n          });\n        }\n      });\n      allIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      return allIntersections;\n    }\n\n    function isHoleTo(simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule) {\n      if (_fillRule === null || _fillRule === undefined || _fillRule === '') {\n        _fillRule = 'nonzero';\n      }\n\n      const centerBoundingBox = new Vector2();\n      simplePath.boundingBox.getCenter(centerBoundingBox);\n      const scanline = [new Vector2(scanlineMinX, centerBoundingBox.y), new Vector2(scanlineMaxX, centerBoundingBox.y)];\n      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);\n      scanlineIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x;\n      });\n      const baseIntersections = [];\n      const otherIntersections = [];\n      scanlineIntersections.forEach(i => {\n        if (i.identifier === simplePath.identifier) {\n          baseIntersections.push(i);\n        } else {\n          otherIntersections.push(i);\n        }\n      });\n      const firstXOfPath = baseIntersections[0].point.x; // build up the path hierarchy\n\n      const stack = [];\n      let i = 0;\n\n      while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n          stack.pop();\n        } else {\n          stack.push(otherIntersections[i].identifier);\n        }\n\n        i++;\n      }\n\n      stack.push(simplePath.identifier);\n\n      if (_fillRule === 'evenodd') {\n        const isHole = stack.length % 2 === 0 ? true : false;\n        const isHoleFor = stack[stack.length - 2];\n        return {\n          identifier: simplePath.identifier,\n          isHole: isHole,\n          for: isHoleFor\n        };\n      } else if (_fillRule === 'nonzero') {\n        // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n        let isHole = true;\n        let isHoleFor = null;\n        let lastCWValue = null;\n\n        for (let i = 0; i < stack.length; i++) {\n          const identifier = stack[i];\n\n          if (isHole) {\n            lastCWValue = allPaths[identifier].isCW;\n            isHole = false;\n            isHoleFor = identifier;\n          } else if (lastCWValue !== allPaths[identifier].isCW) {\n            lastCWValue = allPaths[identifier].isCW;\n            isHole = true;\n          }\n        }\n\n        return {\n          identifier: simplePath.identifier,\n          isHole: isHole,\n          for: isHoleFor\n        };\n      } else {\n        console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.');\n      }\n    } // check for self intersecting paths\n    // TODO\n    // check intersecting paths\n    // TODO\n    // prepare paths for hole detection\n\n\n    let identifier = 0;\n    let scanlineMinX = BIGNUMBER;\n    let scanlineMaxX = -BIGNUMBER;\n    let simplePaths = shapePath.subPaths.map(p => {\n      const points = p.getPoints();\n      let maxY = -BIGNUMBER;\n      let minY = BIGNUMBER;\n      let maxX = -BIGNUMBER;\n      let minX = BIGNUMBER; //points.forEach(p => p.y *= -1);\n\n      for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n\n        if (p.y > maxY) {\n          maxY = p.y;\n        }\n\n        if (p.y < minY) {\n          minY = p.y;\n        }\n\n        if (p.x > maxX) {\n          maxX = p.x;\n        }\n\n        if (p.x < minX) {\n          minX = p.x;\n        }\n      } //\n\n\n      if (scanlineMaxX <= maxX) {\n        scanlineMaxX = maxX + 1;\n      }\n\n      if (scanlineMinX >= minX) {\n        scanlineMinX = minX - 1;\n      }\n\n      return {\n        curves: p.curves,\n        points: points,\n        isCW: ShapeUtils.isClockWise(points),\n        identifier: identifier++,\n        boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY))\n      };\n    });\n    simplePaths = simplePaths.filter(sp => sp.points.length > 1); // check if path is solid or a hole\n\n    const isAHole = simplePaths.map(p => isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData?.style.fillRule));\n    const shapesToReturn = [];\n    simplePaths.forEach(p => {\n      const amIAHole = isAHole[p.identifier];\n\n      if (!amIAHole.isHole) {\n        const shape = new Shape();\n        shape.curves = p.curves;\n        const holes = isAHole.filter(h => h.isHole && h.for === p.identifier);\n        holes.forEach(h => {\n          const hole = simplePaths[h.identifier];\n          const path = new Path();\n          path.curves = hole.curves;\n          shape.holes.push(path);\n        });\n        shapesToReturn.push(shape);\n      }\n    });\n    return shapesToReturn;\n  }\n\n  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n    // Param width: Stroke width\n    // Param color: As returned by THREE.Color.getStyle()\n    // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n    // Param lineCap: One of \"round\", \"square\" or \"butt\"\n    // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n    // Returns style object\n    width = width !== undefined ? width : 1;\n    color = color !== undefined ? color : '#000';\n    lineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n    lineCap = lineCap !== undefined ? lineCap : 'butt';\n    miterLimit = miterLimit !== undefined ? miterLimit : 4;\n    return {\n      strokeColor: color,\n      strokeWidth: width,\n      strokeLineJoin: lineJoin,\n      strokeLineCap: lineCap,\n      strokeMiterLimit: miterLimit\n    };\n  }\n\n  static pointsToStroke(points, style, arcDivisions, minDistance) {\n    // Generates a stroke with some witdh around the given path.\n    // The path can be open or closed (last point equals to first point)\n    // Param points: Array of Vector2D (the path). Minimum 2 points.\n    // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n    // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n    // Param minDistance: Points closer to this distance will be merged. (Optional)\n    // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n\n    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n      return null;\n    }\n\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n    return geometry;\n  }\n\n  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n    // This function can be called to update existing arrays or buffers.\n    // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n    // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n    // Returns number of written vertices / normals / uvs pairs\n    // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n    // 'normals' and 'uvs' buffers are optional\n    const tempV2_1 = new Vector2();\n    const tempV2_2 = new Vector2();\n    const tempV2_3 = new Vector2();\n    const tempV2_4 = new Vector2();\n    const tempV2_5 = new Vector2();\n    const tempV2_6 = new Vector2();\n    const tempV2_7 = new Vector2();\n    const lastPointL = new Vector2();\n    const lastPointR = new Vector2();\n    const point0L = new Vector2();\n    const point0R = new Vector2();\n    const currentPointL = new Vector2();\n    const currentPointR = new Vector2();\n    const nextPointL = new Vector2();\n    const nextPointR = new Vector2();\n    const innerPoint = new Vector2();\n    const outerPoint = new Vector2();\n    arcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n    minDistance = minDistance !== undefined ? minDistance : 0.001;\n    vertexOffset = vertexOffset !== undefined ? vertexOffset : 0; // First ensure there are no duplicated points\n\n    points = removeDuplicatedPoints(points);\n    const numPoints = points.length;\n    if (numPoints < 2) return 0;\n    const isClosed = points[0].equals(points[numPoints - 1]);\n    let currentPoint;\n    let previousPoint = points[0];\n    let nextPoint;\n    const strokeWidth2 = style.strokeWidth / 2;\n    const deltaU = 1 / (numPoints - 1);\n    let u0 = 0,\n        u1;\n    let innerSideModified;\n    let joinIsOnLeftSide;\n    let isMiter;\n    let initialJoinIsOnLeftSide = false;\n    let numVertices = 0;\n    let currentCoordinate = vertexOffset * 3;\n    let currentCoordinateUV = vertexOffset * 2; // Get initial left and right stroke points\n\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);\n    lastPointL.copy(points[0]).sub(tempV2_1);\n    lastPointR.copy(points[0]).add(tempV2_1);\n    point0L.copy(lastPointL);\n    point0R.copy(lastPointR);\n\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint]; // Get next point\n\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          // Skip duplicated initial point\n          nextPoint = points[1];\n        } else nextPoint = undefined;\n      } else {\n        nextPoint = points[iPoint + 1];\n      } // Normal of previous segment in tempV2_1\n\n\n      const normal1 = tempV2_1;\n      getNormal(previousPoint, currentPoint, normal1);\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);\n      currentPointL.copy(currentPoint).sub(tempV2_3);\n      currentPointR.copy(currentPoint).add(tempV2_3);\n      u1 = u0 + deltaU;\n      innerSideModified = false;\n\n      if (nextPoint !== undefined) {\n        // Normal of next segment in tempV2_2\n        getNormal(currentPoint, nextPoint, tempV2_2);\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);\n        nextPointL.copy(currentPoint).sub(tempV2_3);\n        nextPointR.copy(currentPoint).add(tempV2_3);\n        joinIsOnLeftSide = true;\n        tempV2_3.subVectors(nextPoint, previousPoint);\n\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false;\n        }\n\n        if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n        tempV2_3.subVectors(nextPoint, currentPoint);\n        tempV2_3.normalize();\n        const dot = Math.abs(normal1.dot(tempV2_3)); // If path is straight, don't create join\n\n        if (dot > Number.EPSILON) {\n          // Compute inner and outer segment intersections\n          const miterSide = strokeWidth2 / dot;\n          tempV2_3.multiplyScalar(-miterSide);\n          tempV2_4.subVectors(currentPoint, previousPoint);\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);\n          innerPoint.copy(tempV2_5).negate();\n          const miterLength2 = tempV2_5.length();\n          const segmentLengthPrev = tempV2_4.length();\n          tempV2_4.divideScalar(segmentLengthPrev);\n          tempV2_6.subVectors(nextPoint, currentPoint);\n          const segmentLengthNext = tempV2_6.length();\n          tempV2_6.divideScalar(segmentLengthNext); // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true;\n          }\n\n          outerPoint.copy(tempV2_5).add(currentPoint);\n          innerPoint.add(currentPoint);\n          isMiter = false;\n\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint);\n              currentPointR.copy(innerPoint);\n            } else {\n              nextPointL.copy(innerPoint);\n              currentPointL.copy(innerPoint);\n            }\n          } else {\n            // The segment triangles are generated here if there was overlapping\n            makeSegmentTriangles();\n          }\n\n          switch (style.strokeLineJoin) {\n            case 'bevel':\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n              break;\n\n            case 'round':\n              // Segment triangles\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Join triangles\n\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);\n              }\n\n              break;\n\n            case 'miter':\n            case 'miter-clip':\n            default:\n              const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;\n\n              if (miterFraction < 1) {\n                // The join miter length exceeds the miter limit\n                if (style.strokeLineJoin !== 'miter-clip') {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);\n                  break;\n                } else {\n                  // Segment triangles\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified); // Miter-clip join triangles\n\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 0);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_6, u1, 1);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(tempV2_7, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n              } else {\n                // Miter join segment triangles\n                if (innerSideModified) {\n                  // Optimized segment + join triangles\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(innerPoint, u1, 1);\n                  } else {\n                    addVertex(lastPointR, u0, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(lastPointL, u0, 0);\n                    addVertex(innerPoint, u1, 0);\n                    addVertex(outerPoint, u1, 1);\n                  }\n\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint);\n                  } else {\n                    nextPointR.copy(outerPoint);\n                  }\n                } else {\n                  // Add extra miter join triangles\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 0);\n                    addVertex(nextPointL, u1, 0);\n                  } else {\n                    addVertex(currentPointR, u1, 1);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(currentPoint, u1, 0.5);\n                    addVertex(outerPoint, u1, 1);\n                    addVertex(nextPointR, u1, 1);\n                  }\n                }\n\n                isMiter = true;\n              }\n\n              break;\n          }\n        } else {\n          // The segment triangles are generated here when two consecutive points are collinear\n          makeSegmentTriangles();\n        }\n      } else {\n        // The segment triangles are generated here if it is the ending segment\n        makeSegmentTriangles();\n      }\n\n      if (!isClosed && iPoint === numPoints - 1) {\n        // Start line endcap\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);\n      } // Increment loop variables\n\n\n      u0 = u1;\n      previousPoint = currentPoint;\n      lastPointL.copy(nextPointL);\n      lastPointR.copy(nextPointR);\n    }\n\n    if (!isClosed) {\n      // Ending line endcap\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);\n    } else if (innerSideModified && vertices) {\n      // Modify path first segment vertices to adjust to the segments inner and outer intersections\n      let lastOuter = outerPoint;\n      let lastInner = innerPoint;\n\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint;\n        lastInner = outerPoint;\n      }\n\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3);\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3);\n          lastInner.toArray(vertices, 3 * 3);\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3);\n          }\n        }\n      }\n    }\n\n    return numVertices; // -- End of algorithm\n    // -- Functions\n\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1);\n      return result.set(-result.y, result.x).normalize();\n    }\n\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x;\n        vertices[currentCoordinate + 1] = position.y;\n        vertices[currentCoordinate + 2] = 0;\n\n        if (normals) {\n          normals[currentCoordinate] = 0;\n          normals[currentCoordinate + 1] = 0;\n          normals[currentCoordinate + 2] = 1;\n        }\n\n        currentCoordinate += 3;\n\n        if (uvs) {\n          uvs[currentCoordinateUV] = u;\n          uvs[currentCoordinateUV + 1] = v;\n          currentCoordinateUV += 2;\n        }\n      }\n\n      numVertices += 3;\n    }\n\n    function makeCircularSector(center, p1, p2, u, v) {\n      // param p1, p2: Points in the circle arc.\n      // p1 and p2 are in clockwise direction.\n      tempV2_1.copy(p1).sub(center).normalize();\n      tempV2_2.copy(p2).sub(center).normalize();\n      let angle = Math.PI;\n      const dot = tempV2_1.dot(tempV2_2);\n      if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));\n      angle /= arcDivisions;\n      tempV2_3.copy(p1);\n\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle);\n        addVertex(tempV2_3, u, v);\n        addVertex(tempV2_4, u, v);\n        addVertex(center, u, 0.5);\n        tempV2_3.copy(tempV2_4);\n      }\n\n      addVertex(tempV2_4, u, v);\n      addVertex(p2, u, v);\n      addVertex(center, u, 0.5);\n    }\n\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1);\n      addVertex(lastPointL, u0, 0);\n      addVertex(currentPointL, u1, 0);\n      addVertex(lastPointR, u0, 1);\n      addVertex(currentPointL, u1, 1);\n      addVertex(currentPointR, u1, 0);\n    }\n\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n      if (innerSideModified) {\n        // Optimized segment + bevel triangles\n        if (joinIsOnLeftSide) {\n          // Path segments triangles\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1); // Bevel join triangle\n\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        } else {\n          // Path segments triangles\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1); // Bevel join triangle\n\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(innerPoint, u, 0.5);\n        }\n      } else {\n        // Bevel join triangle. The segment triangles are done in the main loop\n        if (joinIsOnLeftSide) {\n          addVertex(currentPointL, u, 0);\n          addVertex(nextPointL, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        } else {\n          addVertex(currentPointR, u, 1);\n          addVertex(nextPointR, u, 0);\n          addVertex(currentPoint, u, 0.5);\n        }\n      }\n    }\n\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n      if (innerSideModified) {\n        if (joinIsOnLeftSide) {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointL, u1, 0);\n          addVertex(lastPointR, u0, 1);\n          addVertex(currentPointL, u1, 0);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPointL, u0, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 1);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(nextPointL, u0, 0);\n          addVertex(innerPoint, u1, 1);\n        } else {\n          addVertex(lastPointR, u0, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(lastPointL, u0, 0);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPointR, u1, 1);\n          addVertex(currentPointR, u0, 1);\n          addVertex(innerPoint, u1, 0);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(currentPoint, u1, 0.5);\n          addVertex(innerPoint, u1, 0);\n          addVertex(nextPointR, u0, 1);\n        }\n      }\n    }\n\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n      // param center: End point of the path\n      // param p1, p2: Left and right cap points\n      switch (style.strokeLineCap) {\n        case 'round':\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5);\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5);\n          }\n\n          break;\n\n        case 'square':\n          if (start) {\n            tempV2_1.subVectors(p1, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center); // Modify already existing vertices\n\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n              tempV2_4.toArray(vertices, 3 * 3);\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3);\n              tempV2_3.toArray(vertices, 3 * 3);\n              tempV2_4.toArray(vertices, 0 * 3);\n            }\n          } else {\n            tempV2_1.subVectors(p2, center);\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x);\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);\n            const vl = vertices.length; // Modify already existing vertices\n\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            } else {\n              tempV2_3.toArray(vertices, vl - 2 * 3);\n              tempV2_4.toArray(vertices, vl - 1 * 3);\n              tempV2_4.toArray(vertices, vl - 4 * 3);\n            }\n          }\n\n          break;\n\n        case 'butt':\n        default:\n          // Nothing to do here\n          break;\n      }\n    }\n\n    function removeDuplicatedPoints(points) {\n      // Creates a new array if necessary with duplicated points removed.\n      // This does not remove duplicated initial and ending points of a closed path.\n      let dupPoints = false;\n\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) < minDistance) {\n          dupPoints = true;\n          break;\n        }\n      }\n\n      if (!dupPoints) return points;\n      const newPoints = [];\n      newPoints.push(points[0]);\n\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n          newPoints.push(points[i]);\n        }\n      }\n\n      newPoints.push(points[points.length - 1]);\n      return newPoints;\n    }\n  }\n\n}\n\nexport { SVGLoader };","map":{"version":3,"names":["Box2","BufferGeometry","FileLoader","Float32BufferAttribute","Loader","Matrix3","Path","Shape","ShapePath","ShapeUtils","Vector2","Vector3","SVGLoader","constructor","manager","defaultDPI","defaultUnit","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","parseNode","node","style","nodeType","transform","getNodeTransform","isDefsNode","nodeName","parseStyle","parseCSSStylesheet","hasAttribute","parsePathNode","parseRectNode","parsePolygonNode","parsePolylineNode","parseCircleNode","parseEllipseNode","parseLineNode","href","getAttributeNS","usedNodeId","substring","usedNode","viewportElement","getElementById","warn","fill","undefined","color","setStyle","transformPath","currentTransform","paths","push","userData","childNodes","i","length","transformStack","pop","copy","identity","point","control","firstPoint","isFirstPoint","doSetFirstPoint","d","getAttribute","commands","match","l","command","type","charAt","data","slice","trim","numbers","parseFloats","j","jl","x","y","moveTo","lineTo","bezierCurveTo","getReflection","quadraticCurveTo","rx","ry","start","clone","parseArcCommand","currentPath","autoClose","curves","currentPoint","sheet","cssRules","stylesheet","selectorList","selectorText","split","filter","Boolean","map","definitions","Object","fromEntries","entries","v","stylesheets","assign","x_axis_rotation","large_arc_flag","sweep_flag","end","Math","PI","abs","dx2","dy2","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseFloatWithUnits","w","h","bci","iterator","a","b","index","regex","replace","r","subpath","absarc","subPaths","x1","y1","x2","y2","stylesheetStyles","classSelectors","addStyle","svgName","jsName","adjustFunction","startsWith","clamp","positive","input","flags","stride","TypeError","RE","SEPARATOR","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","FLAGS","SEP","INT","FLOAT","state","seenComma","number","exponent","result","throwSyntaxError","current","partial","SyntaxError","newNumber","Number","pow","Array","isArray","includes","test","units","unitConversion","string","theUnit","String","n","u","endsWith","scale","parseFloat","parseNodeTransform","premultiply","tempTransform0","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","array","angle","tempTransform1","tempTransform2","rotate","tempTransform3","multiplyMatrices","scaleX","scaleY","set","tan","m","transfVec2","v2","tempV3","applyMatrix3","isRotated","isTransformRotated","subPath","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","tempV2","aX","aY","xRadius","getTransformScaleX","yRadius","getTransformScaleY","elements","te","xml","DOMParser","parseFromString","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","createShapes","shapePath","BIGNUMBER","IntersectionLocationType","ORIGIN","DESTINATION","BETWEEN","LEFT","RIGHT","BEHIND","BEYOND","classifyResult","loc","t","findEdgeIntersection","a0","a1","b0","b1","x3","x4","y3","y4","nom1","nom2","denom","t1","t2","classifyPoint","toPrecision","p","edgeStart","edgeEnd","ax","ay","bx","by","sa","EPSILON","getIntersections","path1","path2","intersectionsRaw","intersections","path1EdgeStart","path1EdgeEnd","index2","path2EdgeStart","path2EdgeEnd","intersection","find","getScanlineIntersections","scanline","boundingBox","center","getCenter","allIntersections","forEach","containsPoint","points","identifier","isCW","sort","i1","i2","isHoleTo","simplePath","allPaths","scanlineMinX","scanlineMaxX","_fillRule","centerBoundingBox","scanlineIntersections","baseIntersections","otherIntersections","firstXOfPath","stack","isHole","isHoleFor","for","lastCWValue","simplePaths","getPoints","maxY","minY","maxX","minX","isClockWise","sp","isAHole","fillRule","shapesToReturn","amIAHole","shape","holes","hole","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","setAttribute","vertexOffset","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","removeDuplicatedPoints","numPoints","isClosed","equals","previousPoint","nextPoint","strokeWidth2","deltaU","u0","u1","innerSideModified","joinIsOnLeftSide","isMiter","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","position","il","rotateAround","addVectors","vl","dupPoints","distanceTo","newPoints"],"sources":["/Users/rohansagar/Desktop/node+react/client/node-react-3d/node_modules/three/examples/jsm/loaders/SVGLoader.js"],"sourcesContent":["import {\n\tBox2,\n\tBufferGeometry,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tMatrix3,\n\tPath,\n\tShape,\n\tShapePath,\n\tShapeUtils,\n\tVector2,\n\tVector3\n} from 'three';\n\nclass SVGLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Default dots per inch\n\t\tthis.defaultDPI = 90;\n\n\t\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\t\tthis.defaultUnit = 'px';\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text ) {\n\n\t\tconst scope = this;\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tconst transform = getNodeTransform( node );\n\n\t\t\tlet isDefsNode = false;\n\n\t\t\tlet path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'style':\n\t\t\t\t\tparseCSSStylesheet( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'defs':\n\t\t\t\t\tisDefsNode = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'use':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\n\t\t\t\t\tconst href = node.getAttributeNS( 'http://www.w3.org/1999/xlink', 'href' ) || '';\n\t\t\t\t\tconst usedNodeId = href.substring( 1 );\n\t\t\t\t\tconst usedNode = node.viewportElement.getElementById( usedNodeId );\n\t\t\t\t\tif ( usedNode ) {\n\n\t\t\t\t\t\tparseNode( usedNode, style );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// console.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tconst childNodes = node.childNodes;\n\n\t\t\tfor ( let i = 0; i < childNodes.length; i ++ ) {\n\n\t\t\t\tconst node = childNodes[ i ];\n\n\t\t\t\tif ( isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs' ) {\n\n\t\t\t\t\t// Ignore everything in defs except CSS style definitions\n\t\t\t\t\t// and nested defs, because it is OK by the standard to have\n\t\t\t\t\t// <style/> there.\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tparseNode( node, style );\n\n\t\t\t}\n\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tconst point = new Vector2();\n\t\t\tconst control = new Vector2();\n\n\t\t\tconst firstPoint = new Vector2();\n\t\t\tlet isFirstPoint = true;\n\t\t\tlet doSetFirstPoint = false;\n\n\t\t\tconst d = node.getAttribute( 'd' );\n\n\t\t\t// console.log( d );\n\n\t\t\tconst commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( let i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tconst command = commands[ i ];\n\n\t\t\t\tconst type = command.charAt( 0 );\n\t\t\t\tconst data = command.slice( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tlet numbers;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if start point == end point\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if no displacement\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCSSStylesheet( node ) {\n\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\n\n\t\t\tfor ( let i = 0; i < node.sheet.cssRules.length; i ++ ) {\n\n\t\t\t\tconst stylesheet = node.sheet.cssRules[ i ];\n\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\n\n\t\t\t\tconst selectorList = stylesheet.selectorText\n\t\t\t\t\t.split( /,/gm )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let j = 0; j < selectorList.length; j ++ ) {\n\n\t\t\t\t\t// Remove empty rules\n\t\t\t\t\tconst definitions = Object.fromEntries(\n\t\t\t\t\t\tObject.entries( stylesheet.style ).filter( ( [ , v ] ) => v !== '' )\n\t\t\t\t\t);\n\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\n\t\t\t\t\t\tdefinitions\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tif ( rx == 0 || ry == 0 ) {\n\n\t\t\t\t// draw a line if either of the radii == 0\n\t\t\t\tpath.lineTo( end.x, end.y );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1', y1')\n\t\t\tconst dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tconst dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tconst x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tconst y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx', cy')\n\t\t\tlet rxs = rx * rx;\n\t\t\tlet rys = ry * ry;\n\t\t\tconst x1ps = x1p * x1p;\n\t\t\tconst y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tconst cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tconst s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tconst dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tconst pq = ( rxs * rys - dq ) / dq;\n\t\t\tlet q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tconst cxp = q * rx * y1p / ry;\n\t\t\tconst cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\n\t\t\tconst cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tconst cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute θ1 and Δθ\n\t\t\tconst theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tconst delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tconst dot = ux * vx + uy * vy;\n\t\t\tconst len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tlet ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || node.getAttribute( 'ry' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\tconst h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\t// Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n\t\t\t// https://spencermortensen.com/articles/bezier-circle/\n\t\t\tconst bci = 1 - 0.551915024494;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\t// top left\n\t\t\tpath.moveTo( x + rx, y );\n\n\t\t\t// top right\n\t\t\tpath.lineTo( x + w - rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry * bci,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom right\n\t\t\tpath.lineTo( x + w, y + h - ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx + w - rx,\n\t\t\t\t\ty + h\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom left\n\t\t\tpath.lineTo( x + rx, y + h );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// back to top left\n\t\t\tpath.lineTo( x, y + ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + ry * bci, x + rx * bci, y, x + rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tconst x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );\n\t\t\tconst y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );\n\t\t\tconst x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );\n\t\t\tconst y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tlet stylesheetStyles = {};\n\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\n\n\t\t\t\tconst classSelectors = node.getAttribute( 'class' )\n\t\t\t\t\t.split( /\\s/ )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let i = 0; i < classSelectors.length; i ++ ) {\n\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\n\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\n\n\t\t\t}\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'fill-rule', 'fillRule' );\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\t\t\taddStyle( 'visibility', 'visibility' );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\t// from https://github.com/ppvg/svg-numbers (MIT License)\n\n\t\tfunction parseFloats( input, flags, stride ) {\n\n\t\t\tif ( typeof input !== 'string' ) {\n\n\t\t\t\tthrow new TypeError( 'Invalid input: ' + typeof input );\n\n\t\t\t}\n\n\t\t\t// Character groups\n\t\t\tconst RE = {\n\t\t\t\tSEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n\t\t\t\tWHITESPACE: /[ \\t\\r\\n]/,\n\t\t\t\tDIGIT: /[\\d]/,\n\t\t\t\tSIGN: /[-+]/,\n\t\t\t\tPOINT: /\\./,\n\t\t\t\tCOMMA: /,/,\n\t\t\t\tEXP: /e/i,\n\t\t\t\tFLAGS: /[01]/\n\t\t\t};\n\n\t\t\t// States\n\t\t\tconst SEP = 0;\n\t\t\tconst INT = 1;\n\t\t\tconst FLOAT = 2;\n\t\t\tconst EXP = 3;\n\n\t\t\tlet state = SEP;\n\t\t\tlet seenComma = true;\n\t\t\tlet number = '', exponent = '';\n\t\t\tconst result = [];\n\n\t\t\tfunction throwSyntaxError( current, i, partial ) {\n\n\t\t\t\tconst error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' );\n\t\t\t\terror.partial = partial;\n\t\t\t\tthrow error;\n\n\t\t\t}\n\n\t\t\tfunction newNumber() {\n\n\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\tif ( exponent === '' ) result.push( Number( number ) );\n\t\t\t\t\telse result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tnumber = '';\n\t\t\t\texponent = '';\n\n\t\t\t}\n\n\t\t\tlet current;\n\t\t\tconst length = input.length;\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tcurrent = input[ i ];\n\n\t\t\t\t// check for flags\n\t\t\t\tif ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {\n\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// parse until next number\n\t\t\t\tif ( state === SEP ) {\n\n\t\t\t\t\t// eat whitespace\n\t\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// start new number\n\t\t\t\t\tif ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tstate = INT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double commas (e.g. \"1, , 2\")\n\t\t\t\t\tif ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\t\tif ( seenComma ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tseenComma = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse integer part\n\t\t\t\tif ( state === INT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\t\t\t\t\tif ( RE.SIGN.test( current )\n\t\t\t\t\t\t\t&& number.length === 1\n\t\t\t\t\t\t\t&& RE.SIGN.test( number[ 0 ] ) ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse decimal part\n\t\t\t\tif ( state === FLOAT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double decimal points (e.g. \"1..2\")\n\t\t\t\t\tif ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse exponent part\n\t\t\t\tif ( state === EXP ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tif ( exponent === '' ) {\n\n\t\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// end of number\n\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = false;\n\n\t\t\t\t} else if ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = true;\n\n\t\t\t\t} else if ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else if ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add the last number found (if any)\n\t\t\tnewNumber();\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// Units\n\n\t\tconst units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\tconst unitConversion = {\n\n\t\t\t'mm': {\n\t\t\t\t'mm': 1,\n\t\t\t\t'cm': 0.1,\n\t\t\t\t'in': 1 / 25.4,\n\t\t\t\t'pt': 72 / 25.4,\n\t\t\t\t'pc': 6 / 25.4,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'cm': {\n\t\t\t\t'mm': 10,\n\t\t\t\t'cm': 1,\n\t\t\t\t'in': 1 / 2.54,\n\t\t\t\t'pt': 72 / 2.54,\n\t\t\t\t'pc': 6 / 2.54,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'in': {\n\t\t\t\t'mm': 25.4,\n\t\t\t\t'cm': 2.54,\n\t\t\t\t'in': 1,\n\t\t\t\t'pt': 72,\n\t\t\t\t'pc': 6,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pt': {\n\t\t\t\t'mm': 25.4 / 72,\n\t\t\t\t'cm': 2.54 / 72,\n\t\t\t\t'in': 1 / 72,\n\t\t\t\t'pt': 1,\n\t\t\t\t'pc': 6 / 72,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pc': {\n\t\t\t\t'mm': 25.4 / 6,\n\t\t\t\t'cm': 2.54 / 6,\n\t\t\t\t'in': 1 / 6,\n\t\t\t\t'pt': 72 / 6,\n\t\t\t\t'pc': 1,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'px': {\n\t\t\t\t'px': 1\n\t\t\t}\n\n\t\t};\n\n\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\tlet theUnit = 'px';\n\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\tfor ( let i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\tconst u = units[ i ];\n\n\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet scale = undefined;\n\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\n\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t} else {\n\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn scale * parseFloat( string );\n\n\t\t}\n\n\t\t// Transforms\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tconst transform = new Matrix3();\n\t\t\tconst currentTransform = tempTransform0;\n\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\n\n\t\t\t\tconst tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\n\t\t\t\tconst ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\n\n\t\t\t\ttransform.translate( tx, ty );\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\tconst transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tconst transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tconst openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tconst closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tconst transformType = transformText.slice( 0, openParPos );\n\n\t\t\t\t\t\tconst array = parseFloats( transformText.slice( openParPos + 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase 'translate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet ty = 0;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'rotate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tlet angle = 0;\n\t\t\t\t\t\t\t\t\tlet cx = 0;\n\t\t\t\t\t\t\t\t\tlet cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'scale':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewX':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewY':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'matrix':\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tconst isRotated = isTransformRotated( m );\n\n\t\t\tconst subPaths = path.subPaths;\n\n\t\t\tfor ( let i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tconst subPath = subPaths[ i ];\n\t\t\t\tconst curves = subPath.curves;\n\n\t\t\t\tfor ( let j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tconst curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformRotated( m ) {\n\n\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t//\n\n\t\tconst paths = [];\n\t\tconst stylesheets = {};\n\n\t\tconst transformStack = [];\n\n\t\tconst tempTransform0 = new Matrix3();\n\t\tconst tempTransform1 = new Matrix3();\n\t\tconst tempTransform2 = new Matrix3();\n\t\tconst tempTransform3 = new Matrix3();\n\t\tconst tempV2 = new Vector2();\n\t\tconst tempV3 = new Vector3();\n\n\t\tconst currentTransform = new Matrix3();\n\n\t\tconst xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tconst data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\t\treturn data;\n\n\t}\n\n\tstatic createShapes( shapePath ) {\n\n\t\t// Param shapePath: a shapepath as returned by the parse function of this class\n\t\t// Returns Shape object\n\n\t\tconst BIGNUMBER = 999999999;\n\n\t\tconst IntersectionLocationType = {\n\t\t\tORIGIN: 0,\n\t\t\tDESTINATION: 1,\n\t\t\tBETWEEN: 2,\n\t\t\tLEFT: 3,\n\t\t\tRIGHT: 4,\n\t\t\tBEHIND: 5,\n\t\t\tBEYOND: 6\n\t\t};\n\n\t\tconst classifyResult = {\n\t\t\tloc: IntersectionLocationType.ORIGIN,\n\t\t\tt: 0\n\t\t};\n\n\t\tfunction findEdgeIntersection( a0, a1, b0, b1 ) {\n\n\t\t\tconst x1 = a0.x;\n\t\t\tconst x2 = a1.x;\n\t\t\tconst x3 = b0.x;\n\t\t\tconst x4 = b1.x;\n\t\t\tconst y1 = a0.y;\n\t\t\tconst y2 = a1.y;\n\t\t\tconst y3 = b0.y;\n\t\t\tconst y4 = b1.y;\n\t\t\tconst nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );\n\t\t\tconst nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );\n\t\t\tconst denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );\n\t\t\tconst t1 = nom1 / denom;\n\t\t\tconst t2 = nom2 / denom;\n\n\t\t\tif ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {\n\n\t\t\t\t//1. lines are parallel or edges don't intersect\n\n\t\t\t\treturn null;\n\n\t\t\t} else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {\n\n\t\t\t\t//2. lines are colinear\n\n\t\t\t\t//check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\t\t\t\t\t//find position of this endpoints relatively to edge1\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t} else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {\n\n\t\t\t\t\t\tconst x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\tconst y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\treturn { x: x, y: y, t: classifyResult.t, };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t} else {\n\n\t\t\t\t//3. edges intersect\n\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\tconst y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\treturn { x: x, y: y, t: t1 };\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction classifyPoint( p, edgeStart, edgeEnd ) {\n\n\t\t\tconst ax = edgeEnd.x - edgeStart.x;\n\t\t\tconst ay = edgeEnd.y - edgeStart.y;\n\t\t\tconst bx = p.x - edgeStart.x;\n\t\t\tconst by = p.y - edgeStart.y;\n\t\t\tconst sa = ax * by - bx * ay;\n\n\t\t\tif ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.ORIGIN;\n\t\t\t\tclassifyResult.t = 0;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.DESTINATION;\n\t\t\t\tclassifyResult.t = 1;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa < - Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.LEFT;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa > Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.RIGHT;\n\t\t\t\treturn;\n\n\n\t\t\t}\n\n\t\t\tif ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEHIND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEYOND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet t;\n\n\t\t\tif ( ax !== 0 ) {\n\n\t\t\t\tt = bx / ax;\n\n\t\t\t} else {\n\n\t\t\t\tt = by / ay;\n\n\t\t\t}\n\n\t\t\tclassifyResult.loc = IntersectionLocationType.BETWEEN;\n\t\t\tclassifyResult.t = t;\n\n\t\t}\n\n\t\tfunction getIntersections( path1, path2 ) {\n\n\t\t\tconst intersectionsRaw = [];\n\t\t\tconst intersections = [];\n\n\t\t\tfor ( let index = 1; index < path1.length; index ++ ) {\n\n\t\t\t\tconst path1EdgeStart = path1[ index - 1 ];\n\t\t\t\tconst path1EdgeEnd = path1[ index ];\n\n\t\t\t\tfor ( let index2 = 1; index2 < path2.length; index2 ++ ) {\n\n\t\t\t\t\tconst path2EdgeStart = path2[ index2 - 1 ];\n\t\t\t\t\tconst path2EdgeEnd = path2[ index2 ];\n\n\t\t\t\t\tconst intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );\n\n\t\t\t\t\tif ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {\n\n\t\t\t\t\t\tintersectionsRaw.push( intersection );\n\t\t\t\t\t\tintersections.push( new Vector2( intersection.x, intersection.y ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn intersections;\n\n\t\t}\n\n\t\tfunction getScanlineIntersections( scanline, boundingBox, paths ) {\n\n\t\t\tconst center = new Vector2();\n\t\t\tboundingBox.getCenter( center );\n\n\t\t\tconst allIntersections = [];\n\n\t\t\tpaths.forEach( path => {\n\n\t\t\t\t// check if the center of the bounding box is in the bounding box of the paths.\n\t\t\t\t// this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n\t\t\t\t// if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n\t\t\t\tif ( path.boundingBox.containsPoint( center ) ) {\n\n\t\t\t\t\tconst intersections = getIntersections( scanline, path.points );\n\n\t\t\t\t\tintersections.forEach( p => {\n\n\t\t\t\t\t\tallIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tallIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\treturn allIntersections;\n\n\t\t}\n\n\t\tfunction isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {\n\n\t\t\tif ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {\n\n\t\t\t\t_fillRule = 'nonzero';\n\n\t\t\t}\n\n\t\t\tconst centerBoundingBox = new Vector2();\n\t\t\tsimplePath.boundingBox.getCenter( centerBoundingBox );\n\n\t\t\tconst scanline = [ new Vector2( scanlineMinX, centerBoundingBox.y ), new Vector2( scanlineMaxX, centerBoundingBox.y ) ];\n\n\t\t\tconst scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );\n\n\t\t\tscanlineIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\tconst baseIntersections = [];\n\t\t\tconst otherIntersections = [];\n\n\t\t\tscanlineIntersections.forEach( i => {\n\n\t\t\t\tif ( i.identifier === simplePath.identifier ) {\n\n\t\t\t\t\tbaseIntersections.push( i );\n\n\t\t\t\t} else {\n\n\t\t\t\t\totherIntersections.push( i );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tconst firstXOfPath = baseIntersections[ 0 ].point.x;\n\n\t\t\t// build up the path hierarchy\n\t\t\tconst stack = [];\n\t\t\tlet i = 0;\n\n\t\t\twhile ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {\n\n\t\t\t\tif ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {\n\n\t\t\t\t\tstack.pop();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( otherIntersections[ i ].identifier );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tstack.push( simplePath.identifier );\n\n\t\t\tif ( _fillRule === 'evenodd' ) {\n\n\t\t\t\tconst isHole = stack.length % 2 === 0 ? true : false;\n\t\t\t\tconst isHoleFor = stack[ stack.length - 2 ];\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else if ( _fillRule === 'nonzero' ) {\n\n\t\t\t\t// check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n\t\t\t\tlet isHole = true;\n\t\t\t\tlet isHoleFor = null;\n\t\t\t\tlet lastCWValue = null;\n\n\t\t\t\tfor ( let i = 0; i < stack.length; i ++ ) {\n\n\t\t\t\t\tconst identifier = stack[ i ];\n\t\t\t\t\tif ( isHole ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = false;\n\t\t\t\t\t\tisHoleFor = identifier;\n\n\t\t\t\t\t} else if ( lastCWValue !== allPaths[ identifier ].isCW ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'fill-rule: \"' + _fillRule + '\" is currently not implemented.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check for self intersecting paths\n\t\t// TODO\n\n\t\t// check intersecting paths\n\t\t// TODO\n\n\t\t// prepare paths for hole detection\n\t\tlet identifier = 0;\n\n\t\tlet scanlineMinX = BIGNUMBER;\n\t\tlet scanlineMaxX = - BIGNUMBER;\n\n\t\tlet simplePaths = shapePath.subPaths.map( p => {\n\n\t\t\tconst points = p.getPoints();\n\t\t\tlet maxY = - BIGNUMBER;\n\t\t\tlet minY = BIGNUMBER;\n\t\t\tlet maxX = - BIGNUMBER;\n\t\t\tlet minX = BIGNUMBER;\n\n\t      \t//points.forEach(p => p.y *= -1);\n\n\t\t\tfor ( let i = 0; i < points.length; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\n\t\t\t\tif ( p.y > maxY ) {\n\n\t\t\t\t\tmaxY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.y < minY ) {\n\n\t\t\t\t\tminY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x > maxX ) {\n\n\t\t\t\t\tmaxX = p.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x < minX ) {\n\n\t\t\t\t\tminX = p.x;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\t\t\tif ( scanlineMaxX <= maxX ) {\n\n\t\t\t\tscanlineMaxX = maxX + 1;\n\n\t\t\t}\n\n\t\t\tif ( scanlineMinX >= minX ) {\n\n\t\t\t\tscanlineMinX = minX - 1;\n\n\t\t\t}\n\n\t\t\treturn { curves: p.curves, points: points, isCW: ShapeUtils.isClockWise( points ), identifier: identifier ++, boundingBox: new Box2( new Vector2( minX, minY ), new Vector2( maxX, maxY ) ) };\n\n\t\t} );\n\n\t\tsimplePaths = simplePaths.filter( sp => sp.points.length > 1 );\n\n\t\t// check if path is solid or a hole\n\t\tconst isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData?.style.fillRule ) );\n\n\n\t\tconst shapesToReturn = [];\n\t\tsimplePaths.forEach( p => {\n\n\t\t\tconst amIAHole = isAHole[ p.identifier ];\n\n\t\t\tif ( ! amIAHole.isHole ) {\n\n\t\t\t\tconst shape = new Shape();\n\t\t\t\tshape.curves = p.curves;\n\t\t\t\tconst holes = isAHole.filter( h => h.isHole && h.for === p.identifier );\n\t\t\t\tholes.forEach( h => {\n\n\t\t\t\t\tconst hole = simplePaths[ h.identifier ];\n\t\t\t\t\tconst path = new Path();\n\t\t\t\t\tpath.curves = hole.curves;\n\t\t\t\t\tshape.holes.push( path );\n\n\t\t\t\t} );\n\t\t\t\tshapesToReturn.push( shape );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn shapesToReturn;\n\n\t}\n\n\tstatic getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t\t// Param width: Stroke width\n\t\t// Param color: As returned by THREE.Color.getStyle()\n\t\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t\t// Returns style object\n\n\t\twidth = width !== undefined ? width : 1;\n\t\tcolor = color !== undefined ? color : '#000';\n\t\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\t\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\t\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\t\treturn {\n\t\t\tstrokeColor: color,\n\t\t\tstrokeWidth: width,\n\t\t\tstrokeLineJoin: lineJoin,\n\t\t\tstrokeLineCap: lineCap,\n\t\t\tstrokeMiterLimit: miterLimit\n\t\t};\n\n\t}\n\n\tstatic pointsToStroke( points, style, arcDivisions, minDistance ) {\n\n\t\t// Generates a stroke with some witdh around the given path.\n\t\t// The path can be open or closed (last point equals to first point)\n\t\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\treturn geometry;\n\n\t}\n\n\tstatic pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tconst tempV2_1 = new Vector2();\n\t\tconst tempV2_2 = new Vector2();\n\t\tconst tempV2_3 = new Vector2();\n\t\tconst tempV2_4 = new Vector2();\n\t\tconst tempV2_5 = new Vector2();\n\t\tconst tempV2_6 = new Vector2();\n\t\tconst tempV2_7 = new Vector2();\n\t\tconst lastPointL = new Vector2();\n\t\tconst lastPointR = new Vector2();\n\t\tconst point0L = new Vector2();\n\t\tconst point0R = new Vector2();\n\t\tconst currentPointL = new Vector2();\n\t\tconst currentPointR = new Vector2();\n\t\tconst nextPointL = new Vector2();\n\t\tconst nextPointR = new Vector2();\n\t\tconst innerPoint = new Vector2();\n\t\tconst outerPoint = new Vector2();\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tconst numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tconst isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tlet currentPoint;\n\t\tlet previousPoint = points[ 0 ];\n\t\tlet nextPoint;\n\n\t\tconst strokeWidth2 = style.strokeWidth / 2;\n\n\t\tconst deltaU = 1 / ( numPoints - 1 );\n\t\tlet u0 = 0, u1;\n\n\t\tlet innerSideModified;\n\t\tlet joinIsOnLeftSide;\n\t\tlet isMiter;\n\t\tlet initialJoinIsOnLeftSide = false;\n\n\t\tlet numVertices = 0;\n\t\tlet currentCoordinate = vertexOffset * 3;\n\t\tlet currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tconst normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tu1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tconst dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot > Number.EPSILON ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tconst miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tconst miterLength2 = tempV2_5.length();\n\t\t\t\t\tconst segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tconst segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconst miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tlet lastOuter = outerPoint;\n\t\t\tlet lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tlet angle = Math.PI;\n\t\t\tconst dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tconst vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'butt':\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Nothing to do here\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tlet dupPoints = false;\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tconst newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t}\n\n\n}\n\nexport { SVGLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
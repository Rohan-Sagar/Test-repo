{"ast":null,"code":"import { BinaryWriter } from '../io/binarywriter.js';\nimport { Utf8StringToArrayBuffer } from '../io/bufferutils.js';\nimport { FileFormat, GetFileExtension, GetFileName } from '../io/fileutils.js';\nimport { RGBColor, SRGBToLinear } from '../model/color.js';\nimport { MaterialType } from '../model/material.js';\nimport { ConvertMeshToMeshBuffer } from '../model/meshbuffer.js';\nimport { ExportedFile, ExporterBase } from './exporterbase.js';\nexport class ExporterGltf extends ExporterBase {\n  constructor() {\n    super();\n    this.components = {\n      index: {\n        type: 5125,\n        // unsigned int 32\n        size: 4\n      },\n      number: {\n        type: 5126,\n        // float 32\n        size: 4\n      }\n    };\n  }\n\n  CanExport(format, extension) {\n    return format === FileFormat.Text && extension === 'gltf' || format === FileFormat.Binary && extension === 'glb';\n  }\n\n  ExportContent(exporterModel, format, files, onFinish) {\n    if (format === FileFormat.Text) {\n      this.ExportAsciiContent(exporterModel, files);\n    } else if (format === FileFormat.Binary) {\n      this.ExportBinaryContent(exporterModel, files);\n    }\n\n    onFinish();\n  }\n\n  ExportAsciiContent(exporterModel, files) {\n    let gltfFile = new ExportedFile('model.gltf');\n    let binFile = new ExportedFile('model.bin');\n    files.push(gltfFile);\n    files.push(binFile);\n    let meshDataArr = this.GetMeshData(exporterModel);\n    let mainBuffer = this.GetMainBuffer(meshDataArr);\n    let mainJson = this.GetMainJson(meshDataArr);\n    mainJson.buffers.push({\n      uri: binFile.GetName(),\n      byteLength: mainBuffer.byteLength\n    });\n    let fileNameToIndex = new Map();\n    this.ExportMaterials(exporterModel, mainJson, texture => {\n      let fileName = GetFileName(texture.name);\n\n      if (fileNameToIndex.has(fileName)) {\n        return fileNameToIndex.get(fileName);\n      } else {\n        let textureFile = new ExportedFile(fileName);\n        textureFile.SetBufferContent(texture.buffer);\n        files.push(textureFile);\n        let textureIndex = mainJson.textures.length;\n        fileNameToIndex.set(fileName, textureIndex);\n        mainJson.images.push({\n          uri: fileName\n        });\n        mainJson.textures.push({\n          source: textureIndex\n        });\n        return textureIndex;\n      }\n    });\n    gltfFile.SetTextContent(JSON.stringify(mainJson, null, 4));\n    binFile.SetBufferContent(mainBuffer);\n  }\n\n  ExportBinaryContent(exporterModel, files) {\n    function AlignToBoundary(size) {\n      let remainder = size % 4;\n\n      if (remainder === 0) {\n        return size;\n      }\n\n      return size + (4 - remainder);\n    }\n\n    function WriteCharacters(writer, char, count) {\n      for (let i = 0; i < count; i++) {\n        writer.WriteUnsignedCharacter8(char);\n      }\n    }\n\n    let glbFile = new ExportedFile('model.glb');\n    files.push(glbFile);\n    let meshDataArr = this.GetMeshData(exporterModel);\n    let mainBuffer = this.GetMainBuffer(meshDataArr);\n    let mainJson = this.GetMainJson(meshDataArr);\n    let textureBuffers = [];\n    let textureOffset = mainBuffer.byteLength;\n    let fileNameToIndex = new Map();\n    this.ExportMaterials(exporterModel, mainJson, texture => {\n      let fileName = GetFileName(texture.name);\n      let extension = GetFileExtension(texture.name);\n\n      if (fileNameToIndex.has(fileName)) {\n        return fileNameToIndex.get(fileName);\n      } else {\n        let bufferViewIndex = mainJson.bufferViews.length;\n        let textureIndex = mainJson.textures.length;\n        fileNameToIndex.set(fileName, textureIndex);\n        let textureBuffer = texture.buffer;\n        textureBuffers.push(textureBuffer);\n        mainJson.bufferViews.push({\n          buffer: 0,\n          byteOffset: textureOffset,\n          byteLength: textureBuffer.byteLength\n        });\n        textureOffset += textureBuffer.byteLength;\n        mainJson.images.push({\n          bufferView: bufferViewIndex,\n          mimeType: 'image/' + extension\n        });\n        mainJson.textures.push({\n          source: textureIndex\n        });\n        return textureIndex;\n      }\n    });\n    let mainBinaryBufferLength = mainBuffer.byteLength;\n\n    for (let i = 0; i < textureBuffers.length; i++) {\n      let textureBuffer = textureBuffers[i];\n      mainBinaryBufferLength += textureBuffer.byteLength;\n    }\n\n    let mainBinaryBufferAlignedLength = AlignToBoundary(mainBinaryBufferLength);\n    mainJson.buffers.push({\n      byteLength: mainBinaryBufferAlignedLength\n    });\n    let mainJsonString = JSON.stringify(mainJson);\n    let mainJsonBuffer = Utf8StringToArrayBuffer(mainJsonString);\n    let mainJsonBufferLength = mainJsonBuffer.byteLength;\n    let mainJsonBufferAlignedLength = AlignToBoundary(mainJsonBufferLength);\n    let glbSize = 12 + 8 + mainJsonBufferAlignedLength + 8 + mainBinaryBufferAlignedLength;\n    let glbWriter = new BinaryWriter(glbSize, true);\n    glbWriter.WriteUnsignedInteger32(0x46546C67);\n    glbWriter.WriteUnsignedInteger32(2);\n    glbWriter.WriteUnsignedInteger32(glbSize);\n    glbWriter.WriteUnsignedInteger32(mainJsonBufferAlignedLength);\n    glbWriter.WriteUnsignedInteger32(0x4E4F534A);\n    glbWriter.WriteArrayBuffer(mainJsonBuffer);\n    WriteCharacters(glbWriter, 32, mainJsonBufferAlignedLength - mainJsonBufferLength);\n    glbWriter.WriteUnsignedInteger32(mainBinaryBufferAlignedLength);\n    glbWriter.WriteUnsignedInteger32(0x004E4942);\n    glbWriter.WriteArrayBuffer(mainBuffer);\n\n    for (let i = 0; i < textureBuffers.length; i++) {\n      let textureBuffer = textureBuffers[i];\n      glbWriter.WriteArrayBuffer(textureBuffer);\n    }\n\n    WriteCharacters(glbWriter, 0, mainBinaryBufferAlignedLength - mainBinaryBufferLength);\n    glbFile.SetBufferContent(glbWriter.GetBuffer());\n  }\n\n  GetMeshData(exporterModel) {\n    let meshDataArr = [];\n    exporterModel.EnumerateTransformedMeshes(mesh => {\n      let buffer = ConvertMeshToMeshBuffer(mesh);\n      meshDataArr.push({\n        name: mesh.GetName(),\n        buffer: buffer,\n        offsets: [],\n        sizes: []\n      });\n    });\n    return meshDataArr;\n  }\n\n  GetMainBuffer(meshDataArr) {\n    let mainBufferSize = 0;\n\n    for (let meshIndex = 0; meshIndex < meshDataArr.length; meshIndex++) {\n      let meshData = meshDataArr[meshIndex];\n      mainBufferSize += meshData.buffer.GetByteLength(this.components.index.size, this.components.number.size);\n    }\n\n    let writer = new BinaryWriter(mainBufferSize, true);\n\n    for (let meshIndex = 0; meshIndex < meshDataArr.length; meshIndex++) {\n      let meshData = meshDataArr[meshIndex];\n\n      for (let primitiveIndex = 0; primitiveIndex < meshData.buffer.PrimitiveCount(); primitiveIndex++) {\n        let primitive = meshData.buffer.GetPrimitive(primitiveIndex);\n        let offset = writer.GetPosition();\n\n        for (let i = 0; i < primitive.indices.length; i++) {\n          writer.WriteUnsignedInteger32(primitive.indices[i]);\n        }\n\n        for (let i = 0; i < primitive.vertices.length; i++) {\n          writer.WriteFloat32(primitive.vertices[i]);\n        }\n\n        for (let i = 0; i < primitive.colors.length; i++) {\n          writer.WriteFloat32(SRGBToLinear(primitive.colors[i]));\n        }\n\n        for (let i = 0; i < primitive.normals.length; i++) {\n          writer.WriteFloat32(primitive.normals[i]);\n        }\n\n        for (let i = 0; i < primitive.uvs.length; i++) {\n          let texCoord = primitive.uvs[i];\n\n          if (i % 2 === 1) {\n            texCoord *= -1.0;\n          }\n\n          writer.WriteFloat32(texCoord);\n        }\n\n        meshData.offsets.push(offset);\n        meshData.sizes.push(writer.GetPosition() - offset);\n      }\n    }\n\n    return writer.GetBuffer();\n  }\n\n  GetMainJson(meshDataArr) {\n    class BufferViewCreator {\n      constructor(mainJson, byteOffset) {\n        this.mainJson = mainJson;\n        this.byteOffset = byteOffset;\n      }\n\n      AddBufferView(byteLength) {\n        this.mainJson.bufferViews.push({\n          buffer: 0,\n          byteOffset: this.byteOffset,\n          byteLength: byteLength\n        });\n        this.byteOffset += byteLength;\n        return this.mainJson.bufferViews.length - 1;\n      }\n\n    }\n\n    let mainJson = {\n      asset: {\n        generator: 'https://3dviewer.net',\n        version: '2.0'\n      },\n      scene: 0,\n      scenes: [{\n        nodes: []\n      }],\n      nodes: [],\n      materials: [],\n      meshes: [],\n      buffers: [],\n      bufferViews: [],\n      accessors: []\n    };\n\n    for (let meshIndex = 0; meshIndex < meshDataArr.length; meshIndex++) {\n      let meshData = meshDataArr[meshIndex];\n      mainJson.scenes[0].nodes.push(meshIndex);\n      mainJson.nodes.push({\n        mesh: meshIndex\n      });\n      let jsonMesh = {\n        name: this.GetExportedMeshName(meshData.name),\n        primitives: []\n      };\n      let primitives = meshData.buffer.primitives;\n\n      for (let primitiveIndex = 0; primitiveIndex < primitives.length; primitiveIndex++) {\n        let primitive = primitives[primitiveIndex];\n        let bufferViewCreator = new BufferViewCreator(mainJson, meshData.offsets[primitiveIndex]);\n        let indicesBufferView = bufferViewCreator.AddBufferView(primitive.indices.length * this.components.index.size);\n        let verticesBufferView = bufferViewCreator.AddBufferView(primitive.vertices.length * this.components.number.size);\n        let colorsBufferView = null;\n\n        if (primitive.colors.length > 0) {\n          colorsBufferView = bufferViewCreator.AddBufferView(primitive.colors.length * this.components.number.size);\n        }\n\n        let normalsBufferView = bufferViewCreator.AddBufferView(primitive.normals.length * this.components.number.size);\n        let uvsBufferView = null;\n\n        if (primitive.uvs.length > 0) {\n          uvsBufferView = bufferViewCreator.AddBufferView(primitive.uvs.length * this.components.number.size);\n        }\n\n        let jsonPrimitive = {\n          attributes: {},\n          mode: 4,\n          material: primitive.material\n        };\n        let bounds = primitive.GetBounds();\n        mainJson.accessors.push({\n          bufferView: indicesBufferView,\n          byteOffset: 0,\n          componentType: this.components.index.type,\n          count: primitive.indices.length,\n          type: 'SCALAR'\n        });\n        jsonPrimitive.indices = mainJson.accessors.length - 1;\n        mainJson.accessors.push({\n          bufferView: verticesBufferView,\n          byteOffset: 0,\n          componentType: this.components.number.type,\n          count: primitive.vertices.length / 3,\n          min: bounds.min,\n          max: bounds.max,\n          type: 'VEC3'\n        });\n        jsonPrimitive.attributes.POSITION = mainJson.accessors.length - 1;\n\n        if (colorsBufferView !== null) {\n          mainJson.accessors.push({\n            bufferView: colorsBufferView,\n            byteOffset: 0,\n            componentType: this.components.number.type,\n            count: primitive.colors.length / 3,\n            type: 'VEC3'\n          });\n          jsonPrimitive.attributes.COLOR_0 = mainJson.accessors.length - 1;\n        }\n\n        mainJson.accessors.push({\n          bufferView: normalsBufferView,\n          byteOffset: 0,\n          componentType: this.components.number.type,\n          count: primitive.normals.length / 3,\n          type: 'VEC3'\n        });\n        jsonPrimitive.attributes.NORMAL = mainJson.accessors.length - 1;\n\n        if (uvsBufferView !== null) {\n          mainJson.accessors.push({\n            bufferView: uvsBufferView,\n            byteOffset: 0,\n            componentType: this.components.number.type,\n            count: primitive.uvs.length / 2,\n            type: 'VEC2'\n          });\n          jsonPrimitive.attributes.TEXCOORD_0 = mainJson.accessors.length - 1;\n        }\n\n        jsonMesh.primitives.push(jsonPrimitive);\n      }\n\n      mainJson.meshes.push(jsonMesh);\n    }\n\n    return mainJson;\n  }\n\n  ExportMaterials(exporterModel, mainJson, addTexture) {\n    function ExportMaterial(obj, mainJson, material, addTexture) {\n      function ColorToRGBA(color, opacity) {\n        return [SRGBToLinear(color.r / 255.0), SRGBToLinear(color.g / 255.0), SRGBToLinear(color.b / 255.0), opacity];\n      }\n\n      function ColorToRGB(color) {\n        return [SRGBToLinear(color.r / 255.0), SRGBToLinear(color.g / 255.0), SRGBToLinear(color.b / 255.0)];\n      }\n\n      function GetTextureParams(mainJson, texture, addTexture) {\n        if (texture === null || !texture.IsValid()) {\n          return null;\n        }\n\n        if (mainJson.images === undefined) {\n          mainJson.images = [];\n        }\n\n        if (mainJson.textures === undefined) {\n          mainJson.textures = [];\n        }\n\n        let textureIndex = addTexture(texture);\n        let textureParams = {\n          index: textureIndex\n        };\n\n        if (texture.HasTransformation()) {\n          let extensionName = 'KHR_texture_transform';\n\n          if (mainJson.extensionsUsed === undefined) {\n            mainJson.extensionsUsed = [];\n          }\n\n          if (mainJson.extensionsUsed.indexOf(extensionName) === -1) {\n            mainJson.extensionsUsed.push(extensionName);\n          }\n\n          textureParams.extensions = {\n            KHR_texture_transform: {\n              offset: [texture.offset.x, -texture.offset.y],\n              scale: [texture.scale.x, texture.scale.y],\n              rotation: -texture.rotation\n            }\n          };\n        }\n\n        return textureParams;\n      }\n\n      let jsonMaterial = {\n        name: obj.GetExportedMaterialName(material.name),\n        pbrMetallicRoughness: {\n          baseColorFactor: ColorToRGBA(material.color, material.opacity)\n        },\n        emissiveFactor: ColorToRGB(material.emissive),\n        doubleSided: true,\n        alphaMode: 'OPAQUE'\n      };\n\n      if (material.transparent) {\n        // TODO: mask, alphaCutoff?\n        jsonMaterial.alphaMode = 'BLEND';\n      }\n\n      let baseColorTexture = GetTextureParams(mainJson, material.diffuseMap, addTexture);\n\n      if (baseColorTexture !== null) {\n        if (!material.multiplyDiffuseMap) {\n          jsonMaterial.pbrMetallicRoughness.baseColorFactor = ColorToRGBA(new RGBColor(255, 255, 255), material.opacity);\n        }\n\n        jsonMaterial.pbrMetallicRoughness.baseColorTexture = baseColorTexture;\n      }\n\n      if (material.type === MaterialType.Physical) {\n        let metallicTexture = GetTextureParams(mainJson, material.metalnessMap, addTexture);\n\n        if (metallicTexture !== null) {\n          jsonMaterial.pbrMetallicRoughness.metallicRoughnessTexture = metallicTexture;\n        } else {\n          jsonMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;\n          jsonMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;\n        }\n      }\n\n      let normalTexture = GetTextureParams(mainJson, material.normalMap, addTexture);\n\n      if (normalTexture !== null) {\n        jsonMaterial.normalTexture = normalTexture;\n      }\n\n      let emissiveTexture = GetTextureParams(mainJson, material.emissiveMap, addTexture);\n\n      if (emissiveTexture !== null) {\n        jsonMaterial.emissiveTexture = emissiveTexture;\n      }\n\n      mainJson.materials.push(jsonMaterial);\n    }\n\n    for (let materialIndex = 0; materialIndex < exporterModel.MaterialCount(); materialIndex++) {\n      let material = exporterModel.GetMaterial(materialIndex);\n      ExportMaterial(this, mainJson, material, addTexture);\n    }\n  }\n\n}","map":{"version":3,"names":["BinaryWriter","Utf8StringToArrayBuffer","FileFormat","GetFileExtension","GetFileName","RGBColor","SRGBToLinear","MaterialType","ConvertMeshToMeshBuffer","ExportedFile","ExporterBase","ExporterGltf","constructor","components","index","type","size","number","CanExport","format","extension","Text","Binary","ExportContent","exporterModel","files","onFinish","ExportAsciiContent","ExportBinaryContent","gltfFile","binFile","push","meshDataArr","GetMeshData","mainBuffer","GetMainBuffer","mainJson","GetMainJson","buffers","uri","GetName","byteLength","fileNameToIndex","Map","ExportMaterials","texture","fileName","name","has","get","textureFile","SetBufferContent","buffer","textureIndex","textures","length","set","images","source","SetTextContent","JSON","stringify","AlignToBoundary","remainder","WriteCharacters","writer","char","count","i","WriteUnsignedCharacter8","glbFile","textureBuffers","textureOffset","bufferViewIndex","bufferViews","textureBuffer","byteOffset","bufferView","mimeType","mainBinaryBufferLength","mainBinaryBufferAlignedLength","mainJsonString","mainJsonBuffer","mainJsonBufferLength","mainJsonBufferAlignedLength","glbSize","glbWriter","WriteUnsignedInteger32","WriteArrayBuffer","GetBuffer","EnumerateTransformedMeshes","mesh","offsets","sizes","mainBufferSize","meshIndex","meshData","GetByteLength","primitiveIndex","PrimitiveCount","primitive","GetPrimitive","offset","GetPosition","indices","vertices","WriteFloat32","colors","normals","uvs","texCoord","BufferViewCreator","AddBufferView","asset","generator","version","scene","scenes","nodes","materials","meshes","accessors","jsonMesh","GetExportedMeshName","primitives","bufferViewCreator","indicesBufferView","verticesBufferView","colorsBufferView","normalsBufferView","uvsBufferView","jsonPrimitive","attributes","mode","material","bounds","GetBounds","componentType","min","max","POSITION","COLOR_0","NORMAL","TEXCOORD_0","addTexture","ExportMaterial","obj","ColorToRGBA","color","opacity","r","g","b","ColorToRGB","GetTextureParams","IsValid","undefined","textureParams","HasTransformation","extensionName","extensionsUsed","indexOf","extensions","KHR_texture_transform","x","y","scale","rotation","jsonMaterial","GetExportedMaterialName","pbrMetallicRoughness","baseColorFactor","emissiveFactor","emissive","doubleSided","alphaMode","transparent","baseColorTexture","diffuseMap","multiplyDiffuseMap","Physical","metallicTexture","metalnessMap","metallicRoughnessTexture","metallicFactor","metalness","roughnessFactor","roughness","normalTexture","normalMap","emissiveTexture","emissiveMap","materialIndex","MaterialCount","GetMaterial"],"sources":["/Users/rohansagar/Desktop/node+react/client/node-react-3d/node_modules/online-3d-viewer/source/engine/export/exportergltf.js"],"sourcesContent":["import { BinaryWriter } from '../io/binarywriter.js';\r\nimport { Utf8StringToArrayBuffer } from '../io/bufferutils.js';\r\nimport { FileFormat, GetFileExtension, GetFileName } from '../io/fileutils.js';\r\nimport { RGBColor, SRGBToLinear } from '../model/color.js';\r\nimport { MaterialType } from '../model/material.js';\r\nimport { ConvertMeshToMeshBuffer } from '../model/meshbuffer.js';\r\nimport { ExportedFile, ExporterBase } from './exporterbase.js';\r\n\r\nexport class ExporterGltf extends ExporterBase\r\n{\r\n\tconstructor ()\r\n\t{\r\n\t\tsuper ();\r\n        this.components = {\r\n            index : {\r\n                type : 5125, // unsigned int 32\r\n                size : 4\r\n            },\r\n            number : {\r\n                type : 5126, // float 32\r\n                size : 4\r\n            }\r\n        };\r\n\t}\r\n\r\n    CanExport (format, extension)\r\n    {\r\n        return (format === FileFormat.Text && extension === 'gltf') || (format === FileFormat.Binary && extension === 'glb');\r\n    }\r\n\r\n\tExportContent (exporterModel, format, files, onFinish)\r\n\t{\r\n        if (format === FileFormat.Text) {\r\n            this.ExportAsciiContent (exporterModel, files);\r\n        } else if (format === FileFormat.Binary) {\r\n            this.ExportBinaryContent (exporterModel, files);\r\n        }\r\n        onFinish ();\r\n\t}\r\n\r\n\tExportAsciiContent (exporterModel, files)\r\n\t{\r\n        let gltfFile = new ExportedFile ('model.gltf');\r\n        let binFile = new ExportedFile ('model.bin');\r\n        files.push (gltfFile);\r\n        files.push (binFile);\r\n\r\n        let meshDataArr = this.GetMeshData (exporterModel);\r\n        let mainBuffer = this.GetMainBuffer (meshDataArr);\r\n        let mainJson = this.GetMainJson (meshDataArr);\r\n        mainJson.buffers.push ({\r\n            uri : binFile.GetName (),\r\n            byteLength : mainBuffer.byteLength\r\n        });\r\n\r\n        let fileNameToIndex = new Map ();\r\n        this.ExportMaterials (exporterModel, mainJson, (texture) => {\r\n            let fileName = GetFileName (texture.name);\r\n            if (fileNameToIndex.has (fileName)) {\r\n                return fileNameToIndex.get (fileName);\r\n            } else {\r\n                let textureFile = new ExportedFile (fileName);\r\n                textureFile.SetBufferContent (texture.buffer);\r\n                files.push (textureFile);\r\n\r\n                let textureIndex = mainJson.textures.length;\r\n                fileNameToIndex.set (fileName, textureIndex);\r\n\r\n                mainJson.images.push ({\r\n                    uri : fileName\r\n                });\r\n\r\n                mainJson.textures.push ({\r\n                    source : textureIndex\r\n                });\r\n\r\n                return textureIndex;\r\n            }\r\n        });\r\n\r\n        gltfFile.SetTextContent (JSON.stringify (mainJson, null, 4));\r\n        binFile.SetBufferContent (mainBuffer);\r\n    }\r\n\r\n    ExportBinaryContent (exporterModel, files)\r\n    {\r\n        function AlignToBoundary (size)\r\n        {\r\n            let remainder = size % 4;\r\n            if (remainder === 0) {\r\n                return size;\r\n            }\r\n            return size + (4 - remainder);\r\n        }\r\n\r\n        function WriteCharacters (writer, char, count)\r\n        {\r\n            for (let i = 0; i < count; i++) {\r\n                writer.WriteUnsignedCharacter8 (char);\r\n            }\r\n        }\r\n\r\n        let glbFile = new ExportedFile ('model.glb');\r\n        files.push (glbFile);\r\n\r\n        let meshDataArr = this.GetMeshData (exporterModel);\r\n        let mainBuffer = this.GetMainBuffer (meshDataArr);\r\n        let mainJson = this.GetMainJson (meshDataArr);\r\n\r\n        let textureBuffers = [];\r\n        let textureOffset = mainBuffer.byteLength;\r\n\r\n        let fileNameToIndex = new Map ();\r\n        this.ExportMaterials (exporterModel, mainJson, (texture) => {\r\n            let fileName = GetFileName (texture.name);\r\n            let extension = GetFileExtension (texture.name);\r\n            if (fileNameToIndex.has (fileName)) {\r\n                return fileNameToIndex.get (fileName);\r\n            } else {\r\n                let bufferViewIndex = mainJson.bufferViews.length;\r\n                let textureIndex = mainJson.textures.length;\r\n                fileNameToIndex.set (fileName, textureIndex);\r\n                let textureBuffer = texture.buffer;\r\n                textureBuffers.push (textureBuffer);\r\n                mainJson.bufferViews.push ({\r\n                    buffer : 0,\r\n                    byteOffset : textureOffset,\r\n                    byteLength : textureBuffer.byteLength\r\n                });\r\n                textureOffset += textureBuffer.byteLength;\r\n                mainJson.images.push ({\r\n                    bufferView : bufferViewIndex,\r\n                    mimeType : 'image/' + extension\r\n                });\r\n                mainJson.textures.push ({\r\n                    source : textureIndex\r\n                });\r\n\r\n                return textureIndex;\r\n            }\r\n        });\r\n\r\n        let mainBinaryBufferLength = mainBuffer.byteLength;\r\n        for (let i = 0; i < textureBuffers.length; i++) {\r\n            let textureBuffer = textureBuffers[i];\r\n            mainBinaryBufferLength += textureBuffer.byteLength;\r\n        }\r\n        let mainBinaryBufferAlignedLength = AlignToBoundary (mainBinaryBufferLength);\r\n        mainJson.buffers.push ({\r\n            byteLength : mainBinaryBufferAlignedLength\r\n        });\r\n\r\n        let mainJsonString = JSON.stringify (mainJson);\r\n        let mainJsonBuffer = Utf8StringToArrayBuffer (mainJsonString);\r\n        let mainJsonBufferLength = mainJsonBuffer.byteLength;\r\n        let mainJsonBufferAlignedLength = AlignToBoundary (mainJsonBufferLength);\r\n\r\n        let glbSize = 12 + 8 + mainJsonBufferAlignedLength + 8 + mainBinaryBufferAlignedLength;\r\n        let glbWriter = new BinaryWriter (glbSize, true);\r\n\r\n        glbWriter.WriteUnsignedInteger32 (0x46546C67);\r\n        glbWriter.WriteUnsignedInteger32 (2);\r\n        glbWriter.WriteUnsignedInteger32 (glbSize);\r\n\r\n        glbWriter.WriteUnsignedInteger32 (mainJsonBufferAlignedLength);\r\n        glbWriter.WriteUnsignedInteger32 (0x4E4F534A);\r\n        glbWriter.WriteArrayBuffer (mainJsonBuffer);\r\n        WriteCharacters (glbWriter, 32, mainJsonBufferAlignedLength - mainJsonBufferLength);\r\n\r\n        glbWriter.WriteUnsignedInteger32 (mainBinaryBufferAlignedLength);\r\n        glbWriter.WriteUnsignedInteger32 (0x004E4942);\r\n        glbWriter.WriteArrayBuffer (mainBuffer);\r\n\r\n        for (let i = 0; i < textureBuffers.length; i++) {\r\n            let textureBuffer = textureBuffers[i];\r\n            glbWriter.WriteArrayBuffer (textureBuffer);\r\n        }\r\n        WriteCharacters (glbWriter, 0, mainBinaryBufferAlignedLength - mainBinaryBufferLength);\r\n\r\n        glbFile.SetBufferContent (glbWriter.GetBuffer ());\r\n    }\r\n\r\n    GetMeshData (exporterModel)\r\n    {\r\n        let meshDataArr = [];\r\n\r\n        exporterModel.EnumerateTransformedMeshes ((mesh) => {\r\n            let buffer = ConvertMeshToMeshBuffer (mesh);\r\n            meshDataArr.push ({\r\n                name : mesh.GetName (),\r\n                buffer : buffer,\r\n                offsets : [],\r\n                sizes : []\r\n            });\r\n        });\r\n\r\n        return meshDataArr;\r\n    }\r\n\r\n    GetMainBuffer (meshDataArr)\r\n    {\r\n        let mainBufferSize = 0;\r\n        for (let meshIndex = 0; meshIndex < meshDataArr.length; meshIndex++) {\r\n            let meshData = meshDataArr[meshIndex];\r\n            mainBufferSize += meshData.buffer.GetByteLength (this.components.index.size, this.components.number.size);\r\n        }\r\n\r\n        let writer = new BinaryWriter (mainBufferSize, true);\r\n        for (let meshIndex = 0; meshIndex < meshDataArr.length; meshIndex++) {\r\n            let meshData = meshDataArr[meshIndex];\r\n            for (let primitiveIndex = 0; primitiveIndex < meshData.buffer.PrimitiveCount (); primitiveIndex++) {\r\n                let primitive = meshData.buffer.GetPrimitive (primitiveIndex);\r\n                let offset = writer.GetPosition ();\r\n                for (let i = 0; i < primitive.indices.length; i++) {\r\n                    writer.WriteUnsignedInteger32 (primitive.indices[i]);\r\n                }\r\n                for (let i = 0; i < primitive.vertices.length; i++) {\r\n                    writer.WriteFloat32 (primitive.vertices[i]);\r\n                }\r\n                for (let i = 0; i < primitive.colors.length; i++) {\r\n                    writer.WriteFloat32 (SRGBToLinear (primitive.colors[i]));\r\n                }\r\n                for (let i = 0; i < primitive.normals.length; i++) {\r\n                    writer.WriteFloat32 (primitive.normals[i]);\r\n                }\r\n                for (let i = 0; i < primitive.uvs.length; i++) {\r\n                    let texCoord = primitive.uvs[i];\r\n                    if (i % 2 === 1) {\r\n                        texCoord *= -1.0;\r\n                    }\r\n                    writer.WriteFloat32 (texCoord);\r\n                }\r\n                meshData.offsets.push (offset);\r\n                meshData.sizes.push (writer.GetPosition () - offset);\r\n            }\r\n        }\r\n\r\n        return writer.GetBuffer ();\r\n    }\r\n\r\n    GetMainJson (meshDataArr)\r\n    {\r\n        class BufferViewCreator\r\n        {\r\n            constructor (mainJson, byteOffset)\r\n            {\r\n                this.mainJson = mainJson;\r\n                this.byteOffset = byteOffset;\r\n            }\r\n\r\n            AddBufferView (byteLength)\r\n            {\r\n                this.mainJson.bufferViews.push ({\r\n                    buffer : 0,\r\n                    byteOffset : this.byteOffset,\r\n                    byteLength : byteLength,\r\n                });\r\n                this.byteOffset += byteLength;\r\n                return this.mainJson.bufferViews.length - 1;\r\n            }\r\n        }\r\n\r\n        let mainJson = {\r\n            asset : {\r\n                generator : 'https://3dviewer.net',\r\n                version : '2.0'\r\n            },\r\n            scene : 0,\r\n            scenes : [\r\n                {\r\n                    nodes : []\r\n                }\r\n            ],\r\n            nodes : [],\r\n            materials : [],\r\n            meshes : [],\r\n            buffers : [],\r\n            bufferViews : [],\r\n            accessors : []\r\n        };\r\n\r\n        for (let meshIndex = 0; meshIndex < meshDataArr.length; meshIndex++) {\r\n            let meshData = meshDataArr[meshIndex];\r\n            mainJson.scenes[0].nodes.push (meshIndex);\r\n            mainJson.nodes.push ({\r\n                mesh : meshIndex\r\n            });\r\n            let jsonMesh = {\r\n                name : this.GetExportedMeshName (meshData.name),\r\n                primitives : []\r\n            };\r\n\r\n            let primitives = meshData.buffer.primitives;\r\n            for (let primitiveIndex = 0; primitiveIndex < primitives.length; primitiveIndex++) {\r\n                let primitive = primitives[primitiveIndex];\r\n\r\n                let bufferViewCreator = new BufferViewCreator (mainJson, meshData.offsets[primitiveIndex]);\r\n                let indicesBufferView = bufferViewCreator.AddBufferView (primitive.indices.length * this.components.index.size);\r\n                let verticesBufferView = bufferViewCreator.AddBufferView (primitive.vertices.length * this.components.number.size);\r\n                let colorsBufferView = null;\r\n                if (primitive.colors.length > 0) {\r\n                    colorsBufferView = bufferViewCreator.AddBufferView (primitive.colors.length * this.components.number.size);\r\n                }\r\n                let normalsBufferView = bufferViewCreator.AddBufferView (primitive.normals.length * this.components.number.size);\r\n                let uvsBufferView = null;\r\n                if (primitive.uvs.length > 0) {\r\n                    uvsBufferView = bufferViewCreator.AddBufferView (primitive.uvs.length * this.components.number.size);\r\n                }\r\n\r\n                let jsonPrimitive = {\r\n                    attributes : {},\r\n                    mode : 4,\r\n                    material : primitive.material\r\n                };\r\n\r\n                let bounds = primitive.GetBounds ();\r\n\r\n                mainJson.accessors.push ({\r\n                    bufferView : indicesBufferView,\r\n                    byteOffset : 0,\r\n                    componentType : this.components.index.type,\r\n                    count : primitive.indices.length,\r\n                    type : 'SCALAR'\r\n                });\r\n                jsonPrimitive.indices = mainJson.accessors.length - 1;\r\n\r\n                mainJson.accessors.push ({\r\n                    bufferView : verticesBufferView,\r\n                    byteOffset : 0,\r\n                    componentType : this.components.number.type,\r\n                    count : primitive.vertices.length / 3,\r\n                    min : bounds.min,\r\n                    max : bounds.max,\r\n                    type : 'VEC3'\r\n                });\r\n                jsonPrimitive.attributes.POSITION = mainJson.accessors.length - 1;\r\n\r\n                if (colorsBufferView !== null) {\r\n                    mainJson.accessors.push ({\r\n                        bufferView : colorsBufferView,\r\n                        byteOffset : 0,\r\n                        componentType : this.components.number.type,\r\n                        count : primitive.colors.length / 3,\r\n                        type : 'VEC3'\r\n                    });\r\n                    jsonPrimitive.attributes.COLOR_0 = mainJson.accessors.length - 1;\r\n                }\r\n\r\n                mainJson.accessors.push ({\r\n                    bufferView : normalsBufferView,\r\n                    byteOffset : 0,\r\n                    componentType : this.components.number.type,\r\n                    count : primitive.normals.length / 3,\r\n                    type : 'VEC3'\r\n                });\r\n                jsonPrimitive.attributes.NORMAL = mainJson.accessors.length - 1;\r\n\r\n                if (uvsBufferView !== null) {\r\n                    mainJson.accessors.push ({\r\n                        bufferView : uvsBufferView,\r\n                        byteOffset : 0,\r\n                        componentType : this.components.number.type,\r\n                        count : primitive.uvs.length / 2,\r\n                        type : 'VEC2'\r\n                    });\r\n                    jsonPrimitive.attributes.TEXCOORD_0 = mainJson.accessors.length - 1;\r\n                }\r\n\r\n                jsonMesh.primitives.push (jsonPrimitive);\r\n            }\r\n            mainJson.meshes.push (jsonMesh);\r\n        }\r\n\r\n        return mainJson;\r\n    }\r\n\r\n    ExportMaterials (exporterModel, mainJson, addTexture)\r\n    {\r\n        function ExportMaterial (obj, mainJson, material, addTexture)\r\n        {\r\n            function ColorToRGBA (color, opacity)\r\n            {\r\n                return [\r\n                    SRGBToLinear (color.r / 255.0),\r\n                    SRGBToLinear (color.g / 255.0),\r\n                    SRGBToLinear (color.b / 255.0),\r\n                    opacity\r\n                ];\r\n            }\r\n\r\n            function ColorToRGB (color)\r\n            {\r\n                return [\r\n                    SRGBToLinear (color.r / 255.0),\r\n                    SRGBToLinear (color.g / 255.0),\r\n                    SRGBToLinear (color.b / 255.0)\r\n                ];\r\n            }\r\n\r\n            function GetTextureParams (mainJson, texture, addTexture)\r\n            {\r\n                if (texture === null || !texture.IsValid ()) {\r\n                    return null;\r\n                }\r\n\r\n                if (mainJson.images === undefined) {\r\n                    mainJson.images = [];\r\n                }\r\n                if (mainJson.textures === undefined) {\r\n                    mainJson.textures = [];\r\n                }\r\n\r\n                let textureIndex = addTexture (texture);\r\n                let textureParams = {\r\n                    index : textureIndex\r\n                };\r\n\r\n                if (texture.HasTransformation ()) {\r\n                    let extensionName = 'KHR_texture_transform';\r\n                    if (mainJson.extensionsUsed === undefined) {\r\n                        mainJson.extensionsUsed = [];\r\n                    }\r\n                    if (mainJson.extensionsUsed.indexOf (extensionName) === -1) {\r\n                        mainJson.extensionsUsed.push (extensionName);\r\n                    }\r\n                    textureParams.extensions = {\r\n                        KHR_texture_transform : {\r\n                            offset : [texture.offset.x, -texture.offset.y],\r\n                            scale : [texture.scale.x, texture.scale.y],\r\n                            rotation : -texture.rotation\r\n                        }\r\n                    };\r\n                }\r\n\r\n                return textureParams;\r\n            }\r\n\r\n            let jsonMaterial = {\r\n                name : obj.GetExportedMaterialName (material.name),\r\n                pbrMetallicRoughness : {\r\n                    baseColorFactor : ColorToRGBA (material.color, material.opacity)\r\n                },\r\n                emissiveFactor : ColorToRGB (material.emissive),\r\n                doubleSided : true,\r\n                alphaMode : 'OPAQUE'\r\n            };\r\n\r\n            if (material.transparent) {\r\n                // TODO: mask, alphaCutoff?\r\n                jsonMaterial.alphaMode = 'BLEND';\r\n            }\r\n\r\n            let baseColorTexture = GetTextureParams (mainJson, material.diffuseMap, addTexture);\r\n            if (baseColorTexture !== null) {\r\n                if (!material.multiplyDiffuseMap) {\r\n                    jsonMaterial.pbrMetallicRoughness.baseColorFactor = ColorToRGBA (new RGBColor (255, 255, 255), material.opacity);\r\n                }\r\n                jsonMaterial.pbrMetallicRoughness.baseColorTexture = baseColorTexture;\r\n            }\r\n            if (material.type === MaterialType.Physical) {\r\n                let metallicTexture = GetTextureParams (mainJson, material.metalnessMap, addTexture);\r\n                if (metallicTexture !== null) {\r\n                    jsonMaterial.pbrMetallicRoughness.metallicRoughnessTexture = metallicTexture;\r\n                } else {\r\n                    jsonMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;\r\n                    jsonMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;\r\n                }\r\n            }\r\n            let normalTexture = GetTextureParams (mainJson, material.normalMap, addTexture);\r\n            if (normalTexture !== null) {\r\n                jsonMaterial.normalTexture = normalTexture;\r\n            }\r\n            let emissiveTexture = GetTextureParams (mainJson, material.emissiveMap, addTexture);\r\n            if (emissiveTexture !== null) {\r\n                jsonMaterial.emissiveTexture = emissiveTexture;\r\n            }\r\n\r\n            mainJson.materials.push (jsonMaterial);\r\n        }\r\n\r\n        for (let materialIndex = 0; materialIndex < exporterModel.MaterialCount (); materialIndex++) {\r\n            let material = exporterModel.GetMaterial (materialIndex);\r\n            ExportMaterial (this, mainJson, material, addTexture);\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { Coord2D, CoordIsEqual2D } from '../geometry/coord2d.js';\nimport { CoordIsEqual3D } from '../geometry/coord3d.js';\nimport { RGBColor, RGBColorIsEqual } from './color.js';\nexport class MeshPrimitiveBuffer {\n  constructor() {\n    this.indices = [];\n    this.vertices = [];\n    this.colors = [];\n    this.normals = [];\n    this.uvs = [];\n    this.material = null;\n  }\n\n  GetBounds() {\n    let min = [Infinity, Infinity, Infinity];\n    let max = [-Infinity, -Infinity, -Infinity];\n\n    for (let i = 0; i < this.vertices.length / 3; i++) {\n      for (let j = 0; j < 3; j++) {\n        min[j] = Math.min(min[j], this.vertices[i * 3 + j]);\n        max[j] = Math.max(max[j], this.vertices[i * 3 + j]);\n      }\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  }\n\n  GetByteLength(indexTypeSize, numberTypeSize) {\n    let indexCount = this.indices.length;\n    let numberCount = this.vertices.length + this.colors.length + this.normals.length + this.uvs.length;\n    return indexCount * indexTypeSize + numberCount * numberTypeSize;\n  }\n\n}\nexport class MeshBuffer {\n  constructor() {\n    this.primitives = [];\n  }\n\n  PrimitiveCount() {\n    return this.primitives.length;\n  }\n\n  GetPrimitive(index) {\n    return this.primitives[index];\n  }\n\n  GetByteLength(indexTypeSize, numberTypeSize) {\n    let byteLength = 0;\n\n    for (let i = 0; i < this.primitives.length; i++) {\n      let primitive = this.primitives[i];\n      byteLength += primitive.GetByteLength(indexTypeSize, numberTypeSize);\n    }\n\n    return byteLength;\n  }\n\n}\nexport function ConvertMeshToMeshBuffer(mesh) {\n  function AddVertexToPrimitiveBuffer(mesh, indices, primitiveBuffer, meshVertexToPrimitiveVertices) {\n    function GetColorOrDefault(mesh, colorIndex, forceColors) {\n      if (colorIndex !== null) {\n        return mesh.GetVertexColor(colorIndex);\n      } else if (forceColors) {\n        return new RGBColor(0, 0, 0);\n      } else {\n        return null;\n      }\n    }\n\n    function GetUVOrDefault(mesh, uvIndex, forceUVs) {\n      if (uvIndex !== null) {\n        return mesh.GetTextureUV(uvIndex);\n      } else if (forceUVs) {\n        return new Coord2D(0.0, 0.0);\n      } else {\n        return null;\n      }\n    }\n\n    function AddVertex(mesh, indices, primitiveBuffer) {\n      let forceColors = mesh.VertexColorCount() > 0;\n      let forceUVs = mesh.TextureUVCount() > 0;\n      let vertex = mesh.GetVertex(indices.vertex);\n      let normal = mesh.GetNormal(indices.normal);\n      let primitiveVertexIndex = primitiveBuffer.vertices.length / 3;\n      primitiveBuffer.indices.push(primitiveVertexIndex);\n      primitiveBuffer.vertices.push(vertex.x, vertex.y, vertex.z);\n      let color = GetColorOrDefault(mesh, indices.color, forceColors);\n\n      if (color !== null) {\n        primitiveBuffer.colors.push(color.r / 255.0, color.g / 255.0, color.b / 255.0);\n      }\n\n      primitiveBuffer.normals.push(normal.x, normal.y, normal.z);\n      let uv = GetUVOrDefault(mesh, indices.uv, forceUVs);\n\n      if (uv !== null) {\n        primitiveBuffer.uvs.push(uv.x, uv.y);\n      }\n\n      return {\n        index: primitiveVertexIndex,\n        color: color,\n        normal: normal,\n        uv: uv\n      };\n    }\n\n    function FindMatchingPrimitiveVertex(mesh, primitiveVertices, indices) {\n      function IsEqualColor(mesh, colorIndex, existingColor) {\n        if (existingColor === null && colorIndex === null) {\n          return true;\n        }\n\n        let color = GetColorOrDefault(mesh, colorIndex, true);\n        return RGBColorIsEqual(existingColor, color);\n      }\n\n      function IsEqualNormal(mesh, normalIndex, existingNormal) {\n        let normal = mesh.GetNormal(normalIndex);\n        return CoordIsEqual3D(existingNormal, normal);\n      }\n\n      function IsEqualUV(mesh, uvIndex, existingUv) {\n        if (existingUv === null && uvIndex === null) {\n          return true;\n        }\n\n        let uv = GetUVOrDefault(mesh, uvIndex, true);\n        return CoordIsEqual2D(existingUv, uv);\n      }\n\n      for (let i = 0; i < primitiveVertices.length; i++) {\n        let primitiveVertex = primitiveVertices[i];\n        let equalColor = IsEqualColor(mesh, indices.color, primitiveVertex.color);\n        let equalNormal = IsEqualNormal(mesh, indices.normal, primitiveVertex.normal);\n        let equalUv = IsEqualUV(mesh, indices.uv, primitiveVertex.uv);\n\n        if (equalColor && equalNormal && equalUv) {\n          return primitiveVertex;\n        }\n      }\n\n      return null;\n    }\n\n    if (meshVertexToPrimitiveVertices.has(indices.vertex)) {\n      let primitiveVertices = meshVertexToPrimitiveVertices.get(indices.vertex);\n      let existingPrimitiveVertex = FindMatchingPrimitiveVertex(mesh, primitiveVertices, indices);\n\n      if (existingPrimitiveVertex !== null) {\n        primitiveBuffer.indices.push(existingPrimitiveVertex.index);\n      } else {\n        let primitiveVertex = AddVertex(mesh, indices, primitiveBuffer);\n        primitiveVertices.push(primitiveVertex);\n      }\n    } else {\n      let primitiveVertex = AddVertex(mesh, indices, primitiveBuffer);\n      meshVertexToPrimitiveVertices.set(indices.vertex, [primitiveVertex]);\n    }\n  }\n\n  let meshBuffer = new MeshBuffer();\n  let triangleCount = mesh.TriangleCount();\n\n  if (triangleCount === 0) {\n    return null;\n  }\n\n  let triangleIndices = [];\n\n  for (let i = 0; i < triangleCount; i++) {\n    triangleIndices.push(i);\n  }\n\n  triangleIndices.sort((a, b) => {\n    let aTriangle = mesh.GetTriangle(a);\n    let bTriangle = mesh.GetTriangle(b);\n    return aTriangle.mat - bTriangle.mat;\n  });\n  let primitiveBuffer = null;\n  let meshVertexToPrimitiveVertices = null;\n\n  for (let i = 0; i < triangleIndices.length; i++) {\n    let triangleIndex = triangleIndices[i];\n    let triangle = mesh.GetTriangle(triangleIndex);\n\n    if (primitiveBuffer === null || primitiveBuffer.material !== triangle.mat) {\n      primitiveBuffer = new MeshPrimitiveBuffer();\n      primitiveBuffer.material = triangle.mat;\n      meshVertexToPrimitiveVertices = new Map();\n      meshBuffer.primitives.push(primitiveBuffer);\n    }\n\n    let v0Indices = {\n      vertex: triangle.v0,\n      color: triangle.c0,\n      normal: triangle.n0,\n      uv: triangle.u0\n    };\n    let v1Indices = {\n      vertex: triangle.v1,\n      color: triangle.c1,\n      normal: triangle.n1,\n      uv: triangle.u1\n    };\n    let v2Indices = {\n      vertex: triangle.v2,\n      color: triangle.c2,\n      normal: triangle.n2,\n      uv: triangle.u2\n    };\n    AddVertexToPrimitiveBuffer(mesh, v0Indices, primitiveBuffer, meshVertexToPrimitiveVertices);\n    AddVertexToPrimitiveBuffer(mesh, v1Indices, primitiveBuffer, meshVertexToPrimitiveVertices);\n    AddVertexToPrimitiveBuffer(mesh, v2Indices, primitiveBuffer, meshVertexToPrimitiveVertices);\n  }\n\n  return meshBuffer;\n}","map":{"version":3,"names":["Coord2D","CoordIsEqual2D","CoordIsEqual3D","RGBColor","RGBColorIsEqual","MeshPrimitiveBuffer","constructor","indices","vertices","colors","normals","uvs","material","GetBounds","min","Infinity","max","i","length","j","Math","GetByteLength","indexTypeSize","numberTypeSize","indexCount","numberCount","MeshBuffer","primitives","PrimitiveCount","GetPrimitive","index","byteLength","primitive","ConvertMeshToMeshBuffer","mesh","AddVertexToPrimitiveBuffer","primitiveBuffer","meshVertexToPrimitiveVertices","GetColorOrDefault","colorIndex","forceColors","GetVertexColor","GetUVOrDefault","uvIndex","forceUVs","GetTextureUV","AddVertex","VertexColorCount","TextureUVCount","vertex","GetVertex","normal","GetNormal","primitiveVertexIndex","push","x","y","z","color","r","g","b","uv","FindMatchingPrimitiveVertex","primitiveVertices","IsEqualColor","existingColor","IsEqualNormal","normalIndex","existingNormal","IsEqualUV","existingUv","primitiveVertex","equalColor","equalNormal","equalUv","has","get","existingPrimitiveVertex","set","meshBuffer","triangleCount","TriangleCount","triangleIndices","sort","a","aTriangle","GetTriangle","bTriangle","mat","triangleIndex","triangle","Map","v0Indices","v0","c0","n0","u0","v1Indices","v1","c1","n1","u1","v2Indices","v2","c2","n2","u2"],"sources":["/Users/rohansagar/Desktop/node+react/client/node-react-3d/node_modules/online-3d-viewer/source/engine/model/meshbuffer.js"],"sourcesContent":["import { Coord2D, CoordIsEqual2D } from '../geometry/coord2d.js';\r\nimport { CoordIsEqual3D } from '../geometry/coord3d.js';\r\nimport { RGBColor, RGBColorIsEqual } from './color.js';\r\n\r\nexport class MeshPrimitiveBuffer\r\n{\r\n    constructor ()\r\n    {\r\n        this.indices = [];\r\n        this.vertices = [];\r\n        this.colors = [];\r\n        this.normals = [];\r\n        this.uvs = [];\r\n        this.material = null;\r\n    }\r\n\r\n    GetBounds ()\r\n    {\r\n        let min = [Infinity, Infinity, Infinity];\r\n        let max = [-Infinity, -Infinity, -Infinity];\r\n        for (let i = 0; i < this.vertices.length / 3; i++) {\r\n            for (let j = 0; j < 3; j++) {\r\n                min[j] = Math.min (min[j], this.vertices[i * 3 + j]);\r\n                max[j] = Math.max (max[j], this.vertices[i * 3 + j]);\r\n            }\r\n        }\r\n        return {\r\n            min : min,\r\n            max : max\r\n        };\r\n    }\r\n\r\n    GetByteLength (indexTypeSize, numberTypeSize)\r\n    {\r\n        let indexCount = this.indices.length;\r\n        let numberCount = this.vertices.length + this.colors.length + this.normals.length + this.uvs.length;\r\n        return indexCount * indexTypeSize + numberCount * numberTypeSize;\r\n    }\r\n}\r\n\r\nexport class MeshBuffer\r\n{\r\n    constructor ()\r\n    {\r\n        this.primitives = [];\r\n    }\r\n\r\n    PrimitiveCount ()\r\n    {\r\n        return this.primitives.length;\r\n    }\r\n\r\n    GetPrimitive (index)\r\n    {\r\n        return this.primitives[index];\r\n    }\r\n\r\n    GetByteLength (indexTypeSize, numberTypeSize)\r\n    {\r\n        let byteLength = 0;\r\n        for (let i = 0; i < this.primitives.length; i++) {\r\n            let primitive = this.primitives[i];\r\n            byteLength += primitive.GetByteLength (indexTypeSize, numberTypeSize);\r\n        }\r\n        return byteLength;\r\n    }\r\n}\r\n\r\nexport function ConvertMeshToMeshBuffer (mesh)\r\n{\r\n    function AddVertexToPrimitiveBuffer (mesh, indices, primitiveBuffer, meshVertexToPrimitiveVertices)\r\n    {\r\n        function GetColorOrDefault (mesh, colorIndex, forceColors)\r\n        {\r\n            if (colorIndex !== null) {\r\n                return mesh.GetVertexColor (colorIndex);\r\n            } else if (forceColors) {\r\n                return new RGBColor (0, 0, 0);\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        function GetUVOrDefault (mesh, uvIndex, forceUVs)\r\n        {\r\n            if (uvIndex !== null) {\r\n                return mesh.GetTextureUV (uvIndex);\r\n            } else if (forceUVs) {\r\n                return new Coord2D (0.0, 0.0);\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        function AddVertex (mesh, indices, primitiveBuffer)\r\n        {\r\n            let forceColors = mesh.VertexColorCount () > 0;\r\n            let forceUVs = mesh.TextureUVCount () > 0;\r\n\r\n            let vertex = mesh.GetVertex (indices.vertex);\r\n            let normal = mesh.GetNormal (indices.normal);\r\n\r\n            let primitiveVertexIndex = primitiveBuffer.vertices.length / 3;\r\n            primitiveBuffer.indices.push (primitiveVertexIndex);\r\n            primitiveBuffer.vertices.push (vertex.x, vertex.y, vertex.z);\r\n\r\n            let color = GetColorOrDefault (mesh, indices.color, forceColors);\r\n            if (color !== null) {\r\n                primitiveBuffer.colors.push (color.r / 255.0, color.g / 255.0, color.b / 255.0);\r\n            }\r\n\r\n            primitiveBuffer.normals.push (normal.x, normal.y, normal.z);\r\n\r\n            let uv = GetUVOrDefault (mesh, indices.uv, forceUVs);\r\n            if (uv !== null) {\r\n                primitiveBuffer.uvs.push (uv.x, uv.y);\r\n            }\r\n\r\n            return {\r\n                index : primitiveVertexIndex,\r\n                color : color,\r\n                normal : normal,\r\n                uv : uv\r\n            };\r\n        }\r\n\r\n        function FindMatchingPrimitiveVertex (mesh, primitiveVertices, indices)\r\n        {\r\n            function IsEqualColor (mesh, colorIndex, existingColor)\r\n            {\r\n                if (existingColor === null && colorIndex === null) {\r\n                    return true;\r\n                }\r\n                let color = GetColorOrDefault (mesh, colorIndex, true);\r\n                return RGBColorIsEqual (existingColor, color);\r\n            }\r\n\r\n            function IsEqualNormal (mesh, normalIndex, existingNormal)\r\n            {\r\n                let normal = mesh.GetNormal (normalIndex);\r\n                return CoordIsEqual3D (existingNormal, normal);\r\n            }\r\n\r\n            function IsEqualUV (mesh, uvIndex, existingUv)\r\n            {\r\n                if (existingUv === null && uvIndex === null) {\r\n                    return true;\r\n                }\r\n                let uv = GetUVOrDefault (mesh, uvIndex, true);\r\n                return CoordIsEqual2D (existingUv, uv);\r\n            }\r\n\r\n            for (let i = 0; i < primitiveVertices.length; i++) {\r\n                let primitiveVertex = primitiveVertices[i];\r\n                let equalColor = IsEqualColor (mesh, indices.color, primitiveVertex.color);\r\n                let equalNormal = IsEqualNormal (mesh, indices.normal, primitiveVertex.normal);\r\n                let equalUv = IsEqualUV (mesh, indices.uv, primitiveVertex.uv);\r\n                if (equalColor && equalNormal && equalUv) {\r\n                    return primitiveVertex;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        if (meshVertexToPrimitiveVertices.has (indices.vertex)) {\r\n            let primitiveVertices = meshVertexToPrimitiveVertices.get (indices.vertex);\r\n            let existingPrimitiveVertex = FindMatchingPrimitiveVertex (mesh, primitiveVertices, indices);\r\n            if (existingPrimitiveVertex !== null) {\r\n                primitiveBuffer.indices.push (existingPrimitiveVertex.index);\r\n            } else {\r\n                let primitiveVertex = AddVertex (mesh, indices, primitiveBuffer);\r\n                primitiveVertices.push (primitiveVertex);\r\n            }\r\n        } else {\r\n            let primitiveVertex = AddVertex (mesh, indices, primitiveBuffer);\r\n            meshVertexToPrimitiveVertices.set (indices.vertex, [primitiveVertex]);\r\n        }\r\n    }\r\n\r\n    let meshBuffer = new MeshBuffer ();\r\n\r\n    let triangleCount = mesh.TriangleCount ();\r\n    if (triangleCount === 0) {\r\n        return null;\r\n    }\r\n\r\n    let triangleIndices = [];\r\n    for (let i = 0; i < triangleCount; i++) {\r\n        triangleIndices.push (i);\r\n    }\r\n    triangleIndices.sort ((a, b) => {\r\n        let aTriangle = mesh.GetTriangle (a);\r\n        let bTriangle = mesh.GetTriangle (b);\r\n        return aTriangle.mat - bTriangle.mat;\r\n    });\r\n\r\n    let primitiveBuffer = null;\r\n    let meshVertexToPrimitiveVertices = null;\r\n    for (let i = 0; i < triangleIndices.length; i++) {\r\n        let triangleIndex = triangleIndices[i];\r\n        let triangle = mesh.GetTriangle (triangleIndex);\r\n        if (primitiveBuffer === null || primitiveBuffer.material !== triangle.mat) {\r\n            primitiveBuffer = new MeshPrimitiveBuffer ();\r\n            primitiveBuffer.material = triangle.mat;\r\n            meshVertexToPrimitiveVertices = new Map ();\r\n            meshBuffer.primitives.push (primitiveBuffer);\r\n        }\r\n        let v0Indices = {\r\n            vertex : triangle.v0,\r\n            color : triangle.c0,\r\n            normal : triangle.n0,\r\n            uv : triangle.u0\r\n        };\r\n        let v1Indices = {\r\n            vertex : triangle.v1,\r\n            color : triangle.c1,\r\n            normal : triangle.n1,\r\n            uv : triangle.u1\r\n        };\r\n        let v2Indices = {\r\n            vertex : triangle.v2,\r\n            color : triangle.c2,\r\n            normal : triangle.n2,\r\n            uv : triangle.u2\r\n        };\r\n\r\n        AddVertexToPrimitiveBuffer (mesh, v0Indices, primitiveBuffer, meshVertexToPrimitiveVertices);\r\n        AddVertexToPrimitiveBuffer (mesh, v1Indices, primitiveBuffer, meshVertexToPrimitiveVertices);\r\n        AddVertexToPrimitiveBuffer (mesh, v2Indices, primitiveBuffer, meshVertexToPrimitiveVertices);\r\n    }\r\n\r\n    return meshBuffer;\r\n}\r\n"],"mappings":"AAAA,SAASA,OAAT,EAAkBC,cAAlB,QAAwC,wBAAxC;AACA,SAASC,cAAT,QAA+B,wBAA/B;AACA,SAASC,QAAT,EAAmBC,eAAnB,QAA0C,YAA1C;AAEA,OAAO,MAAMC,mBAAN,CACP;EACIC,WAAW,GACX;IACI,KAAKC,OAAL,GAAe,EAAf;IACA,KAAKC,QAAL,GAAgB,EAAhB;IACA,KAAKC,MAAL,GAAc,EAAd;IACA,KAAKC,OAAL,GAAe,EAAf;IACA,KAAKC,GAAL,GAAW,EAAX;IACA,KAAKC,QAAL,GAAgB,IAAhB;EACH;;EAEDC,SAAS,GACT;IACI,IAAIC,GAAG,GAAG,CAACC,QAAD,EAAWA,QAAX,EAAqBA,QAArB,CAAV;IACA,IAAIC,GAAG,GAAG,CAAC,CAACD,QAAF,EAAY,CAACA,QAAb,EAAuB,CAACA,QAAxB,CAAV;;IACA,KAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKT,QAAL,CAAcU,MAAd,GAAuB,CAA3C,EAA8CD,CAAC,EAA/C,EAAmD;MAC/C,KAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;QACxBL,GAAG,CAACK,CAAD,CAAH,GAASC,IAAI,CAACN,GAAL,CAAUA,GAAG,CAACK,CAAD,CAAb,EAAkB,KAAKX,QAAL,CAAcS,CAAC,GAAG,CAAJ,GAAQE,CAAtB,CAAlB,CAAT;QACAH,GAAG,CAACG,CAAD,CAAH,GAASC,IAAI,CAACJ,GAAL,CAAUA,GAAG,CAACG,CAAD,CAAb,EAAkB,KAAKX,QAAL,CAAcS,CAAC,GAAG,CAAJ,GAAQE,CAAtB,CAAlB,CAAT;MACH;IACJ;;IACD,OAAO;MACHL,GAAG,EAAGA,GADH;MAEHE,GAAG,EAAGA;IAFH,CAAP;EAIH;;EAEDK,aAAa,CAAEC,aAAF,EAAiBC,cAAjB,EACb;IACI,IAAIC,UAAU,GAAG,KAAKjB,OAAL,CAAaW,MAA9B;IACA,IAAIO,WAAW,GAAG,KAAKjB,QAAL,CAAcU,MAAd,GAAuB,KAAKT,MAAL,CAAYS,MAAnC,GAA4C,KAAKR,OAAL,CAAaQ,MAAzD,GAAkE,KAAKP,GAAL,CAASO,MAA7F;IACA,OAAOM,UAAU,GAAGF,aAAb,GAA6BG,WAAW,GAAGF,cAAlD;EACH;;AAhCL;AAmCA,OAAO,MAAMG,UAAN,CACP;EACIpB,WAAW,GACX;IACI,KAAKqB,UAAL,GAAkB,EAAlB;EACH;;EAEDC,cAAc,GACd;IACI,OAAO,KAAKD,UAAL,CAAgBT,MAAvB;EACH;;EAEDW,YAAY,CAAEC,KAAF,EACZ;IACI,OAAO,KAAKH,UAAL,CAAgBG,KAAhB,CAAP;EACH;;EAEDT,aAAa,CAAEC,aAAF,EAAiBC,cAAjB,EACb;IACI,IAAIQ,UAAU,GAAG,CAAjB;;IACA,KAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKU,UAAL,CAAgBT,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;MAC7C,IAAIe,SAAS,GAAG,KAAKL,UAAL,CAAgBV,CAAhB,CAAhB;MACAc,UAAU,IAAIC,SAAS,CAACX,aAAV,CAAyBC,aAAzB,EAAwCC,cAAxC,CAAd;IACH;;IACD,OAAOQ,UAAP;EACH;;AAxBL;AA2BA,OAAO,SAASE,uBAAT,CAAkCC,IAAlC,EACP;EACI,SAASC,0BAAT,CAAqCD,IAArC,EAA2C3B,OAA3C,EAAoD6B,eAApD,EAAqEC,6BAArE,EACA;IACI,SAASC,iBAAT,CAA4BJ,IAA5B,EAAkCK,UAAlC,EAA8CC,WAA9C,EACA;MACI,IAAID,UAAU,KAAK,IAAnB,EAAyB;QACrB,OAAOL,IAAI,CAACO,cAAL,CAAqBF,UAArB,CAAP;MACH,CAFD,MAEO,IAAIC,WAAJ,EAAiB;QACpB,OAAO,IAAIrC,QAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,CAAP;MACH,CAFM,MAEA;QACH,OAAO,IAAP;MACH;IACJ;;IAED,SAASuC,cAAT,CAAyBR,IAAzB,EAA+BS,OAA/B,EAAwCC,QAAxC,EACA;MACI,IAAID,OAAO,KAAK,IAAhB,EAAsB;QAClB,OAAOT,IAAI,CAACW,YAAL,CAAmBF,OAAnB,CAAP;MACH,CAFD,MAEO,IAAIC,QAAJ,EAAc;QACjB,OAAO,IAAI5C,OAAJ,CAAa,GAAb,EAAkB,GAAlB,CAAP;MACH,CAFM,MAEA;QACH,OAAO,IAAP;MACH;IACJ;;IAED,SAAS8C,SAAT,CAAoBZ,IAApB,EAA0B3B,OAA1B,EAAmC6B,eAAnC,EACA;MACI,IAAII,WAAW,GAAGN,IAAI,CAACa,gBAAL,KAA2B,CAA7C;MACA,IAAIH,QAAQ,GAAGV,IAAI,CAACc,cAAL,KAAyB,CAAxC;MAEA,IAAIC,MAAM,GAAGf,IAAI,CAACgB,SAAL,CAAgB3C,OAAO,CAAC0C,MAAxB,CAAb;MACA,IAAIE,MAAM,GAAGjB,IAAI,CAACkB,SAAL,CAAgB7C,OAAO,CAAC4C,MAAxB,CAAb;MAEA,IAAIE,oBAAoB,GAAGjB,eAAe,CAAC5B,QAAhB,CAAyBU,MAAzB,GAAkC,CAA7D;MACAkB,eAAe,CAAC7B,OAAhB,CAAwB+C,IAAxB,CAA8BD,oBAA9B;MACAjB,eAAe,CAAC5B,QAAhB,CAAyB8C,IAAzB,CAA+BL,MAAM,CAACM,CAAtC,EAAyCN,MAAM,CAACO,CAAhD,EAAmDP,MAAM,CAACQ,CAA1D;MAEA,IAAIC,KAAK,GAAGpB,iBAAiB,CAAEJ,IAAF,EAAQ3B,OAAO,CAACmD,KAAhB,EAAuBlB,WAAvB,CAA7B;;MACA,IAAIkB,KAAK,KAAK,IAAd,EAAoB;QAChBtB,eAAe,CAAC3B,MAAhB,CAAuB6C,IAAvB,CAA6BI,KAAK,CAACC,CAAN,GAAU,KAAvC,EAA8CD,KAAK,CAACE,CAAN,GAAU,KAAxD,EAA+DF,KAAK,CAACG,CAAN,GAAU,KAAzE;MACH;;MAEDzB,eAAe,CAAC1B,OAAhB,CAAwB4C,IAAxB,CAA8BH,MAAM,CAACI,CAArC,EAAwCJ,MAAM,CAACK,CAA/C,EAAkDL,MAAM,CAACM,CAAzD;MAEA,IAAIK,EAAE,GAAGpB,cAAc,CAAER,IAAF,EAAQ3B,OAAO,CAACuD,EAAhB,EAAoBlB,QAApB,CAAvB;;MACA,IAAIkB,EAAE,KAAK,IAAX,EAAiB;QACb1B,eAAe,CAACzB,GAAhB,CAAoB2C,IAApB,CAA0BQ,EAAE,CAACP,CAA7B,EAAgCO,EAAE,CAACN,CAAnC;MACH;;MAED,OAAO;QACH1B,KAAK,EAAGuB,oBADL;QAEHK,KAAK,EAAGA,KAFL;QAGHP,MAAM,EAAGA,MAHN;QAIHW,EAAE,EAAGA;MAJF,CAAP;IAMH;;IAED,SAASC,2BAAT,CAAsC7B,IAAtC,EAA4C8B,iBAA5C,EAA+DzD,OAA/D,EACA;MACI,SAAS0D,YAAT,CAAuB/B,IAAvB,EAA6BK,UAA7B,EAAyC2B,aAAzC,EACA;QACI,IAAIA,aAAa,KAAK,IAAlB,IAA0B3B,UAAU,KAAK,IAA7C,EAAmD;UAC/C,OAAO,IAAP;QACH;;QACD,IAAImB,KAAK,GAAGpB,iBAAiB,CAAEJ,IAAF,EAAQK,UAAR,EAAoB,IAApB,CAA7B;QACA,OAAOnC,eAAe,CAAE8D,aAAF,EAAiBR,KAAjB,CAAtB;MACH;;MAED,SAASS,aAAT,CAAwBjC,IAAxB,EAA8BkC,WAA9B,EAA2CC,cAA3C,EACA;QACI,IAAIlB,MAAM,GAAGjB,IAAI,CAACkB,SAAL,CAAgBgB,WAAhB,CAAb;QACA,OAAOlE,cAAc,CAAEmE,cAAF,EAAkBlB,MAAlB,CAArB;MACH;;MAED,SAASmB,SAAT,CAAoBpC,IAApB,EAA0BS,OAA1B,EAAmC4B,UAAnC,EACA;QACI,IAAIA,UAAU,KAAK,IAAf,IAAuB5B,OAAO,KAAK,IAAvC,EAA6C;UACzC,OAAO,IAAP;QACH;;QACD,IAAImB,EAAE,GAAGpB,cAAc,CAAER,IAAF,EAAQS,OAAR,EAAiB,IAAjB,CAAvB;QACA,OAAO1C,cAAc,CAAEsE,UAAF,EAAcT,EAAd,CAArB;MACH;;MAED,KAAK,IAAI7C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+C,iBAAiB,CAAC9C,MAAtC,EAA8CD,CAAC,EAA/C,EAAmD;QAC/C,IAAIuD,eAAe,GAAGR,iBAAiB,CAAC/C,CAAD,CAAvC;QACA,IAAIwD,UAAU,GAAGR,YAAY,CAAE/B,IAAF,EAAQ3B,OAAO,CAACmD,KAAhB,EAAuBc,eAAe,CAACd,KAAvC,CAA7B;QACA,IAAIgB,WAAW,GAAGP,aAAa,CAAEjC,IAAF,EAAQ3B,OAAO,CAAC4C,MAAhB,EAAwBqB,eAAe,CAACrB,MAAxC,CAA/B;QACA,IAAIwB,OAAO,GAAGL,SAAS,CAAEpC,IAAF,EAAQ3B,OAAO,CAACuD,EAAhB,EAAoBU,eAAe,CAACV,EAApC,CAAvB;;QACA,IAAIW,UAAU,IAAIC,WAAd,IAA6BC,OAAjC,EAA0C;UACtC,OAAOH,eAAP;QACH;MACJ;;MACD,OAAO,IAAP;IACH;;IAED,IAAInC,6BAA6B,CAACuC,GAA9B,CAAmCrE,OAAO,CAAC0C,MAA3C,CAAJ,EAAwD;MACpD,IAAIe,iBAAiB,GAAG3B,6BAA6B,CAACwC,GAA9B,CAAmCtE,OAAO,CAAC0C,MAA3C,CAAxB;MACA,IAAI6B,uBAAuB,GAAGf,2BAA2B,CAAE7B,IAAF,EAAQ8B,iBAAR,EAA2BzD,OAA3B,CAAzD;;MACA,IAAIuE,uBAAuB,KAAK,IAAhC,EAAsC;QAClC1C,eAAe,CAAC7B,OAAhB,CAAwB+C,IAAxB,CAA8BwB,uBAAuB,CAAChD,KAAtD;MACH,CAFD,MAEO;QACH,IAAI0C,eAAe,GAAG1B,SAAS,CAAEZ,IAAF,EAAQ3B,OAAR,EAAiB6B,eAAjB,CAA/B;QACA4B,iBAAiB,CAACV,IAAlB,CAAwBkB,eAAxB;MACH;IACJ,CATD,MASO;MACH,IAAIA,eAAe,GAAG1B,SAAS,CAAEZ,IAAF,EAAQ3B,OAAR,EAAiB6B,eAAjB,CAA/B;MACAC,6BAA6B,CAAC0C,GAA9B,CAAmCxE,OAAO,CAAC0C,MAA3C,EAAmD,CAACuB,eAAD,CAAnD;IACH;EACJ;;EAED,IAAIQ,UAAU,GAAG,IAAItD,UAAJ,EAAjB;EAEA,IAAIuD,aAAa,GAAG/C,IAAI,CAACgD,aAAL,EAApB;;EACA,IAAID,aAAa,KAAK,CAAtB,EAAyB;IACrB,OAAO,IAAP;EACH;;EAED,IAAIE,eAAe,GAAG,EAAtB;;EACA,KAAK,IAAIlE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgE,aAApB,EAAmChE,CAAC,EAApC,EAAwC;IACpCkE,eAAe,CAAC7B,IAAhB,CAAsBrC,CAAtB;EACH;;EACDkE,eAAe,CAACC,IAAhB,CAAsB,CAACC,CAAD,EAAIxB,CAAJ,KAAU;IAC5B,IAAIyB,SAAS,GAAGpD,IAAI,CAACqD,WAAL,CAAkBF,CAAlB,CAAhB;IACA,IAAIG,SAAS,GAAGtD,IAAI,CAACqD,WAAL,CAAkB1B,CAAlB,CAAhB;IACA,OAAOyB,SAAS,CAACG,GAAV,GAAgBD,SAAS,CAACC,GAAjC;EACH,CAJD;EAMA,IAAIrD,eAAe,GAAG,IAAtB;EACA,IAAIC,6BAA6B,GAAG,IAApC;;EACA,KAAK,IAAIpB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkE,eAAe,CAACjE,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;IAC7C,IAAIyE,aAAa,GAAGP,eAAe,CAAClE,CAAD,CAAnC;IACA,IAAI0E,QAAQ,GAAGzD,IAAI,CAACqD,WAAL,CAAkBG,aAAlB,CAAf;;IACA,IAAItD,eAAe,KAAK,IAApB,IAA4BA,eAAe,CAACxB,QAAhB,KAA6B+E,QAAQ,CAACF,GAAtE,EAA2E;MACvErD,eAAe,GAAG,IAAI/B,mBAAJ,EAAlB;MACA+B,eAAe,CAACxB,QAAhB,GAA2B+E,QAAQ,CAACF,GAApC;MACApD,6BAA6B,GAAG,IAAIuD,GAAJ,EAAhC;MACAZ,UAAU,CAACrD,UAAX,CAAsB2B,IAAtB,CAA4BlB,eAA5B;IACH;;IACD,IAAIyD,SAAS,GAAG;MACZ5C,MAAM,EAAG0C,QAAQ,CAACG,EADN;MAEZpC,KAAK,EAAGiC,QAAQ,CAACI,EAFL;MAGZ5C,MAAM,EAAGwC,QAAQ,CAACK,EAHN;MAIZlC,EAAE,EAAG6B,QAAQ,CAACM;IAJF,CAAhB;IAMA,IAAIC,SAAS,GAAG;MACZjD,MAAM,EAAG0C,QAAQ,CAACQ,EADN;MAEZzC,KAAK,EAAGiC,QAAQ,CAACS,EAFL;MAGZjD,MAAM,EAAGwC,QAAQ,CAACU,EAHN;MAIZvC,EAAE,EAAG6B,QAAQ,CAACW;IAJF,CAAhB;IAMA,IAAIC,SAAS,GAAG;MACZtD,MAAM,EAAG0C,QAAQ,CAACa,EADN;MAEZ9C,KAAK,EAAGiC,QAAQ,CAACc,EAFL;MAGZtD,MAAM,EAAGwC,QAAQ,CAACe,EAHN;MAIZ5C,EAAE,EAAG6B,QAAQ,CAACgB;IAJF,CAAhB;IAOAxE,0BAA0B,CAAED,IAAF,EAAQ2D,SAAR,EAAmBzD,eAAnB,EAAoCC,6BAApC,CAA1B;IACAF,0BAA0B,CAAED,IAAF,EAAQgE,SAAR,EAAmB9D,eAAnB,EAAoCC,6BAApC,CAA1B;IACAF,0BAA0B,CAAED,IAAF,EAAQqE,SAAR,EAAmBnE,eAAnB,EAAoCC,6BAApC,CAA1B;EACH;;EAED,OAAO2C,UAAP;AACH"},"metadata":{},"sourceType":"module"}
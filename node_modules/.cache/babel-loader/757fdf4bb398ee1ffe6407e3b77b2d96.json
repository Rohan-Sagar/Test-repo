{"ast":null,"code":"import { Coord2D } from '../geometry/coord2d.js';\nimport { ArrayToCoord3D, Coord3D } from '../geometry/coord3d.js';\nimport { DegRad, Direction, IsNegative } from '../geometry/geometry.js';\nimport { Matrix } from '../geometry/matrix.js';\nimport { ArrayToQuaternion } from '../geometry/quaternion.js';\nimport { Transformation } from '../geometry/transformation.js';\nimport { BinaryReader } from '../io/binaryreader.js';\nimport { RGBColor, ColorComponentFromFloat } from '../model/color.js';\nimport { PhongMaterial, TextureMap } from '../model/material.js';\nimport { Mesh } from '../model/mesh.js';\nimport { FlipMeshTrianglesOrientation, TransformMesh } from '../model/meshutils.js';\nimport { Node, NodeType } from '../model/node.js';\nimport { Triangle } from '../model/triangle.js';\nimport { ImporterBase } from './importerbase.js';\nimport { UpdateMaterialTransparency } from './importerutils.js';\nconst CHUNK3DS = {\n  MAIN3DS: 0x4D4D,\n  EDIT3DS: 0x3D3D,\n  EDIT_MATERIAL: 0xAFFF,\n  MAT_NAME: 0xA000,\n  MAT_AMBIENT: 0xA010,\n  MAT_DIFFUSE: 0xA020,\n  MAT_SPECULAR: 0xA030,\n  MAT_SHININESS: 0xA040,\n  MAT_SHININESS_STRENGTH: 0xA041,\n  MAT_TRANSPARENCY: 0xA050,\n  MAT_COLOR_F: 0x0010,\n  MAT_COLOR: 0x0011,\n  MAT_LIN_COLOR: 0x0012,\n  MAT_LIN_COLOR_F: 0x0013,\n  MAT_TEXMAP: 0xA200,\n  MAT_TEXMAP_NAME: 0xA300,\n  MAT_TEXMAP_UOFFSET: 0xA358,\n  MAT_TEXMAP_VOFFSET: 0xA35A,\n  MAT_TEXMAP_USCALE: 0xA354,\n  MAT_TEXMAP_VSCALE: 0xA356,\n  MAT_TEXMAP_ROTATION: 0xA35C,\n  PERCENTAGE: 0x0030,\n  PERCENTAGE_F: 0x0031,\n  EDIT_OBJECT: 0x4000,\n  OBJ_TRIMESH: 0x4100,\n  OBJ_LIGHT: 0x4600,\n  OBJ_CAMERA: 0x4700,\n  TRI_VERTEX: 0x4110,\n  TRI_TEXVERTEX: 0x4140,\n  TRI_FACE: 0x4120,\n  TRI_TRANSFORMATION: 0x4160,\n  TRI_MATERIAL: 0x4130,\n  TRI_SMOOTH: 0x4150,\n  KF3DS: 0xB000,\n  OBJECT_NODE: 0xB002,\n  OBJECT_HIERARCHY: 0xB010,\n  OBJECT_INSTANCE_NAME: 0xB011,\n  OBJECT_PIVOT: 0xB013,\n  OBJECT_POSITION: 0xB020,\n  OBJECT_ROTATION: 0xB021,\n  OBJECT_SCALE: 0xB022,\n  OBJECT_ID: 0xB030\n};\n\nclass Importer3dsNode {\n  constructor() {\n    this.id = -1;\n    this.name = '';\n    this.flags = -1;\n    this.parentId = -1;\n    this.instanceName = '';\n    this.pivot = [0.0, 0.0, 0.0];\n    this.positions = [];\n    this.rotations = [];\n    this.scales = [];\n  }\n\n}\n\nclass Importer3dsNodeList {\n  constructor() {\n    this.nodes = [];\n    this.nodeIdToNode = new Map();\n  }\n\n  IsEmpty() {\n    return this.nodes.length === 0;\n  }\n\n  AddNode(node) {\n    this.nodes.push(node);\n    this.nodeIdToNode.set(node.nodeId, node);\n  }\n\n  GetNodes() {\n    return this.nodes;\n  }\n\n}\n\nexport class Importer3ds extends ImporterBase {\n  constructor() {\n    super();\n  }\n\n  CanImportExtension(extension) {\n    return extension === '3ds';\n  }\n\n  GetUpDirection() {\n    return Direction.Z;\n  }\n\n  ClearContent() {\n    this.materialNameToIndex = null;\n    this.meshNameToIndex = null;\n    this.nodeList = null;\n  }\n\n  ResetContent() {\n    this.materialNameToIndex = new Map();\n    this.meshNameToIndex = new Map();\n    this.nodeList = new Importer3dsNodeList();\n  }\n\n  ImportContent(fileContent, onFinish) {\n    this.ProcessBinary(fileContent);\n    onFinish();\n  }\n\n  ProcessBinary(fileContent) {\n    let reader = new BinaryReader(fileContent, true);\n    let endByte = reader.GetByteLength();\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.MAIN3DS) {\n        this.ReadMainChunk(reader, chunkLength);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n  }\n\n  ReadMainChunk(reader, length) {\n    let endByte = this.GetChunkEnd(reader, length);\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.EDIT3DS) {\n        this.ReadEditorChunk(reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.KF3DS) {\n        this.ReadKeyFrameChunk(reader, chunkLength);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n    this.BuildNodeHierarchy();\n  }\n\n  ReadEditorChunk(reader, length) {\n    let endByte = this.GetChunkEnd(reader, length);\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.EDIT_MATERIAL) {\n        this.ReadMaterialChunk(reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.EDIT_OBJECT) {\n        this.ReadObjectChunk(reader, chunkLength);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n  }\n\n  ReadMaterialChunk(reader, length) {\n    let material = new PhongMaterial();\n    let endByte = this.GetChunkEnd(reader, length);\n    let shininess = null;\n    let shininessStrength = null;\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.MAT_NAME) {\n        material.name = this.ReadName(reader);\n      } else if (chunkId === CHUNK3DS.MAT_AMBIENT) {\n        material.ambient = this.ReadColorChunk(reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.MAT_DIFFUSE) {\n        material.color = this.ReadColorChunk(reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.MAT_SPECULAR) {\n        material.specular = this.ReadColorChunk(reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.MAT_SHININESS) {\n        shininess = this.ReadPercentageChunk(reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.MAT_SHININESS_STRENGTH) {\n        shininessStrength = this.ReadPercentageChunk(reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.MAT_TRANSPARENCY) {\n        material.opacity = 1.0 - this.ReadPercentageChunk(reader, chunkLength);\n        UpdateMaterialTransparency(material);\n      } else if (chunkId === CHUNK3DS.MAT_TEXMAP) {\n        material.diffuseMap = this.ReadTextureMapChunk(reader, chunkLength);\n        UpdateMaterialTransparency(material);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n\n    if (shininess !== null && shininessStrength !== null) {\n      material.shininess = shininess * shininessStrength / 10.0;\n    }\n\n    let materialIndex = this.model.AddMaterial(material);\n    this.materialNameToIndex.set(material.name, materialIndex);\n  }\n\n  ReadTextureMapChunk(reader, length) {\n    let texture = new TextureMap();\n    let endByte = this.GetChunkEnd(reader, length);\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.MAT_TEXMAP_NAME) {\n        let textureName = this.ReadName(reader);\n        let textureBuffer = this.callbacks.getFileBuffer(textureName);\n        texture.name = textureName;\n        texture.buffer = textureBuffer;\n      } else if (chunkId === CHUNK3DS.MAT_TEXMAP_UOFFSET) {\n        texture.offset.x = reader.ReadFloat32();\n      } else if (chunkId === CHUNK3DS.MAT_TEXMAP_VOFFSET) {\n        texture.offset.y = reader.ReadFloat32();\n      } else if (chunkId === CHUNK3DS.MAT_TEXMAP_USCALE) {\n        texture.scale.x = reader.ReadFloat32();\n      } else if (chunkId === CHUNK3DS.MAT_TEXMAP_VSCALE) {\n        texture.scale.y = reader.ReadFloat32();\n      } else if (chunkId === CHUNK3DS.MAT_TEXMAP_ROTATION) {\n        texture.rotation = reader.ReadFloat32() * DegRad;\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n    return texture;\n  }\n\n  ReadColorChunk(reader, length) {\n    let color = new RGBColor(0, 0, 0);\n    let endByte = this.GetChunkEnd(reader, length);\n    let hasLinColor = false;\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.MAT_COLOR) {\n        if (!hasLinColor) {\n          color.r = reader.ReadUnsignedCharacter8();\n          color.g = reader.ReadUnsignedCharacter8();\n          color.b = reader.ReadUnsignedCharacter8();\n        }\n      } else if (chunkId === CHUNK3DS.MAT_LIN_COLOR) {\n        color.r = reader.ReadUnsignedCharacter8();\n        color.g = reader.ReadUnsignedCharacter8();\n        color.b = reader.ReadUnsignedCharacter8();\n        hasLinColor = true;\n      } else if (chunkId === CHUNK3DS.MAT_COLOR_F) {\n        if (!hasLinColor) {\n          color.r = ColorComponentFromFloat(reader.ReadFloat32());\n          color.g = ColorComponentFromFloat(reader.ReadFloat32());\n          color.b = ColorComponentFromFloat(reader.ReadFloat32());\n        }\n      } else if (chunkId === CHUNK3DS.MAT_LIN_COLOR_F) {\n        color.r = ColorComponentFromFloat(reader.ReadFloat32());\n        color.g = ColorComponentFromFloat(reader.ReadFloat32());\n        color.b = ColorComponentFromFloat(reader.ReadFloat32());\n        hasLinColor = true;\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n    return color;\n  }\n\n  ReadPercentageChunk(reader, length) {\n    let percentage = 0.0;\n    let endByte = this.GetChunkEnd(reader, length);\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.PERCENTAGE) {\n        percentage = reader.ReadUnsignedInteger16() / 100.0;\n      } else if (chunkId === CHUNK3DS.PERCENTAGE_F) {\n        percentage = reader.ReadFloat32();\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n    return percentage;\n  }\n\n  ReadObjectChunk(reader, length) {\n    let endByte = this.GetChunkEnd(reader, length);\n    let objectName = this.ReadName(reader);\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.OBJ_TRIMESH) {\n        this.ReadMeshChunk(reader, chunkLength, objectName);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n  }\n\n  ReadMeshChunk(reader, length, objectName) {\n    function ApplyMeshTransformation(mesh, meshMatrix) {\n      if (!meshMatrix.IsValid()) {\n        return;\n      }\n\n      let determinant = meshMatrix.Determinant();\n      let mirrorByX = IsNegative(determinant);\n\n      if (mirrorByX) {\n        let scaleMatrix = new Matrix().CreateScale(-1.0, 1.0, 1.0);\n        meshMatrix = scaleMatrix.MultiplyMatrix(meshMatrix);\n      }\n\n      let invMeshMatrix = meshMatrix.Invert();\n\n      if (invMeshMatrix === null) {\n        return;\n      }\n\n      let transformation = new Transformation(invMeshMatrix);\n      TransformMesh(mesh, transformation);\n\n      if (mirrorByX) {\n        FlipMeshTrianglesOrientation(mesh);\n      }\n    }\n\n    let mesh = new Mesh();\n    mesh.SetName(objectName);\n    let endByte = this.GetChunkEnd(reader, length);\n    let matrixElements = null;\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.TRI_VERTEX) {\n        this.ReadVerticesChunk(mesh, reader);\n      } else if (chunkId === CHUNK3DS.TRI_TEXVERTEX) {\n        this.ReadTextureVerticesChunk(mesh, reader);\n      } else if (chunkId === CHUNK3DS.TRI_FACE) {\n        this.ReadFacesChunk(mesh, reader, chunkLength);\n      } else if (chunkId === CHUNK3DS.TRI_TRANSFORMATION) {\n        matrixElements = this.ReadTransformationChunk(reader);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n\n    if (mesh.VertexCount() === mesh.TextureUVCount()) {\n      for (let i = 0; i < mesh.TriangleCount(); i++) {\n        let triangle = mesh.GetTriangle(i);\n        triangle.SetTextureUVs(triangle.v0, triangle.v1, triangle.v2);\n      }\n    }\n\n    let meshMatrix = new Matrix(matrixElements);\n    ApplyMeshTransformation(mesh, meshMatrix);\n    let meshIndex = this.model.AddMesh(mesh);\n    this.meshNameToIndex.set(mesh.GetName(), meshIndex);\n  }\n\n  ReadVerticesChunk(mesh, reader) {\n    let vertexCount = reader.ReadUnsignedInteger16();\n\n    for (let i = 0; i < vertexCount; i++) {\n      let x = reader.ReadFloat32();\n      let y = reader.ReadFloat32();\n      let z = reader.ReadFloat32();\n      mesh.AddVertex(new Coord3D(x, y, z));\n    }\n  }\n\n  ReadTextureVerticesChunk(mesh, reader) {\n    let texVertexCount = reader.ReadUnsignedInteger16();\n\n    for (let i = 0; i < texVertexCount; i++) {\n      let x = reader.ReadFloat32();\n      let y = reader.ReadFloat32();\n      mesh.AddTextureUV(new Coord2D(x, y));\n    }\n  }\n\n  ReadFacesChunk(mesh, reader, length) {\n    let endByte = this.GetChunkEnd(reader, length);\n    let faceCount = reader.ReadUnsignedInteger16();\n\n    for (let i = 0; i < faceCount; i++) {\n      let v0 = reader.ReadUnsignedInteger16();\n      let v1 = reader.ReadUnsignedInteger16();\n      let v2 = reader.ReadUnsignedInteger16();\n      reader.ReadUnsignedInteger16(); // flags\n\n      mesh.AddTriangle(new Triangle(v0, v1, v2));\n    }\n\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.TRI_MATERIAL) {\n        this.ReadFaceMaterialsChunk(mesh, reader);\n      } else if (chunkId === CHUNK3DS.TRI_SMOOTH) {\n        this.ReadFaceSmoothingGroupsChunk(mesh, faceCount, reader);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n  }\n\n  ReadFaceMaterialsChunk(mesh, reader) {\n    let materialName = this.ReadName(reader);\n    let materialIndex = this.materialNameToIndex.get(materialName);\n    let faceCount = reader.ReadUnsignedInteger16();\n\n    for (let i = 0; i < faceCount; i++) {\n      let faceIndex = reader.ReadUnsignedInteger16();\n      let triangle = mesh.GetTriangle(faceIndex);\n\n      if (materialIndex !== undefined) {\n        triangle.mat = materialIndex;\n      }\n    }\n  }\n\n  ReadFaceSmoothingGroupsChunk(mesh, faceCount, reader) {\n    for (let i = 0; i < faceCount; i++) {\n      let smoothingGroup = reader.ReadUnsignedInteger32();\n      let triangle = mesh.GetTriangle(i);\n      triangle.curve = smoothingGroup;\n    }\n  }\n\n  ReadTransformationChunk(reader) {\n    let matrix = [];\n\n    for (let i = 0; i < 4; i++) {\n      for (let j = 0; j < 3; j++) {\n        matrix.push(reader.ReadFloat32());\n      }\n\n      if (i < 3) {\n        matrix.push(0);\n      } else {\n        matrix.push(1);\n      }\n    }\n\n    return matrix;\n  }\n\n  ReadKeyFrameChunk(reader, length) {\n    let endByte = this.GetChunkEnd(reader, length);\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.OBJECT_NODE) {\n        this.ReadObjectNodeChunk(reader, chunkLength);\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n  }\n\n  BuildNodeHierarchy() {\n    function GetNodeTransformation(node3ds, isMeshNode) {\n      function GetNodePosition(node3ds) {\n        if (node3ds.positions.length === 0) {\n          return [0.0, 0.0, 0.0];\n        }\n\n        return node3ds.positions[0];\n      }\n\n      function GetNodeRotation(node3ds) {\n        function GetQuaternionFromAxisAndAngle(axisAngle) {\n          let result = [0.0, 0.0, 0.0, 1.0];\n          let length = Math.sqrt(axisAngle[0] * axisAngle[0] + axisAngle[1] * axisAngle[1] + axisAngle[2] * axisAngle[2]);\n\n          if (length > 0.0) {\n            let omega = axisAngle[3] * -0.5;\n            let si = Math.sin(omega) / length;\n            result = [si * axisAngle[0], si * axisAngle[1], si * axisAngle[2], Math.cos(omega)];\n          }\n\n          return result;\n        }\n\n        if (node3ds.rotations.length === 0) {\n          return [0.0, 0.0, 0.0, 1.0];\n        }\n\n        let rotation = node3ds.rotations[0];\n        return GetQuaternionFromAxisAndAngle(rotation);\n      }\n\n      function GetNodeScale(node3ds) {\n        if (node3ds.scales.length === 0) {\n          return [1.0, 1.0, 1.0];\n        }\n\n        return node3ds.scales[0];\n      }\n\n      let matrix = new Matrix();\n      matrix.ComposeTRS(ArrayToCoord3D(GetNodePosition(node3ds)), ArrayToQuaternion(GetNodeRotation(node3ds)), ArrayToCoord3D(GetNodeScale(node3ds)));\n\n      if (isMeshNode) {\n        let pivotPoint = node3ds.pivot;\n        let pivotMatrix = new Matrix().CreateTranslation(-pivotPoint[0], -pivotPoint[1], -pivotPoint[2]);\n        matrix = pivotMatrix.MultiplyMatrix(matrix);\n      }\n\n      return new Transformation(matrix);\n    }\n\n    let rootNode = this.model.GetRootNode();\n\n    if (this.nodeList.IsEmpty()) {\n      for (let meshIndex = 0; meshIndex < this.model.MeshCount(); meshIndex++) {\n        rootNode.AddMeshIndex(meshIndex);\n      }\n    } else {\n      let nodeIdToModelNode = new Map();\n\n      for (let node3ds of this.nodeList.GetNodes()) {\n        let node = new Node();\n\n        if (node3ds.name.length > 0 && node3ds.name !== '$$$DUMMY') {\n          node.SetName(node3ds.name);\n\n          if (node3ds.instanceName.length > 0) {\n            node.SetName(node.GetName() + ' ' + node3ds.instanceName);\n          }\n        }\n\n        if (node3ds.parentId === 65535 || !nodeIdToModelNode.has(node3ds.parentId)) {\n          rootNode.AddChildNode(node);\n        } else {\n          let parentNode = nodeIdToModelNode.get(node3ds.parentId);\n          parentNode.AddChildNode(node);\n        }\n\n        nodeIdToModelNode.set(node3ds.id, node);\n        let isMeshNode = this.meshNameToIndex.has(node3ds.name);\n        node.SetTransformation(GetNodeTransformation(node3ds, isMeshNode));\n\n        if (isMeshNode) {\n          node.SetType(NodeType.MeshNode);\n          node.AddMeshIndex(this.meshNameToIndex.get(node3ds.name));\n        }\n      }\n    }\n  }\n\n  ReadObjectNodeChunk(reader, length) {\n    function ReadTrackVector(obj, reader, type) {\n      let result = [];\n      reader.Skip(10);\n      let keyNum = reader.ReadInteger32();\n\n      for (let i = 0; i < keyNum; i++) {\n        reader.ReadInteger32();\n        let flags = reader.ReadUnsignedInteger16();\n\n        if (flags !== 0) {\n          reader.ReadFloat32();\n        }\n\n        let current = null;\n\n        if (type === CHUNK3DS.OBJECT_ROTATION) {\n          let tmp = reader.ReadFloat32();\n          current = obj.ReadVector(reader);\n          current[3] = tmp;\n        } else {\n          current = obj.ReadVector(reader);\n        }\n\n        result.push(current);\n      }\n\n      return result;\n    }\n\n    let node3ds = new Importer3dsNode();\n    let endByte = this.GetChunkEnd(reader, length);\n    this.ReadChunks(reader, endByte, (chunkId, chunkLength) => {\n      if (chunkId === CHUNK3DS.OBJECT_HIERARCHY) {\n        node3ds.name = this.ReadName(reader);\n        node3ds.flags = reader.ReadUnsignedInteger32();\n        node3ds.parentId = reader.ReadUnsignedInteger16();\n      } else if (chunkId === CHUNK3DS.OBJECT_INSTANCE_NAME) {\n        node3ds.instanceName = this.ReadName(reader);\n      } else if (chunkId === CHUNK3DS.OBJECT_PIVOT) {\n        node3ds.pivot = this.ReadVector(reader);\n      } else if (chunkId === CHUNK3DS.OBJECT_POSITION) {\n        node3ds.positions = ReadTrackVector(this, reader, CHUNK3DS.OBJECT_POSITION);\n      } else if (chunkId === CHUNK3DS.OBJECT_ROTATION) {\n        node3ds.rotations = ReadTrackVector(this, reader, CHUNK3DS.OBJECT_ROTATION);\n      } else if (chunkId === CHUNK3DS.OBJECT_SCALE) {\n        node3ds.scales = ReadTrackVector(this, reader, CHUNK3DS.OBJECT_SCALE);\n      } else if (chunkId === CHUNK3DS.OBJECT_ID) {\n        node3ds.id = reader.ReadUnsignedInteger16();\n      } else {\n        this.SkipChunk(reader, chunkLength);\n      }\n    });\n    this.nodeList.AddNode(node3ds);\n  }\n\n  ReadName(reader) {\n    let name = '';\n    let char = 0;\n    let count = 0;\n\n    while (count < 64) {\n      char = reader.ReadCharacter8();\n\n      if (char === 0) {\n        break;\n      }\n\n      name = name + String.fromCharCode(char);\n      count = count + 1;\n    }\n\n    return name;\n  }\n\n  ReadVector(reader) {\n    let result = [reader.ReadFloat32(), reader.ReadFloat32(), reader.ReadFloat32()];\n    return result;\n  }\n\n  ReadChunks(reader, endByte, onChunk) {\n    while (reader.GetPosition() <= endByte - 6) {\n      let chunkId = reader.ReadUnsignedInteger16();\n      let chunkLength = reader.ReadUnsignedInteger32();\n      onChunk(chunkId, chunkLength);\n    }\n  }\n\n  GetChunkEnd(reader, length) {\n    return reader.GetPosition() + length - 6;\n  }\n\n  SkipChunk(reader, length) {\n    reader.Skip(length - 6);\n  }\n\n}","map":{"version":3,"names":["Coord2D","ArrayToCoord3D","Coord3D","DegRad","Direction","IsNegative","Matrix","ArrayToQuaternion","Transformation","BinaryReader","RGBColor","ColorComponentFromFloat","PhongMaterial","TextureMap","Mesh","FlipMeshTrianglesOrientation","TransformMesh","Node","NodeType","Triangle","ImporterBase","UpdateMaterialTransparency","CHUNK3DS","MAIN3DS","EDIT3DS","EDIT_MATERIAL","MAT_NAME","MAT_AMBIENT","MAT_DIFFUSE","MAT_SPECULAR","MAT_SHININESS","MAT_SHININESS_STRENGTH","MAT_TRANSPARENCY","MAT_COLOR_F","MAT_COLOR","MAT_LIN_COLOR","MAT_LIN_COLOR_F","MAT_TEXMAP","MAT_TEXMAP_NAME","MAT_TEXMAP_UOFFSET","MAT_TEXMAP_VOFFSET","MAT_TEXMAP_USCALE","MAT_TEXMAP_VSCALE","MAT_TEXMAP_ROTATION","PERCENTAGE","PERCENTAGE_F","EDIT_OBJECT","OBJ_TRIMESH","OBJ_LIGHT","OBJ_CAMERA","TRI_VERTEX","TRI_TEXVERTEX","TRI_FACE","TRI_TRANSFORMATION","TRI_MATERIAL","TRI_SMOOTH","KF3DS","OBJECT_NODE","OBJECT_HIERARCHY","OBJECT_INSTANCE_NAME","OBJECT_PIVOT","OBJECT_POSITION","OBJECT_ROTATION","OBJECT_SCALE","OBJECT_ID","Importer3dsNode","constructor","id","name","flags","parentId","instanceName","pivot","positions","rotations","scales","Importer3dsNodeList","nodes","nodeIdToNode","Map","IsEmpty","length","AddNode","node","push","set","nodeId","GetNodes","Importer3ds","CanImportExtension","extension","GetUpDirection","Z","ClearContent","materialNameToIndex","meshNameToIndex","nodeList","ResetContent","ImportContent","fileContent","onFinish","ProcessBinary","reader","endByte","GetByteLength","ReadChunks","chunkId","chunkLength","ReadMainChunk","SkipChunk","GetChunkEnd","ReadEditorChunk","ReadKeyFrameChunk","BuildNodeHierarchy","ReadMaterialChunk","ReadObjectChunk","material","shininess","shininessStrength","ReadName","ambient","ReadColorChunk","color","specular","ReadPercentageChunk","opacity","diffuseMap","ReadTextureMapChunk","materialIndex","model","AddMaterial","texture","textureName","textureBuffer","callbacks","getFileBuffer","buffer","offset","x","ReadFloat32","y","scale","rotation","hasLinColor","r","ReadUnsignedCharacter8","g","b","percentage","ReadUnsignedInteger16","objectName","ReadMeshChunk","ApplyMeshTransformation","mesh","meshMatrix","IsValid","determinant","Determinant","mirrorByX","scaleMatrix","CreateScale","MultiplyMatrix","invMeshMatrix","Invert","transformation","SetName","matrixElements","ReadVerticesChunk","ReadTextureVerticesChunk","ReadFacesChunk","ReadTransformationChunk","VertexCount","TextureUVCount","i","TriangleCount","triangle","GetTriangle","SetTextureUVs","v0","v1","v2","meshIndex","AddMesh","GetName","vertexCount","z","AddVertex","texVertexCount","AddTextureUV","faceCount","AddTriangle","ReadFaceMaterialsChunk","ReadFaceSmoothingGroupsChunk","materialName","get","faceIndex","undefined","mat","smoothingGroup","ReadUnsignedInteger32","curve","matrix","j","ReadObjectNodeChunk","GetNodeTransformation","node3ds","isMeshNode","GetNodePosition","GetNodeRotation","GetQuaternionFromAxisAndAngle","axisAngle","result","Math","sqrt","omega","si","sin","cos","GetNodeScale","ComposeTRS","pivotPoint","pivotMatrix","CreateTranslation","rootNode","GetRootNode","MeshCount","AddMeshIndex","nodeIdToModelNode","has","AddChildNode","parentNode","SetTransformation","SetType","MeshNode","ReadTrackVector","obj","type","Skip","keyNum","ReadInteger32","current","tmp","ReadVector","char","count","ReadCharacter8","String","fromCharCode","onChunk","GetPosition"],"sources":["/Users/rohansagar/Desktop/node+react/client/node-react-3d/node_modules/online-3d-viewer/source/engine/import/importer3ds.js"],"sourcesContent":["import { Coord2D } from '../geometry/coord2d.js';\r\nimport { ArrayToCoord3D, Coord3D } from '../geometry/coord3d.js';\r\nimport { DegRad, Direction, IsNegative } from '../geometry/geometry.js';\r\nimport { Matrix } from '../geometry/matrix.js';\r\nimport { ArrayToQuaternion } from '../geometry/quaternion.js';\r\nimport { Transformation } from '../geometry/transformation.js';\r\nimport { BinaryReader } from '../io/binaryreader.js';\r\nimport { RGBColor, ColorComponentFromFloat } from '../model/color.js';\r\nimport { PhongMaterial, TextureMap } from '../model/material.js';\r\nimport { Mesh } from '../model/mesh.js';\r\nimport { FlipMeshTrianglesOrientation, TransformMesh } from '../model/meshutils.js';\r\nimport { Node, NodeType } from '../model/node.js';\r\nimport { Triangle } from '../model/triangle.js';\r\nimport { ImporterBase } from './importerbase.js';\r\nimport { UpdateMaterialTransparency } from './importerutils.js';\r\n\r\nconst CHUNK3DS =\r\n{\r\n    MAIN3DS : 0x4D4D,\r\n    EDIT3DS : 0x3D3D,\r\n    EDIT_MATERIAL : 0xAFFF,\r\n    MAT_NAME : 0xA000,\r\n    MAT_AMBIENT : 0xA010,\r\n    MAT_DIFFUSE : 0xA020,\r\n    MAT_SPECULAR : 0xA030,\r\n    MAT_SHININESS : 0xA040,\r\n    MAT_SHININESS_STRENGTH : 0xA041,\r\n    MAT_TRANSPARENCY : 0xA050,\r\n    MAT_COLOR_F : 0x0010,\r\n    MAT_COLOR : 0x0011,\r\n    MAT_LIN_COLOR : 0x0012,\r\n    MAT_LIN_COLOR_F : 0x0013,\r\n    MAT_TEXMAP : 0xA200,\r\n    MAT_TEXMAP_NAME : 0xA300,\r\n    MAT_TEXMAP_UOFFSET : 0xA358,\r\n    MAT_TEXMAP_VOFFSET : 0xA35A,\r\n    MAT_TEXMAP_USCALE : 0xA354,\r\n    MAT_TEXMAP_VSCALE : 0xA356,\r\n    MAT_TEXMAP_ROTATION : 0xA35C,\r\n    PERCENTAGE : 0x0030,\r\n    PERCENTAGE_F : 0x0031,\r\n    EDIT_OBJECT : 0x4000,\r\n    OBJ_TRIMESH : 0x4100,\r\n    OBJ_LIGHT : 0x4600,\r\n    OBJ_CAMERA : 0x4700,\r\n    TRI_VERTEX : 0x4110,\r\n    TRI_TEXVERTEX : 0x4140,\r\n    TRI_FACE : 0x4120,\r\n    TRI_TRANSFORMATION : 0x4160,\r\n    TRI_MATERIAL : 0x4130,\r\n    TRI_SMOOTH : 0x4150,\r\n    KF3DS : 0xB000,\r\n    OBJECT_NODE : 0xB002,\r\n    OBJECT_HIERARCHY : 0xB010,\r\n    OBJECT_INSTANCE_NAME : 0xB011,\r\n    OBJECT_PIVOT : 0xB013,\r\n    OBJECT_POSITION : 0xB020,\r\n    OBJECT_ROTATION : 0xB021,\r\n    OBJECT_SCALE : 0xB022,\r\n    OBJECT_ID : 0xB030\r\n};\r\n\r\nclass Importer3dsNode\r\n{\r\n    constructor ()\r\n    {\r\n        this.id = -1;\r\n        this.name = '';\r\n        this.flags = -1;\r\n        this.parentId = -1;\r\n        this.instanceName = '';\r\n        this.pivot = [0.0, 0.0, 0.0];\r\n        this.positions = [];\r\n        this.rotations = [];\r\n        this.scales = [];\r\n    }\r\n}\r\n\r\nclass Importer3dsNodeList\r\n{\r\n    constructor ()\r\n    {\r\n        this.nodes = [];\r\n        this.nodeIdToNode = new Map ();\r\n    }\r\n\r\n    IsEmpty ()\r\n    {\r\n        return this.nodes.length === 0;\r\n    }\r\n\r\n    AddNode (node)\r\n    {\r\n        this.nodes.push (node);\r\n        this.nodeIdToNode.set (node.nodeId, node);\r\n    }\r\n\r\n    GetNodes ()\r\n    {\r\n        return this.nodes;\r\n    }\r\n}\r\n\r\nexport class Importer3ds extends ImporterBase\r\n{\r\n    constructor ()\r\n    {\r\n        super ();\r\n    }\r\n\r\n    CanImportExtension (extension)\r\n    {\r\n        return extension === '3ds';\r\n    }\r\n\r\n    GetUpDirection ()\r\n    {\r\n        return Direction.Z;\r\n    }\r\n\r\n    ClearContent ()\r\n    {\r\n        this.materialNameToIndex = null;\r\n        this.meshNameToIndex = null;\r\n        this.nodeList = null;\r\n    }\r\n\r\n    ResetContent ()\r\n    {\r\n        this.materialNameToIndex = new Map ();\r\n        this.meshNameToIndex = new Map ();\r\n        this.nodeList = new Importer3dsNodeList ();\r\n    }\r\n\r\n    ImportContent (fileContent, onFinish)\r\n    {\r\n        this.ProcessBinary (fileContent);\r\n        onFinish ();\r\n    }\r\n\r\n    ProcessBinary (fileContent)\r\n    {\r\n        let reader = new BinaryReader (fileContent, true);\r\n        let endByte = reader.GetByteLength ();\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.MAIN3DS) {\r\n                this.ReadMainChunk (reader, chunkLength);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n    }\r\n\r\n    ReadMainChunk (reader, length)\r\n    {\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.EDIT3DS) {\r\n                this.ReadEditorChunk (reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.KF3DS) {\r\n                this.ReadKeyFrameChunk (reader, chunkLength);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n        this.BuildNodeHierarchy ();\r\n    }\r\n\r\n    ReadEditorChunk (reader, length)\r\n    {\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.EDIT_MATERIAL) {\r\n                this.ReadMaterialChunk (reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.EDIT_OBJECT) {\r\n                this.ReadObjectChunk (reader, chunkLength);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n    }\r\n\r\n    ReadMaterialChunk (reader, length)\r\n    {\r\n        let material = new PhongMaterial ();\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        let shininess = null;\r\n        let shininessStrength = null;\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.MAT_NAME) {\r\n                material.name = this.ReadName (reader);\r\n            } else if (chunkId === CHUNK3DS.MAT_AMBIENT) {\r\n                material.ambient = this.ReadColorChunk (reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.MAT_DIFFUSE) {\r\n                material.color = this.ReadColorChunk (reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.MAT_SPECULAR) {\r\n                material.specular = this.ReadColorChunk (reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.MAT_SHININESS) {\r\n                shininess = this.ReadPercentageChunk (reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.MAT_SHININESS_STRENGTH) {\r\n                shininessStrength = this.ReadPercentageChunk (reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.MAT_TRANSPARENCY) {\r\n                material.opacity = 1.0 - this.ReadPercentageChunk (reader, chunkLength);\r\n                UpdateMaterialTransparency (material);\r\n            } else if (chunkId === CHUNK3DS.MAT_TEXMAP) {\r\n                material.diffuseMap = this.ReadTextureMapChunk (reader, chunkLength);\r\n                UpdateMaterialTransparency (material);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n\r\n        if (shininess !== null && shininessStrength !== null) {\r\n            material.shininess = shininess * shininessStrength / 10.0;\r\n        }\r\n        let materialIndex = this.model.AddMaterial (material);\r\n        this.materialNameToIndex.set (material.name, materialIndex);\r\n    }\r\n\r\n    ReadTextureMapChunk (reader, length)\r\n    {\r\n        let texture = new TextureMap ();\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.MAT_TEXMAP_NAME) {\r\n                let textureName = this.ReadName (reader);\r\n                let textureBuffer = this.callbacks.getFileBuffer (textureName);\r\n                texture.name = textureName;\r\n                texture.buffer = textureBuffer;\r\n            } else if (chunkId === CHUNK3DS.MAT_TEXMAP_UOFFSET) {\r\n                texture.offset.x = reader.ReadFloat32 ();\r\n            } else if (chunkId === CHUNK3DS.MAT_TEXMAP_VOFFSET) {\r\n                texture.offset.y = reader.ReadFloat32 ();\r\n            } else if (chunkId === CHUNK3DS.MAT_TEXMAP_USCALE) {\r\n                texture.scale.x = reader.ReadFloat32 ();\r\n            } else if (chunkId === CHUNK3DS.MAT_TEXMAP_VSCALE) {\r\n                texture.scale.y = reader.ReadFloat32 ();\r\n            } else if (chunkId === CHUNK3DS.MAT_TEXMAP_ROTATION) {\r\n                texture.rotation = reader.ReadFloat32 () * DegRad;\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n        return texture;\r\n    }\r\n\r\n    ReadColorChunk (reader, length)\r\n    {\r\n        let color = new RGBColor (0, 0, 0);\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        let hasLinColor = false;\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.MAT_COLOR) {\r\n                if (!hasLinColor) {\r\n                    color.r = reader.ReadUnsignedCharacter8 ();\r\n                    color.g = reader.ReadUnsignedCharacter8 ();\r\n                    color.b = reader.ReadUnsignedCharacter8 ();\r\n                }\r\n            } else if (chunkId === CHUNK3DS.MAT_LIN_COLOR) {\r\n                color.r = reader.ReadUnsignedCharacter8 ();\r\n                color.g = reader.ReadUnsignedCharacter8 ();\r\n                color.b = reader.ReadUnsignedCharacter8 ();\r\n                hasLinColor = true;\r\n            } else if (chunkId === CHUNK3DS.MAT_COLOR_F) {\r\n                if (!hasLinColor) {\r\n                    color.r = ColorComponentFromFloat (reader.ReadFloat32 ());\r\n                    color.g = ColorComponentFromFloat (reader.ReadFloat32 ());\r\n                    color.b = ColorComponentFromFloat (reader.ReadFloat32 ());\r\n                }\r\n            } else if (chunkId === CHUNK3DS.MAT_LIN_COLOR_F) {\r\n                color.r = ColorComponentFromFloat (reader.ReadFloat32 ());\r\n                color.g = ColorComponentFromFloat (reader.ReadFloat32 ());\r\n                color.b = ColorComponentFromFloat (reader.ReadFloat32 ());\r\n                hasLinColor = true;\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n        return color;\r\n    }\r\n\r\n    ReadPercentageChunk (reader, length)\r\n    {\r\n        let percentage = 0.0;\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.PERCENTAGE) {\r\n                percentage = reader.ReadUnsignedInteger16 () / 100.0;\r\n            } else if (chunkId === CHUNK3DS.PERCENTAGE_F) {\r\n                percentage = reader.ReadFloat32 ();\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n        return percentage;\r\n    }\r\n\r\n    ReadObjectChunk (reader, length)\r\n    {\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        let objectName = this.ReadName (reader);\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.OBJ_TRIMESH) {\r\n                this.ReadMeshChunk (reader, chunkLength, objectName);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n    }\r\n\r\n    ReadMeshChunk (reader, length, objectName)\r\n    {\r\n        function ApplyMeshTransformation (mesh, meshMatrix)\r\n        {\r\n            if (!meshMatrix.IsValid ()) {\r\n                return;\r\n            }\r\n\r\n            let determinant = meshMatrix.Determinant ();\r\n            let mirrorByX = IsNegative (determinant);\r\n            if (mirrorByX) {\r\n                let scaleMatrix = new Matrix ().CreateScale (-1.0, 1.0, 1.0);\r\n                meshMatrix = scaleMatrix.MultiplyMatrix (meshMatrix);\r\n            }\r\n\r\n            let invMeshMatrix = meshMatrix.Invert ();\r\n            if (invMeshMatrix === null) {\r\n                return;\r\n            }\r\n\r\n            let transformation = new Transformation (invMeshMatrix);\r\n            TransformMesh (mesh, transformation);\r\n            if (mirrorByX) {\r\n                FlipMeshTrianglesOrientation (mesh);\r\n            }\r\n        }\r\n\r\n        let mesh = new Mesh ();\r\n        mesh.SetName (objectName);\r\n\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        let matrixElements = null;\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.TRI_VERTEX) {\r\n                this.ReadVerticesChunk (mesh, reader);\r\n            } else if (chunkId === CHUNK3DS.TRI_TEXVERTEX) {\r\n                this.ReadTextureVerticesChunk (mesh, reader);\r\n            } else if (chunkId === CHUNK3DS.TRI_FACE) {\r\n                this.ReadFacesChunk (mesh, reader, chunkLength);\r\n            } else if (chunkId === CHUNK3DS.TRI_TRANSFORMATION) {\r\n                matrixElements = this.ReadTransformationChunk (reader);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n\r\n        if (mesh.VertexCount () === mesh.TextureUVCount ()) {\r\n            for (let i = 0; i < mesh.TriangleCount (); i++) {\r\n                let triangle = mesh.GetTriangle (i);\r\n                triangle.SetTextureUVs (\r\n                    triangle.v0,\r\n                    triangle.v1,\r\n                    triangle.v2\r\n                );\r\n            }\r\n        }\r\n\r\n        let meshMatrix = new Matrix (matrixElements);\r\n        ApplyMeshTransformation (mesh, meshMatrix);\r\n\r\n        let meshIndex = this.model.AddMesh (mesh);\r\n        this.meshNameToIndex.set (mesh.GetName (), meshIndex);\r\n    }\r\n\r\n    ReadVerticesChunk (mesh, reader)\r\n    {\r\n        let vertexCount = reader.ReadUnsignedInteger16 ();\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            let x = reader.ReadFloat32 ();\r\n            let y = reader.ReadFloat32 ();\r\n            let z = reader.ReadFloat32 ();\r\n            mesh.AddVertex (new Coord3D (x, y, z));\r\n        }\r\n    }\r\n\r\n    ReadTextureVerticesChunk (mesh, reader)\r\n    {\r\n        let texVertexCount = reader.ReadUnsignedInteger16 ();\r\n        for (let i = 0; i < texVertexCount; i++) {\r\n            let x = reader.ReadFloat32 ();\r\n            let y = reader.ReadFloat32 ();\r\n            mesh.AddTextureUV (new Coord2D (x, y));\r\n        }\r\n    }\r\n\r\n    ReadFacesChunk (mesh, reader, length)\r\n    {\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        let faceCount = reader.ReadUnsignedInteger16 ();\r\n        for (let i = 0; i < faceCount; i++) {\r\n            let v0 = reader.ReadUnsignedInteger16 ();\r\n            let v1 = reader.ReadUnsignedInteger16 ();\r\n            let v2 = reader.ReadUnsignedInteger16 ();\r\n            reader.ReadUnsignedInteger16 (); // flags\r\n            mesh.AddTriangle (new Triangle (v0, v1, v2));\r\n        }\r\n\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.TRI_MATERIAL) {\r\n                this.ReadFaceMaterialsChunk (mesh, reader);\r\n            } else if (chunkId === CHUNK3DS.TRI_SMOOTH) {\r\n                this.ReadFaceSmoothingGroupsChunk (mesh, faceCount, reader);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n    }\r\n\r\n    ReadFaceMaterialsChunk (mesh, reader)\r\n    {\r\n        let materialName = this.ReadName (reader);\r\n        let materialIndex = this.materialNameToIndex.get (materialName);\r\n        let faceCount = reader.ReadUnsignedInteger16 ();\r\n        for (let i = 0; i < faceCount; i++) {\r\n            let faceIndex = reader.ReadUnsignedInteger16 ();\r\n            let triangle = mesh.GetTriangle (faceIndex);\r\n            if (materialIndex !== undefined) {\r\n                triangle.mat = materialIndex;\r\n            }\r\n        }\r\n    }\r\n\r\n    ReadFaceSmoothingGroupsChunk (mesh, faceCount, reader)\r\n    {\r\n        for (let i = 0; i < faceCount; i++) {\r\n            let smoothingGroup = reader.ReadUnsignedInteger32 ();\r\n            let triangle = mesh.GetTriangle (i);\r\n            triangle.curve = smoothingGroup;\r\n        }\r\n    }\r\n\r\n    ReadTransformationChunk (reader)\r\n    {\r\n        let matrix = [];\r\n        for (let i = 0; i < 4; i++) {\r\n            for (let j = 0; j < 3; j++) {\r\n                matrix.push (reader.ReadFloat32 ());\r\n            }\r\n            if (i < 3) {\r\n                matrix.push (0);\r\n            } else {\r\n                matrix.push (1);\r\n            }\r\n        }\r\n        return matrix;\r\n    }\r\n\r\n    ReadKeyFrameChunk (reader, length)\r\n    {\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.OBJECT_NODE) {\r\n                this.ReadObjectNodeChunk (reader, chunkLength);\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n    }\r\n\r\n    BuildNodeHierarchy ()\r\n    {\r\n        function GetNodeTransformation (node3ds, isMeshNode)\r\n        {\r\n            function GetNodePosition (node3ds)\r\n            {\r\n                if (node3ds.positions.length === 0) {\r\n                    return [0.0, 0.0, 0.0];\r\n                }\r\n                return node3ds.positions[0];\r\n            }\r\n\r\n            function GetNodeRotation (node3ds)\r\n            {\r\n                function GetQuaternionFromAxisAndAngle (axisAngle)\r\n                {\r\n                    let result = [0.0, 0.0, 0.0, 1.0];\r\n                    let length = Math.sqrt (axisAngle[0] * axisAngle[0] + axisAngle[1] * axisAngle[1] + axisAngle[2] * axisAngle[2]);\r\n                    if (length > 0.0) {\r\n                        let omega = axisAngle[3] * -0.5;\r\n                        let si = Math.sin (omega) / length;\r\n                        result = [si * axisAngle[0], si * axisAngle[1], si * axisAngle[2], Math.cos (omega)];\r\n                    }\r\n                    return result;\r\n                }\r\n\r\n                if (node3ds.rotations.length === 0) {\r\n                    return [0.0, 0.0, 0.0, 1.0];\r\n                }\r\n\r\n                let rotation = node3ds.rotations[0];\r\n                return GetQuaternionFromAxisAndAngle (rotation);\r\n            }\r\n\r\n            function GetNodeScale (node3ds)\r\n            {\r\n                if (node3ds.scales.length === 0) {\r\n                    return [1.0, 1.0, 1.0];\r\n                }\r\n                return node3ds.scales[0];\r\n            }\r\n\r\n            let matrix = new Matrix ();\r\n            matrix.ComposeTRS (\r\n                ArrayToCoord3D (GetNodePosition (node3ds)),\r\n                ArrayToQuaternion (GetNodeRotation (node3ds)),\r\n                ArrayToCoord3D (GetNodeScale (node3ds))\r\n            );\r\n\r\n            if (isMeshNode) {\r\n                let pivotPoint = node3ds.pivot;\r\n                let pivotMatrix = new Matrix ().CreateTranslation (-pivotPoint[0], -pivotPoint[1], -pivotPoint[2]);\r\n                matrix = pivotMatrix.MultiplyMatrix (matrix);\r\n            }\r\n\r\n            return new Transformation (matrix);\r\n        }\r\n\r\n        let rootNode = this.model.GetRootNode ();\r\n        if (this.nodeList.IsEmpty ()) {\r\n            for (let meshIndex = 0; meshIndex < this.model.MeshCount (); meshIndex++) {\r\n                rootNode.AddMeshIndex (meshIndex);\r\n            }\r\n        } else {\r\n            let nodeIdToModelNode = new Map ();\r\n            for (let node3ds of this.nodeList.GetNodes ()) {\r\n                let node = new Node ();\r\n                if (node3ds.name.length > 0 && node3ds.name !== '$$$DUMMY') {\r\n                    node.SetName (node3ds.name);\r\n                    if (node3ds.instanceName.length > 0) {\r\n                        node.SetName (node.GetName () + ' ' + node3ds.instanceName);\r\n                    }\r\n                }\r\n                if (node3ds.parentId === 65535 || !nodeIdToModelNode.has (node3ds.parentId)) {\r\n                    rootNode.AddChildNode (node);\r\n                } else {\r\n                    let parentNode = nodeIdToModelNode.get (node3ds.parentId);\r\n                    parentNode.AddChildNode (node);\r\n                }\r\n                nodeIdToModelNode.set (node3ds.id, node);\r\n                let isMeshNode = this.meshNameToIndex.has (node3ds.name);\r\n                node.SetTransformation (GetNodeTransformation (node3ds, isMeshNode));\r\n                if (isMeshNode) {\r\n                    node.SetType (NodeType.MeshNode);\r\n                    node.AddMeshIndex (this.meshNameToIndex.get (node3ds.name));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    ReadObjectNodeChunk (reader, length)\r\n    {\r\n        function ReadTrackVector (obj, reader, type)\r\n        {\r\n            let result = [];\r\n            reader.Skip (10);\r\n\r\n            let keyNum = reader.ReadInteger32 ();\r\n            for (let i = 0; i < keyNum; i++) {\r\n                reader.ReadInteger32 ();\r\n                let flags = reader.ReadUnsignedInteger16 ();\r\n                if (flags !== 0) {\r\n                    reader.ReadFloat32 ();\r\n                }\r\n\r\n                let current = null;\r\n                if (type === CHUNK3DS.OBJECT_ROTATION) {\r\n                    let tmp = reader.ReadFloat32 ();\r\n                    current = obj.ReadVector (reader);\r\n                    current[3] = tmp;\r\n                } else {\r\n                    current = obj.ReadVector (reader);\r\n                }\r\n                result.push (current);\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        let node3ds = new Importer3dsNode ();\r\n        let endByte = this.GetChunkEnd (reader, length);\r\n        this.ReadChunks (reader, endByte, (chunkId, chunkLength) => {\r\n            if (chunkId === CHUNK3DS.OBJECT_HIERARCHY) {\r\n                node3ds.name = this.ReadName (reader);\r\n                node3ds.flags = reader.ReadUnsignedInteger32 ();\r\n                node3ds.parentId = reader.ReadUnsignedInteger16 ();\r\n            } else if (chunkId === CHUNK3DS.OBJECT_INSTANCE_NAME) {\r\n                node3ds.instanceName = this.ReadName (reader);\r\n            } else if (chunkId === CHUNK3DS.OBJECT_PIVOT) {\r\n                node3ds.pivot = this.ReadVector (reader);\r\n            } else if (chunkId === CHUNK3DS.OBJECT_POSITION) {\r\n                node3ds.positions = ReadTrackVector (this, reader, CHUNK3DS.OBJECT_POSITION);\r\n            } else if (chunkId === CHUNK3DS.OBJECT_ROTATION) {\r\n                node3ds.rotations = ReadTrackVector (this, reader, CHUNK3DS.OBJECT_ROTATION);\r\n            } else if (chunkId === CHUNK3DS.OBJECT_SCALE) {\r\n                node3ds.scales = ReadTrackVector (this, reader, CHUNK3DS.OBJECT_SCALE);\r\n            } else if (chunkId === CHUNK3DS.OBJECT_ID) {\r\n                node3ds.id = reader.ReadUnsignedInteger16 ();\r\n            } else {\r\n                this.SkipChunk (reader, chunkLength);\r\n            }\r\n        });\r\n\r\n        this.nodeList.AddNode (node3ds);\r\n    }\r\n\r\n    ReadName (reader)\r\n    {\r\n        let name = '';\r\n        let char = 0;\r\n        let count = 0;\r\n        while (count < 64) {\r\n            char = reader.ReadCharacter8 ();\r\n            if (char === 0) {\r\n                break;\r\n            }\r\n            name = name + String.fromCharCode (char);\r\n            count = count + 1;\r\n        }\r\n        return name;\r\n    }\r\n\r\n    ReadVector (reader)\r\n    {\r\n        let result = [\r\n            reader.ReadFloat32 (),\r\n            reader.ReadFloat32 (),\r\n            reader.ReadFloat32 ()\r\n        ];\r\n        return result;\r\n    }\r\n\r\n    ReadChunks (reader, endByte, onChunk)\r\n    {\r\n        while (reader.GetPosition () <= endByte - 6) {\r\n        let chunkId = reader.ReadUnsignedInteger16 ();\r\n            let chunkLength = reader.ReadUnsignedInteger32 ();\r\n            onChunk (chunkId, chunkLength);\r\n        }\r\n    }\r\n\r\n    GetChunkEnd (reader, length)\r\n    {\r\n        return reader.GetPosition () + length - 6;\r\n    }\r\n\r\n    SkipChunk (reader, length)\r\n    {\r\n        reader.Skip (length - 6);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}